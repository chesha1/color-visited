// ==UserScript==
// @name         color-visited 对已访问过的链接染色
// @version      2.7.0
// @author       chesha1
// @description  把访问过的链接染色成灰色
// @license      GPL-3.0-only
// @homepage     https://github.com/chesha1/color-visited
// @supportURL   https://github.com/chesha1/color-visited/issues
// @include      /https:\/\/36kr\.com\/$/
// @include      /https:\/\/36kr\.com\/motif\/\d+$/
// @include      /https:\/\/36kr\.com\/newsflashes\/$/
// @include      /https:\/\/36kr\.com\/information\/.*/
// @include      /https:\/\/36kr\.com\/topics\/\d+$/
// @include      /https:\/\/forum\.gamer\.com\.tw\/(A|B|G1)\.php\?bsn=.*/
// @include      /https:\/\/space\.bilibili\.com\/\d+(\?.*)?$/
// @include      /https:\/\/space\.bilibili\.com\/\d+\/video/
// @include      /https:\/\/space\.bilibili\.com\/\d+\/upload.*/
// @include      /https:\/\/www\.bilibili\.com\/video\/BV.*/
// @include      /https:\/\/www\.bilibili\.com\/list\/watchlater\?.*/
// @include      /https:\/\/www\.chiphell\.com\/forum-.*/
// @include      /https:\/\/www\.douban\.com\/group\/.*/
// @include      /https:\/\/forums\.e-hentai\.org\/index\.php\?showforum=\d+/
// @include      /https:\/\/e-hentai\.org\/?$/
// @include      /https:\/\/exhentai\.org\/?$/
// @include      /https:\/\/e-hentai\.org\/toplist\.php\?tl=\d+/
// @include      /https:\/\/exhentai\.org\/toplist\.php\?tl=\d+/
// @include      /https:\/\/e-hentai\.org\/\?f_search=.*/
// @include      /https:\/\/exhentai\.org\/\?f_search=.*/
// @include      /https:\/\/e-hentai\.org\/popular/
// @include      /https:\/\/exhentai\.org\/popular/
// @include      /https:\/\/www\.hacg\.me\/wp\/$/
// @include      /https:\/\/www\.hacg\.me\/wp\/[a-zA-Z].*/
// @include      /https:\/\/news\.ycombinator\.com\/.*/
// @include      /https:\/\/news\.ycombinator\.com\/newest.*/
// @include      /https:\/\/news\.ycombinator\.com\/front.*/
// @include      /https:\/\/news\.ycombinator\.com\/show.*/
// @include      /https:\/\/hostloc\.com\/forum-.*/
// @include      /https:\/\/bbs\.hupu\.com\/[a-zA-Z].*/
// @include      /https:\/\/linux\.do\/?$/
// @include      /https:\/\/linux\.do\/(latest|new|top|hot|categories)/
// @include      /https:\/\/linux\.do\/c\/.*/
// @include      /https:\/\/bbs\.nga\.cn\/thread\.php\?(fid|stid).*/
// @include      /https:\/\/ngabbs\.com\/thread\.php\?(fid|stid).*/
// @include      /https:\/\/nga\.178\.com\/thread\.php\?(fid|stid).*/
// @include      /https:\/\/www\.nodeseek\.com\/?$/
// @include      /https:\/\/www\.nodeseek\.com\/categories\/.*/
// @include      /https:\/\/www\.nodeseek\.com\/page-\d+/
// @include      /https:\/\/www\.reddit\.com\/r\/[^\/]+\/?$/
// @include      /https:\/\/seekingalpha\.com\/$/
// @include      /https:\/\/seekingalpha\.com\/symbol\/.*/
// @include      /https:\/\/www\.(south|north|blue|white|level|snow|spring|summer)-plus\.net\/thread\.php\?fid.*/
// @include      /https:\/\/bbs\.imoutolove\.me\/thread\.php\?fid.*/
// @include      /https:\/\/www\.(south|north|blue|white|level|snow|spring|summer)-plus\.net\/u\.php\?action-topic-uid-.*/
// @include      /https:\/\/www\.techflowpost\.com\/$/
// @include      /https:\/\/tieba\.baidu\.com\/f\?kw=.*/
// @include      /https:\/\/tieba\.baidu\.com\/hottopic.*/
// @include      /https:\/\/www\.v2ex\.com\/$/
// @include      /https:\/\/www\.v2ex\.com\/\?tab.*/
// @include      /https:\/\/www\.v2ex\.com\/go\/.*/
// @include      /https:\/\/www\.zhihu\.com\/$/
// @include      /https:\/\/www\.zhihu\.com\/hot$/
// @include      /https:\/\/www\.zhihu\.com\/people\/.*/
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.15.1/dist/system.min.js
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.15.1/dist/extras/named-register.min.js
// @require      data:application/javascript,%3B(typeof%20System!%3D'undefined')%26%26(System%3Dnew%20System.constructor())%3B
// @grant        GM_addStyle
// @grant        GM_getValue
// @grant        GM_registerMenuCommand
// @grant        GM_setValue
// @run-at       document-end
// @noframes
// ==/UserScript==

(e=>{if(typeof GM_addStyle=="function"){GM_addStyle(e);return}const r=document.createElement("style");r.textContent=e,document.head.append(r)})(' @charset "UTF-8";:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","\u5FAE\u8F6F\u96C5\u9ED1",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:.3s;--el-transition-duration-fast:.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(.645,.045,.355,1);--el-transition-function-fast-bezier:cubic-bezier(.23,1,.32,1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px;color-scheme:light;--el-color-primary:#409eff;--el-color-primary-light-3:rgb(121.3,187.1,255);--el-color-primary-light-5:rgb(159.5,206.5,255);--el-color-primary-light-7:rgb(197.7,225.9,255);--el-color-primary-light-8:rgb(216.8,235.6,255);--el-color-primary-light-9:rgb(235.9,245.3,255);--el-color-primary-dark-2:rgb(51.2,126.4,204);--el-color-success:#67c23a;--el-color-success-light-3:rgb(148.6,212.3,117.1);--el-color-success-light-5:rgb(179,224.5,156.5);--el-color-success-light-7:rgb(209.4,236.7,195.9);--el-color-success-light-8:rgb(224.6,242.8,215.6);--el-color-success-light-9:rgb(239.8,248.9,235.3);--el-color-success-dark-2:rgb(82.4,155.2,46.4);--el-color-warning:#e6a23c;--el-color-warning-light-3:rgb(237.5,189.9,118.5);--el-color-warning-light-5:rgb(242.5,208.5,157.5);--el-color-warning-light-7:rgb(247.5,227.1,196.5);--el-color-warning-light-8:rgb(250,236.4,216);--el-color-warning-light-9:rgb(252.5,245.7,235.5);--el-color-warning-dark-2:rgb(184,129.6,48);--el-color-danger:#f56c6c;--el-color-danger-light-3:rgb(248,152.1,152.1);--el-color-danger-light-5:rgb(250,181.5,181.5);--el-color-danger-light-7:rgb(252,210.9,210.9);--el-color-danger-light-8:rgb(253,225.6,225.6);--el-color-danger-light-9:rgb(254,240.3,240.3);--el-color-danger-dark-2:rgb(196,86.4,86.4);--el-color-error:#f56c6c;--el-color-error-light-3:rgb(248,152.1,152.1);--el-color-error-light-5:rgb(250,181.5,181.5);--el-color-error-light-7:rgb(252,210.9,210.9);--el-color-error-light-8:rgb(253,225.6,225.6);--el-color-error-light-9:rgb(254,240.3,240.3);--el-color-error-dark-2:rgb(196,86.4,86.4);--el-color-info:#909399;--el-color-info-light-3:rgb(177.3,179.4,183.6);--el-color-info-light-5:rgb(199.5,201,204);--el-color-info-light-7:rgb(221.7,222.6,224.4);--el-color-info-light-8:rgb(232.8,233.4,234.6);--el-color-info-light-9:rgb(243.9,244.2,244.8);--el-color-info-dark-2:rgb(115.2,117.6,122.4);--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0,0,0,.04),0px 8px 20px rgba(0,0,0,.08);--el-box-shadow-light:0px 0px 12px rgba(0,0,0,.12);--el-box-shadow-lighter:0px 0px 6px rgba(0,0,0,.12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0,0,0,.08),0px 12px 32px rgba(0,0,0,.12),0px 8px 16px -8px rgba(0,0,0,.16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0,0,0,.8);--el-overlay-color-light:rgba(0,0,0,.7);--el-overlay-color-lighter:rgba(0,0,0,.5);--el-mask-color:rgba(255,255,255,.9);--el-mask-color-extra-light:rgba(255,255,255,.3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transform-origin:center top;transition:var(--el-transition-md-fade)}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transform-origin:center bottom;transition:var(--el-transition-md-fade)}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transform-origin:top left;transition:var(--el-transition-md-fade)}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-icon-loading{animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.el-icon{--color:inherit;align-items:center;display:inline-flex;height:1em;justify-content:center;line-height:1em;position:relative;width:1em;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:.5}.v-modal-enter{animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{background:var(--el-popup-modal-bg-color);height:100%;left:0;opacity:var(--el-popup-modal-opacity);position:fixed;top:0;width:100%}.el-popup-parent--hidden{overflow:hidden}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:16px;--el-dialog-border-radius:var(--el-border-radius-base);background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;margin:var(--el-dialog-margin-top,15vh) auto 50px;overflow-wrap:break-word;padding:var(--el-dialog-padding-primary);position:relative;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:none!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;border-radius:0;height:100%;margin-bottom:0;overflow:auto}.el-dialog__wrapper{inset:0;margin:0;overflow:auto;position:fixed}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-dialog__header{padding-bottom:var(--el-dialog-padding-primary)}.el-dialog__header.show-close{padding-right:calc(var(--el-dialog-padding-primary) + var(--el-message-close-size, 16px))}.el-dialog__headerbtn{background:transparent;border:none;cursor:pointer;font-size:var(--el-message-close-size,16px);height:48px;outline:none;padding:0;position:absolute;right:0;top:0;width:48px}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{color:var(--el-text-color-primary);font-size:var(--el-dialog-title-font-size);line-height:var(--el-dialog-font-line-height)}.el-dialog__body{color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size)}.el-dialog__footer{box-sizing:border-box;padding-top:var(--el-dialog-padding-primary);text-align:right}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{inset:0;overflow:auto;position:fixed}.dialog-fade-enter-active{animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{animation:dialog-fade-out var(--el-transition-duration)}@keyframes dialog-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@keyframes dialog-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}@keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}.el-overlay{background-color:var(--el-overlay-color-lighter);height:100%;inset:0;overflow:auto;position:fixed;z-index:2000}.el-overlay .el-overlay-root{height:0}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255,255,255,.5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-text-color-secondary);--el-button-active-color:var(--el-text-color-primary);align-items:center;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);box-sizing:border-box;color:var(--el-button-text-color);cursor:pointer;display:inline-flex;font-weight:var(--el-button-font-weight);height:32px;justify-content:center;line-height:1;outline:none;text-align:center;transition:.1s;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;white-space:nowrap}.el-button:hover{background-color:var(--el-button-hover-bg-color);border-color:var(--el-button-hover-border-color);color:var(--el-button-hover-text-color);outline:none}.el-button:active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button>span{align-items:center;display:inline-flex}.el-button+.el-button{margin-left:12px}.el-button{border-radius:var(--el-border-radius-base);font-size:var(--el-font-size-base)}.el-button,.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button.is-disabled,.el-button.is-disabled:hover{background-color:var(--el-button-disabled-bg-color);background-image:none;border-color:var(--el-button-disabled-border-color);color:var(--el-button-disabled-text-color);cursor:not-allowed}.el-button.is-loading{pointer-events:none;position:relative}.el-button.is-loading:before{background-color:var(--el-mask-color-extra-light);border-radius:inherit;content:"";inset:-1px;pointer-events:none;position:absolute;z-index:1}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px;width:32px}.el-button.is-text{background-color:transparent;border:0 solid transparent;color:var(--el-button-text-color)}.el-button.is-text.is-disabled{background-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{background:transparent;border-color:transparent;color:var(--el-button-text-color);height:auto;padding:2px}.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-link:not(.is-disabled):active,.el-button.is-link:not(.is-disabled):hover{background-color:transparent;border-color:transparent}.el-button.is-link:not(.is-disabled):active{color:var(--el-button-active-color)}.el-button--text{background:transparent;border-color:transparent;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button--text:not(.is-disabled):hover{background-color:transparent;border-color:transparent;color:var(--el-color-primary-light-3)}.el-button--text:not(.is-disabled):active{background-color:transparent;border-color:transparent;color:var(--el-color-primary-dark-2)}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8);color:var(--el-color-primary-light-5)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8);color:var(--el-color-success-light-5)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8);color:var(--el-color-warning-light-5)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8);color:var(--el-color-danger-light-5)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8);color:var(--el-color-info-light-5)}.el-button--large{--el-button-size:40px;height:var(--el-button-size)}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large{border-radius:var(--el-border-radius-base);font-size:var(--el-font-size-base);padding:12px 19px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{padding:12px;width:var(--el-button-size)}.el-button--small{--el-button-size:24px;height:var(--el-button-size)}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small{border-radius:calc(var(--el-border-radius-base) - 1px);font-size:12px;padding:5px 11px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{padding:5px;width:var(--el-button-size)}.el-tabs{--el-tabs-header-height:40px;display:flex}.el-tabs__header{align-items:center;display:flex;justify-content:space-between;margin:0 0 15px;padding:0;position:relative}.el-tabs__header-vertical{flex-direction:column}.el-tabs__active-bar{background-color:var(--el-color-primary);bottom:0;height:2px;left:0;list-style:none;position:absolute;transition:width var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),transform var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);z-index:1}.el-tabs__new-tab{align-items:center;border:1px solid var(--el-border-color);border-radius:3px;color:var(--el-text-color-primary);cursor:pointer;display:flex;flex-shrink:0;font-size:12px;height:20px;justify-content:center;line-height:20px;margin:10px 0 10px 10px;text-align:center;transition:all .15s;width:20px}.el-tabs__new-tab .is-icon-plus{height:inherit;transform:scale(.8);width:inherit}.el-tabs__new-tab .is-icon-plus svg{vertical-align:middle}.el-tabs__new-tab:hover{color:var(--el-color-primary)}.el-tabs__new-tab-vertical{margin-left:0}.el-tabs__nav-wrap{flex:1 auto;margin-bottom:-1px;overflow:hidden;position:relative}.el-tabs__nav-wrap:after{background-color:var(--el-border-color-light);bottom:0;content:"";height:2px;left:0;position:absolute;width:100%;z-index:var(--el-index-normal)}.el-tabs__nav-wrap.is-scrollable{box-sizing:border-box;padding:0 20px}.el-tabs__nav-scroll{overflow:hidden}.el-tabs__nav-next,.el-tabs__nav-prev{color:var(--el-text-color-secondary);cursor:pointer;font-size:12px;line-height:44px;position:absolute;text-align:center;width:20px}.el-tabs__nav-next{right:0}.el-tabs__nav-prev{left:0}.el-tabs__nav{display:flex;float:left;height:var(--el-tabs-header-height);position:relative;transition:transform var(--el-transition-duration);white-space:nowrap;z-index:calc(var(--el-index-normal) + 1)}.el-tabs__nav.is-stretch{display:flex;min-width:100%}.el-tabs__nav.is-stretch>*{flex:1;text-align:center}.el-tabs__item{align-items:center;box-sizing:border-box;color:var(--el-text-color-primary);display:flex;font-size:var(--el-font-size-base);font-weight:500;height:var(--el-tabs-header-height);justify-content:center;list-style:none;padding:0 20px;position:relative}.el-tabs__item:focus,.el-tabs__item:focus:active{outline:none}.el-tabs__item:focus-visible{border-radius:3px;box-shadow:0 0 2px 2px var(--el-color-primary) inset}.el-tabs__item .is-icon-close{border-radius:50%;margin-left:5px;text-align:center;transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs__item .is-icon-close:before{display:inline-block;transform:scale(.9)}.el-tabs__item .is-icon-close:hover{background-color:var(--el-text-color-placeholder);color:#fff}.el-tabs__item.is-active,.el-tabs__item:hover{color:var(--el-color-primary)}.el-tabs__item:hover{cursor:pointer}.el-tabs__item.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-tabs__content{flex-grow:1;overflow:hidden;position:relative}.el-tabs--bottom>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top>.el-tabs__header .el-tabs__item:nth-child(2){padding-left:0}.el-tabs--bottom>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top>.el-tabs__header .el-tabs__item:last-child{padding-right:0}.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2){padding-left:20px}.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:last-child{padding-right:20px}.el-tabs--card>.el-tabs__header{border-bottom:1px solid var(--el-border-color-light);height:var(--el-tabs-header-height)}.el-tabs--card>.el-tabs__header .el-tabs__nav-wrap:after{content:none}.el-tabs--card>.el-tabs__header .el-tabs__nav{border:1px solid var(--el-border-color-light);border-bottom:none;border-radius:4px 4px 0 0;box-sizing:border-box}.el-tabs--card>.el-tabs__header .el-tabs__active-bar{display:none}.el-tabs--card>.el-tabs__header .el-tabs__item .is-icon-close{font-size:12px;height:14px;overflow:hidden;position:relative;right:-2px;transform-origin:100% 50%;width:0}.el-tabs--card>.el-tabs__header .el-tabs__item{border-bottom:1px solid transparent;border-left:1px solid var(--el-border-color-light);transition:color var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),padding var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs--card>.el-tabs__header .el-tabs__item:first-child{border-left:none}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover{padding-left:13px;padding-right:13px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover .is-icon-close{width:14px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active{border-bottom-color:var(--el-bg-color)}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable{padding-left:20px;padding-right:20px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable .is-icon-close{width:14px}.el-tabs--border-card{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color)}.el-tabs--border-card>.el-tabs__content{padding:15px}.el-tabs--border-card>.el-tabs__header{background-color:var(--el-fill-color-light);border-bottom:1px solid var(--el-border-color-light);margin:0}.el-tabs--border-card>.el-tabs__header .el-tabs__nav-wrap:after{content:none}.el-tabs--border-card>.el-tabs__header .el-tabs__item{border:1px solid transparent;color:var(--el-text-color-secondary);margin-top:-1px;transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs--border-card>.el-tabs__header .el-tabs__item+.el-tabs__item,.el-tabs--border-card>.el-tabs__header .el-tabs__item:first-child{margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-active{background-color:var(--el-bg-color-overlay);border-left-color:var(--el-border-color);border-right-color:var(--el-border-color);color:var(--el-color-primary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item:not(.is-disabled):hover{color:var(--el-color-primary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-disabled{color:var(--el-disabled-text-color)}.el-tabs--border-card>.el-tabs__header .is-scrollable .el-tabs__item:first-child{margin-left:0}.el-tabs--bottom{flex-direction:column}.el-tabs--bottom .el-tabs__header.is-bottom{margin-bottom:0;margin-top:10px}.el-tabs--bottom.el-tabs--border-card .el-tabs__header.is-bottom{border-bottom:0;border-top:1px solid var(--el-border-color)}.el-tabs--bottom.el-tabs--border-card .el-tabs__nav-wrap.is-bottom{margin-bottom:0;margin-top:-1px}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom:not(.is-active){border:1px solid transparent}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom{margin:0 -1px -1px}.el-tabs--left,.el-tabs--right{overflow:hidden}.el-tabs--left .el-tabs__header.is-left,.el-tabs--left .el-tabs__header.is-right,.el-tabs--left .el-tabs__nav-scroll,.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__header.is-left,.el-tabs--right .el-tabs__header.is-right,.el-tabs--right .el-tabs__nav-scroll,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{height:100%}.el-tabs--left .el-tabs__active-bar.is-left,.el-tabs--left .el-tabs__active-bar.is-right,.el-tabs--right .el-tabs__active-bar.is-left,.el-tabs--right .el-tabs__active-bar.is-right{bottom:auto;height:auto;top:0;width:2px}.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{margin-bottom:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{cursor:pointer;height:30px;line-height:30px;text-align:center;width:100%}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i{transform:rotate(90deg)}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{left:auto;top:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next{bottom:0;right:auto}.el-tabs--left .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--left .el-tabs__nav-wrap.is-right.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-right.is-scrollable{padding:30px 0}.el-tabs--left .el-tabs__nav-wrap.is-left:after,.el-tabs--left .el-tabs__nav-wrap.is-right:after,.el-tabs--right .el-tabs__nav-wrap.is-left:after,.el-tabs--right .el-tabs__nav-wrap.is-right:after{bottom:auto;height:100%;top:0;width:2px}.el-tabs--left .el-tabs__nav.is-left,.el-tabs--left .el-tabs__nav.is-right,.el-tabs--right .el-tabs__nav.is-left,.el-tabs--right .el-tabs__nav.is-right{flex-direction:column}.el-tabs--left .el-tabs__item.is-left,.el-tabs--right .el-tabs__item.is-left{justify-content:flex-end}.el-tabs--left .el-tabs__item.is-right,.el-tabs--right .el-tabs__item.is-right{justify-content:flex-start}.el-tabs--left{flex-direction:row}.el-tabs--left .el-tabs__header.is-left{margin-bottom:0;margin-right:10px}.el-tabs--left .el-tabs__nav-wrap.is-left{margin-right:-1px}.el-tabs--left .el-tabs__active-bar.is-left,.el-tabs--left .el-tabs__nav-wrap.is-left:after{left:auto;right:0}.el-tabs--left .el-tabs__item.is-left{text-align:right}.el-tabs--left.el-tabs--card .el-tabs__active-bar.is-left{display:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left{border-bottom:none;border-left:none;border-right:1px solid var(--el-border-color-light);border-top:1px solid var(--el-border-color-light);text-align:left}.el-tabs--left.el-tabs--card .el-tabs__item.is-left:first-child{border-right:1px solid var(--el-border-color-light);border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active{border:1px solid var(--el-border-color-light);border-bottom:none;border-left:none;border-right:1px solid #fff}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:first-child{border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:last-child{border-bottom:none}.el-tabs--left.el-tabs--card .el-tabs__nav{border-bottom:1px solid var(--el-border-color-light);border-radius:4px 0 0 4px;border-right:none}.el-tabs--left.el-tabs--card .el-tabs__new-tab{float:none}.el-tabs--left.el-tabs--border-card .el-tabs__header.is-left{border-right:1px solid var(--el-border-color)}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left{border:1px solid transparent;margin:-1px 0 -1px -1px}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left.is-active{border-color:rgb(209,219,229) transparent}.el-tabs--left>.el-tabs__content+.el-tabs__header{order:-1}.el-tabs--right .el-tabs__header.is-right{margin-bottom:0;margin-left:10px}.el-tabs--right .el-tabs__nav-wrap.is-right{margin-left:-1px}.el-tabs--right .el-tabs__nav-wrap.is-right:after{left:0;right:auto}.el-tabs--right .el-tabs__active-bar.is-right{left:0}.el-tabs--right.el-tabs--card .el-tabs__active-bar.is-right{display:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right{border-bottom:none;border-top:1px solid var(--el-border-color-light)}.el-tabs--right.el-tabs--card .el-tabs__item.is-right:first-child{border-left:1px solid var(--el-border-color-light);border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active{border:1px solid var(--el-border-color-light);border-bottom:none;border-left:1px solid #fff;border-right:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:first-child{border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:last-child{border-bottom:none}.el-tabs--right.el-tabs--card .el-tabs__nav{border-bottom:1px solid var(--el-border-color-light);border-left:none;border-radius:0 4px 4px 0}.el-tabs--right.el-tabs--border-card .el-tabs__header.is-right{border-left:1px solid var(--el-border-color)}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right{border:1px solid transparent;margin:-1px -1px -1px 0}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right.is-active{border-color:rgb(209,219,229) transparent}.el-tabs--top{flex-direction:column}.el-tabs--top>.el-tabs__content+.el-tabs__header{order:-1}.slideInLeft-transition,.slideInRight-transition{display:inline-block}.slideInRight-enter{animation:slideInRight-enter var(--el-transition-duration)}.slideInRight-leave{animation:slideInRight-leave var(--el-transition-duration);left:0;position:absolute;right:0}.slideInLeft-enter{animation:slideInLeft-enter var(--el-transition-duration)}.slideInLeft-leave{animation:slideInLeft-leave var(--el-transition-duration);left:0;position:absolute;right:0}@keyframes slideInRight-enter{0%{opacity:0;transform:translate(100%);transform-origin:0 0}to{opacity:1;transform:translate(0);transform-origin:0 0}}@keyframes slideInRight-leave{0%{opacity:1;transform:translate(0);transform-origin:0 0}to{opacity:0;transform:translate(100%);transform-origin:0 0}}@keyframes slideInLeft-enter{0%{opacity:0;transform:translate(-100%);transform-origin:0 0}to{opacity:1;transform:translate(0);transform-origin:0 0}}@keyframes slideInLeft-leave{0%{opacity:1;transform:translate(0);transform-origin:0 0}to{opacity:0;transform:translate(-100%);transform-origin:0 0}}.el-form{--el-form-label-font-size:var(--el-font-size-base);--el-form-inline-content-width:220px}.el-form--inline .el-form-item{display:inline-flex;margin-right:32px;vertical-align:middle}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item--label-left .el-form-item__label{justify-content:flex-start;text-align:left}.el-form-item--label-right .el-form-item__label{justify-content:flex-end;text-align:right}.el-form-item--label-top{display:block}.el-form-item--label-top .el-form-item__label{display:block;height:auto;line-height:22px;margin-bottom:8px;text-align:left}.el-form-item__label-wrap{display:flex}.el-form-item__label{align-items:flex-start;box-sizing:border-box;color:var(--el-text-color-regular);display:inline-flex;flex:0 0 auto;font-size:var(--el-form-label-font-size);height:32px;line-height:32px;padding:0 12px 0 0}.el-form-item__content{align-items:center;display:flex;flex:1;flex-wrap:wrap;font-size:var(--font-size);line-height:32px;min-width:0;position:relative}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;left:0;line-height:1;padding-top:2px;position:absolute;top:100%}.el-form-item__error--inline{display:inline-block;left:auto;margin-left:10px;position:relative;top:auto}.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label:before{color:var(--el-color-danger);content:"*";margin-right:4px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label-wrap>.el-form-item__label:after,.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label:after{color:var(--el-color-danger);content:"*";margin-left:4px}.el-form-item.is-error .el-form-item__content .el-input-tag__wrapper,.el-form-item.is-error .el-form-item__content .el-input-tag__wrapper.is-focus,.el-form-item.is-error .el-form-item__content .el-input-tag__wrapper:focus,.el-form-item.is-error .el-form-item__content .el-input-tag__wrapper:hover,.el-form-item.is-error .el-form-item__content .el-input__wrapper,.el-form-item.is-error .el-form-item__content .el-input__wrapper.is-focus,.el-form-item.is-error .el-form-item__content .el-input__wrapper:focus,.el-form-item.is-error .el-form-item__content .el-input__wrapper:hover,.el-form-item.is-error .el-form-item__content .el-select__wrapper,.el-form-item.is-error .el-form-item__content .el-select__wrapper.is-focus,.el-form-item.is-error .el-form-item__content .el-select__wrapper:focus,.el-form-item.is-error .el-form-item__content .el-select__wrapper:hover,.el-form-item.is-error .el-form-item__content .el-textarea__inner,.el-form-item.is-error .el-form-item__content .el-textarea__inner.is-focus,.el-form-item.is-error .el-form-item__content .el-textarea__inner:focus,.el-form-item.is-error .el-form-item__content .el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-form-item__content .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-form-item__content .el-input-group__prepend .el-input__wrapper{box-shadow:inset 0 0 0 1px transparent}.el-form-item.is-error .el-form-item__content .el-input-group__append .el-input__validateIcon,.el-form-item.is-error .el-form-item__content .el-input-group__prepend .el-input__validateIcon{display:none}.el-form-item.is-error .el-form-item__content .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}.el-switch{--el-switch-on-color:var(--el-color-primary);--el-switch-off-color:var(--el-border-color);align-items:center;display:inline-flex;font-size:14px;height:32px;line-height:20px;position:relative;vertical-align:middle}.el-switch.is-disabled .el-switch__core,.el-switch.is-disabled .el-switch__label{cursor:not-allowed}.el-switch__label{color:var(--el-text-color-primary);cursor:pointer;display:inline-block;font-size:14px;font-weight:500;height:20px;transition:var(--el-transition-duration-fast);vertical-align:middle}.el-switch__label.is-active{color:var(--el-color-primary)}.el-switch__label--left{margin-right:10px}.el-switch__label--right{margin-left:10px}.el-switch__label *{display:inline-block;font-size:14px;line-height:1}.el-switch__label .el-icon{height:inherit}.el-switch__label .el-icon svg{vertical-align:middle}.el-switch__input{height:0;margin:0;opacity:0;position:absolute;width:0}.el-switch__input:focus-visible~.el-switch__core{outline:2px solid var(--el-switch-on-color);outline-offset:1px}.el-switch__core{align-items:center;background:var(--el-switch-off-color);border:1px solid var(--el-switch-border-color,var(--el-switch-off-color));border-radius:10px;box-sizing:border-box;cursor:pointer;display:inline-flex;height:20px;min-width:40px;outline:none;position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration)}.el-switch__core .el-switch__inner{align-items:center;display:flex;height:16px;justify-content:center;overflow:hidden;padding:0 4px 0 18px;transition:all var(--el-transition-duration);width:100%}.el-switch__core .el-switch__inner .is-icon,.el-switch__core .el-switch__inner .is-text{color:var(--el-color-white);font-size:12px;overflow:hidden;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;user-select:none;white-space:nowrap}.el-switch__core .el-switch__action{align-items:center;background-color:var(--el-color-white);border-radius:var(--el-border-radius-circle);color:var(--el-switch-off-color);display:flex;height:16px;justify-content:center;left:1px;position:absolute;transition:all var(--el-transition-duration);width:16px}.el-switch.is-checked .el-switch__core{background-color:var(--el-switch-on-color);border-color:var(--el-switch-border-color,var(--el-switch-on-color))}.el-switch.is-checked .el-switch__core .el-switch__action{color:var(--el-switch-on-color);left:calc(100% - 17px)}.el-switch.is-checked .el-switch__core .el-switch__inner{padding:0 18px 0 4px}.el-switch.is-disabled{opacity:.6}.el-switch--wide .el-switch__label.el-switch__label--left span{left:10px}.el-switch--wide .el-switch__label.el-switch__label--right span{right:10px}.el-switch .label-fade-enter-from,.el-switch .label-fade-leave-active{opacity:0}.el-switch--large{font-size:14px;height:40px;line-height:24px}.el-switch--large .el-switch__label{font-size:14px;height:24px}.el-switch--large .el-switch__label *{font-size:14px}.el-switch--large .el-switch__core{border-radius:12px;height:24px;min-width:50px}.el-switch--large .el-switch__core .el-switch__inner{height:20px;padding:0 6px 0 22px}.el-switch--large .el-switch__core .el-switch__action{height:20px;width:20px}.el-switch--large.is-checked .el-switch__core .el-switch__action{left:calc(100% - 21px)}.el-switch--large.is-checked .el-switch__core .el-switch__inner{padding:0 22px 0 6px}.el-switch--small{font-size:12px;height:24px;line-height:16px}.el-switch--small .el-switch__label{font-size:12px;height:16px}.el-switch--small .el-switch__label *{font-size:12px}.el-switch--small .el-switch__core{border-radius:8px;height:16px;min-width:30px}.el-switch--small .el-switch__core .el-switch__inner{height:12px;padding:0 2px 0 14px}.el-switch--small .el-switch__core .el-switch__action{height:12px;width:12px}.el-switch--small.is-checked .el-switch__core .el-switch__action{left:calc(100% - 13px)}.el-switch--small.is-checked .el-switch__core .el-switch__inner{padding:0 14px 0 2px}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;display:inline-block;font-size:var(--el-font-size-base);position:relative;vertical-align:bottom;width:100%}.el-textarea__inner{-webkit-appearance:none;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));display:block;font-family:inherit;font-size:inherit;line-height:1.5;padding:5px 11px;position:relative;resize:vertical;transition:var(--el-transition-box-shadow);width:100%}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset;outline:none}.el-textarea .el-input__count{background:var(--el-fill-color-blank);bottom:5px;color:var(--el-color-info);font-size:12px;line-height:14px;position:absolute;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;--el-input-height:var(--el-component-size);box-sizing:border-box;display:inline-flex;font-size:var(--el-font-size-base);line-height:var(--el-input-height);position:relative;vertical-align:middle;width:var(--el-input-width)}.el-input::-webkit-scrollbar{width:6px;z-index:11}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{background:var(--el-text-color-disabled);border-radius:5px;width:6px}.el-input::-webkit-scrollbar-corner,.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);cursor:pointer;font-size:14px}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{align-items:center;color:var(--el-color-info);display:inline-flex;font-size:12px;height:100%}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);display:inline-block;line-height:normal;padding-left:8px}.el-input__wrapper{align-items:center;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;cursor:text;display:inline-flex;flex-grow:1;justify-content:center;padding:1px 11px;transform:translateZ(0);transition:var(--el-transition-box-shadow)}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px)}.el-input__inner{-webkit-appearance:none;background:none;border:none;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));flex-grow:1;font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);outline:none;padding:0;width:100%}.el-input__inner:focus{outline:none}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__inner[type=number]{line-height:1}.el-input__prefix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;line-height:var(--el-input-inner-height);pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__prefix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;line-height:var(--el-input-inner-height);pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__suffix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{align-items:center;display:flex;height:inherit;justify-content:center;line-height:inherit;margin-left:8px;transition:all var(--el-transition-duration)}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color, ) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;cursor:not-allowed}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{align-items:stretch;display:inline-flex;width:100%}.el-input-group__append,.el-input-group__prepend{align-items:center;background-color:var(--el-fill-color-light);border-radius:var(--el-input-border-radius);color:var(--el-color-info);display:inline-flex;justify-content:center;min-height:100%;padding:0 20px;position:relative;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:none}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-select__wrapper,.el-input-group__append div.el-select:hover .el-select__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-select__wrapper,.el-input-group__prepend div.el-select:hover .el-select__wrapper{background-color:transparent;border-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-bottom-right-radius:0;border-right:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper,.el-input-group__append{border-bottom-left-radius:0;border-top-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-select__wrapper{border-bottom-right-radius:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--append>.el-input__wrapper{border-bottom-right-radius:0;border-top-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-select__wrapper{border-bottom-left-radius:0;border-top-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-hidden{display:none!important}.el-input-number{display:inline-flex;line-height:30px;position:relative;vertical-align:middle;width:150px}.el-input-number .el-input__wrapper{padding-left:42px;padding-right:42px}.el-input-number .el-input__inner{-webkit-appearance:none;-moz-appearance:textfield;line-height:1;text-align:center}.el-input-number .el-input__inner::-webkit-inner-spin-button,.el-input-number .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-input-number__decrease,.el-input-number__increase{align-items:center;background:var(--el-fill-color-light);bottom:1px;color:var(--el-text-color-regular);cursor:pointer;display:flex;font-size:13px;height:auto;justify-content:center;position:absolute;top:1px;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:32px;z-index:1}.el-input-number__decrease:hover,.el-input-number__increase:hover{color:var(--el-color-primary)}.el-input-number__decrease:hover~.el-input:not(.is-disabled) .el-input__wrapper,.el-input-number__increase:hover~.el-input:not(.is-disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-input-number__decrease.is-disabled,.el-input-number__increase.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-input-number__increase{border-left:var(--el-border);border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0;right:1px}.el-input-number__decrease{border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);border-right:var(--el-border);left:1px}.el-input-number.is-disabled .el-input-number__decrease,.el-input-number.is-disabled .el-input-number__increase{border-color:var(--el-disabled-border-color);color:var(--el-disabled-border-color)}.el-input-number.is-disabled .el-input-number__decrease:hover,.el-input-number.is-disabled .el-input-number__increase:hover{color:var(--el-disabled-border-color);cursor:not-allowed}.el-input-number--large{line-height:38px;width:180px}.el-input-number--large .el-input-number__decrease,.el-input-number--large .el-input-number__increase{font-size:14px;width:40px}.el-input-number--large.is-controls-right .el-input--large .el-input__wrapper{padding-right:47px}.el-input-number--large .el-input--large .el-input__wrapper{padding-left:47px;padding-right:47px}.el-input-number--small{line-height:22px;width:120px}.el-input-number--small .el-input-number__decrease,.el-input-number--small .el-input-number__increase{font-size:12px;width:24px}.el-input-number--small.is-controls-right .el-input--small .el-input__wrapper{padding-right:31px}.el-input-number--small .el-input--small .el-input__wrapper{padding-left:31px;padding-right:31px}.el-input-number--small .el-input-number__decrease [class*=el-icon],.el-input-number--small .el-input-number__increase [class*=el-icon]{transform:scale(.9)}.el-input-number.is-without-controls .el-input__wrapper{padding-left:15px;padding-right:15px}.el-input-number.is-controls-right .el-input__wrapper{padding-left:15px;padding-right:42px}.el-input-number.is-controls-right .el-input-number__decrease,.el-input-number.is-controls-right .el-input-number__increase{--el-input-number-controls-height:15px;height:var(--el-input-number-controls-height);line-height:var(--el-input-number-controls-height)}.el-input-number.is-controls-right .el-input-number__decrease [class*=el-icon],.el-input-number.is-controls-right .el-input-number__increase [class*=el-icon]{transform:scale(.8)}.el-input-number.is-controls-right .el-input-number__increase{border-bottom:var(--el-border);border-radius:0 var(--el-border-radius-base) 0 0;bottom:auto;left:auto}.el-input-number.is-controls-right .el-input-number__decrease{border-left:var(--el-border);border-radius:0 0 var(--el-border-radius-base) 0;border-right:none;left:auto;right:1px;top:auto}.el-input-number.is-controls-right[class*=large] [class*=decrease],.el-input-number.is-controls-right[class*=large] [class*=increase]{--el-input-number-controls-height:19px}.el-input-number.is-controls-right[class*=small] [class*=decrease],.el-input-number.is-controls-right[class*=small] [class*=increase]{--el-input-number-controls-height:11px}.el-color-predefine{display:flex;font-size:12px;margin-top:8px;width:280px}.el-color-predefine__colors{display:flex;flex:1;flex-wrap:wrap}.el-color-predefine__color-selector{border-radius:4px;cursor:pointer;height:20px;margin:0 0 8px 8px;width:20px}.el-color-predefine__color-selector:nth-child(10n+1){margin-left:0}.el-color-predefine__color-selector.selected{box-shadow:0 0 3px 2px var(--el-color-primary)}.el-color-predefine__color-selector>div{border-radius:3px;display:flex;height:100%}.el-color-predefine__color-selector.is-alpha{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==)}.el-color-hue-slider{background-color:red;box-sizing:border-box;float:right;height:12px;padding:0 2px;position:relative;width:280px}.el-color-hue-slider__bar{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff,#00f 67%,#f0f 83%,red);height:100%;position:relative}.el-color-hue-slider__thumb{background:#fff;border:1px solid var(--el-border-color-lighter);border-radius:1px;box-shadow:0 0 2px #0009;box-sizing:border-box;cursor:pointer;height:100%;left:0;position:absolute;top:0;width:4px;z-index:1}.el-color-hue-slider__thumb:focus-visible{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-hue-slider.is-vertical{height:180px;padding:2px 0;width:12px}.el-color-hue-slider.is-vertical .el-color-hue-slider__bar{background:linear-gradient(180deg,red 0,#ff0 17%,#0f0 33%,#0ff,#00f 67%,#f0f 83%,red)}.el-color-hue-slider.is-vertical .el-color-hue-slider__thumb{height:4px;left:0;top:0;width:100%}.el-color-svpanel{height:180px;position:relative;width:280px}.el-color-svpanel__black,.el-color-svpanel__white{inset:0;position:absolute}.el-color-svpanel__white{background:linear-gradient(90deg,#fff,#fff0)}.el-color-svpanel__black{background:linear-gradient(0deg,#000,#0000)}.el-color-svpanel__cursor{position:absolute}.el-color-svpanel__cursor>div{border-radius:50%;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px #0000004d,0 0 1px 2px #0006;cursor:head;height:4px;transform:translate(-2px,-2px);width:4px}.el-color-alpha-slider{background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-position:0 0,6px 0,6px -6px,0 6px;background-size:12px 12px;box-sizing:border-box;height:12px;position:relative;width:280px}.el-color-alpha-slider__bar{background:linear-gradient(to right,rgba(255,255,255,0) 0,var(--el-bg-color) 100%);height:100%;position:relative}.el-color-alpha-slider__thumb{background:#fff;border:1px solid var(--el-border-color-lighter);border-radius:1px;box-shadow:0 0 2px #0009;box-sizing:border-box;cursor:pointer;height:100%;left:0;position:absolute;top:0;width:4px;z-index:1}.el-color-alpha-slider__thumb:focus-visible{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-alpha-slider.is-vertical{height:180px;width:20px}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__bar{background:linear-gradient(180deg,#fff0 0,#fff)}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__thumb{height:4px;left:0;top:0;width:100%}.el-color-dropdown{width:300px}.el-color-dropdown__main-wrapper{margin-bottom:6px}.el-color-dropdown__main-wrapper:after{clear:both;content:"";display:table}.el-color-dropdown__btns{margin-top:12px;text-align:right}.el-color-dropdown__value{color:#000;float:left;font-size:12px;line-height:26px;width:160px}.el-color-picker{display:inline-block;height:32px;line-height:normal;outline:none;position:relative;width:32px}.el-color-picker:hover:not(.is-disabled,.is-focused) .el-color-picker__trigger{border-color:var(--el-border-color-hover)}.el-color-picker:focus-visible:not(.is-disabled) .el-color-picker__trigger{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-picker.is-focused .el-color-picker__trigger{border-color:var(--el-color-primary)}.el-color-picker.is-disabled .el-color-picker__trigger{background-color:var(--el-fill-color-light);cursor:not-allowed}.el-color-picker.is-disabled .el-color-picker__color{opacity:.3}.el-color-picker--large{height:40px;width:40px}.el-color-picker--small{height:24px;width:24px}.el-color-picker--small .el-color-picker__empty,.el-color-picker--small .el-color-picker__icon{transform:scale(.8)}.el-color-picker__trigger{align-items:center;border:1px solid var(--el-border-color);border-radius:4px;cursor:pointer;display:inline-flex;font-size:0;justify-content:center;padding:4px}.el-color-picker__color,.el-color-picker__trigger{box-sizing:border-box;height:100%;position:relative;width:100%}.el-color-picker__color{border:1px solid var(--el-text-color-secondary);border-radius:var(--el-border-radius-small);display:block;text-align:center}.el-color-picker__color.is-alpha{background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-position:0 0,6px 0,6px -6px,0 6px;background-size:12px 12px}.el-color-picker__color-inner{align-items:center;display:inline-flex;height:100%;justify-content:center;width:100%}.el-color-picker .el-color-picker__empty{color:var(--el-text-color-secondary);font-size:12px}.el-color-picker .el-color-picker__icon{align-items:center;color:#fff;display:inline-flex;font-size:12px;justify-content:center}.el-color-picker__panel{background-color:#fff;border-radius:var(--el-border-radius-base);box-shadow:var(--el-box-shadow-light);box-sizing:content-box;padding:6px;position:absolute;z-index:10}.el-color-picker__panel.el-popper{border:1px solid var(--el-border-color-lighter)}.el-color-picker,.el-color-picker__panel{--el-color-picker-alpha-bg-a:#ccc;--el-color-picker-alpha-bg-b:transparent}.dark .el-color-picker,.dark .el-color-picker__panel{--el-color-picker-alpha-bg-a:#333333}.el-badge{--el-badge-bg-color:var(--el-color-danger);--el-badge-radius:10px;--el-badge-font-size:12px;--el-badge-padding:6px;--el-badge-size:18px;display:inline-block;position:relative;vertical-align:middle;width:-moz-fit-content;width:fit-content}.el-badge__content{align-items:center;background-color:var(--el-badge-bg-color);border:1px solid var(--el-bg-color);border-radius:var(--el-badge-radius);color:var(--el-color-white);display:inline-flex;font-size:var(--el-badge-font-size);height:var(--el-badge-size);justify-content:center;padding:0 var(--el-badge-padding);white-space:nowrap}.el-badge__content.is-fixed{position:absolute;right:calc(1px + var(--el-badge-size)/2);top:0;transform:translateY(-50%) translate(100%);z-index:var(--el-index-normal)}.el-badge__content.is-fixed.is-dot{right:5px}.el-badge__content.is-dot{border-radius:50%;height:8px;padding:0;right:0;width:8px}.el-badge__content.is-hide-zero{display:none}.el-badge__content--primary{background-color:var(--el-color-primary)}.el-badge__content--success{background-color:var(--el-color-success)}.el-badge__content--warning{background-color:var(--el-color-warning)}.el-badge__content--info{background-color:var(--el-color-info)}.el-badge__content--danger{background-color:var(--el-color-danger)}.el-message{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-border-color-lighter);--el-message-padding:11px 15px;--el-message-close-size:16px;--el-message-close-icon-color:var(--el-text-color-placeholder);--el-message-close-hover-color:var(--el-text-color-secondary);align-items:center;background-color:var(--el-message-bg-color);border-color:var(--el-message-border-color);border-radius:var(--el-border-radius-base);border-style:var(--el-border-style);border-width:var(--el-border-width);box-sizing:border-box;display:flex;gap:8px;left:50%;max-width:calc(100% - 32px);padding:var(--el-message-padding);position:fixed;top:20px;transform:translate(-50%);transition:opacity var(--el-transition-duration),transform .4s,top .4s;width:-moz-fit-content;width:fit-content}.el-message.is-plain{background-color:var(--el-bg-color-overlay);border-color:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-message p{margin:0}.el-message--primary{--el-message-bg-color:var(--el-color-primary-light-9);--el-message-border-color:var(--el-color-primary-light-8);--el-message-text-color:var(--el-color-primary)}.el-message--primary .el-message__content{color:var(--el-message-text-color);overflow-wrap:break-word}.el-message .el-message-icon--primary{color:var(--el-message-text-color)}.el-message--success{--el-message-bg-color:var(--el-color-success-light-9);--el-message-border-color:var(--el-color-success-light-8);--el-message-text-color:var(--el-color-success)}.el-message--success .el-message__content{color:var(--el-message-text-color);overflow-wrap:break-word}.el-message .el-message-icon--success{color:var(--el-message-text-color)}.el-message--info{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-color-info-light-8);--el-message-text-color:var(--el-color-info)}.el-message--info .el-message__content{color:var(--el-message-text-color);overflow-wrap:break-word}.el-message .el-message-icon--info{color:var(--el-message-text-color)}.el-message--warning{--el-message-bg-color:var(--el-color-warning-light-9);--el-message-border-color:var(--el-color-warning-light-8);--el-message-text-color:var(--el-color-warning)}.el-message--warning .el-message__content{color:var(--el-message-text-color);overflow-wrap:break-word}.el-message .el-message-icon--warning{color:var(--el-message-text-color)}.el-message--error{--el-message-bg-color:var(--el-color-error-light-9);--el-message-border-color:var(--el-color-error-light-8);--el-message-text-color:var(--el-color-error)}.el-message--error .el-message__content{color:var(--el-message-text-color);overflow-wrap:break-word}.el-message .el-message-icon--error{color:var(--el-message-text-color)}.el-message .el-message__badge{position:absolute;right:-8px;top:-8px}.el-message__content{font-size:14px;line-height:1;padding:0}.el-message__content:focus{outline-width:0}.el-message .el-message__closeBtn{color:var(--el-message-close-icon-color);cursor:pointer;font-size:var(--el-message-close-size)}.el-message .el-message__closeBtn:focus{outline-width:0}.el-message .el-message__closeBtn:hover{color:var(--el-message-close-hover-color)}.el-message-fade-enter-from,.el-message-fade-leave-to{opacity:0;transform:translate(-50%,-100%)}.el-alert{--el-alert-padding:8px 16px;--el-alert-border-radius-base:var(--el-border-radius-base);--el-alert-title-font-size:14px;--el-alert-title-with-description-font-size:16px;--el-alert-description-font-size:14px;--el-alert-close-font-size:16px;--el-alert-close-customed-font-size:14px;--el-alert-icon-size:16px;--el-alert-icon-large-size:28px;align-items:center;background-color:var(--el-color-white);border-radius:var(--el-alert-border-radius-base);box-sizing:border-box;display:flex;margin:0;opacity:1;overflow:hidden;padding:var(--el-alert-padding);position:relative;transition:opacity var(--el-transition-duration-fast);width:100%}.el-alert.is-light .el-alert__close-btn{color:var(--el-text-color-placeholder)}.el-alert.is-dark .el-alert__close-btn,.el-alert.is-dark .el-alert__description{color:var(--el-color-white)}.el-alert.is-center{justify-content:center}.el-alert--primary{--el-alert-bg-color:var(--el-color-primary-light-9)}.el-alert--primary.is-light{background-color:var(--el-alert-bg-color)}.el-alert--primary.is-light,.el-alert--primary.is-light .el-alert__description{color:var(--el-color-primary)}.el-alert--primary.is-dark{background-color:var(--el-color-primary);color:var(--el-color-white)}.el-alert--success{--el-alert-bg-color:var(--el-color-success-light-9)}.el-alert--success.is-light{background-color:var(--el-alert-bg-color)}.el-alert--success.is-light,.el-alert--success.is-light .el-alert__description{color:var(--el-color-success)}.el-alert--success.is-dark{background-color:var(--el-color-success);color:var(--el-color-white)}.el-alert--info{--el-alert-bg-color:var(--el-color-info-light-9)}.el-alert--info.is-light{background-color:var(--el-alert-bg-color)}.el-alert--info.is-light,.el-alert--info.is-light .el-alert__description{color:var(--el-color-info)}.el-alert--info.is-dark{background-color:var(--el-color-info);color:var(--el-color-white)}.el-alert--warning{--el-alert-bg-color:var(--el-color-warning-light-9)}.el-alert--warning.is-light{background-color:var(--el-alert-bg-color)}.el-alert--warning.is-light,.el-alert--warning.is-light .el-alert__description{color:var(--el-color-warning)}.el-alert--warning.is-dark{background-color:var(--el-color-warning);color:var(--el-color-white)}.el-alert--error{--el-alert-bg-color:var(--el-color-error-light-9)}.el-alert--error.is-light{background-color:var(--el-alert-bg-color)}.el-alert--error.is-light,.el-alert--error.is-light .el-alert__description{color:var(--el-color-error)}.el-alert--error.is-dark{background-color:var(--el-color-error);color:var(--el-color-white)}.el-alert__content{display:flex;flex-direction:column;gap:4px}.el-alert .el-alert__icon{font-size:var(--el-alert-icon-size);margin-right:8px;width:var(--el-alert-icon-size)}.el-alert .el-alert__icon.is-big{font-size:var(--el-alert-icon-large-size);margin-right:12px;width:var(--el-alert-icon-large-size)}.el-alert__title{font-size:var(--el-alert-title-font-size);line-height:24px}.el-alert__title.with-description{font-size:var(--el-alert-title-with-description-font-size)}.el-alert .el-alert__description{font-size:var(--el-alert-description-font-size);margin:0}.el-alert .el-alert__close-btn{cursor:pointer;font-size:var(--el-alert-close-font-size);opacity:1;position:absolute;right:16px;top:12px}.el-alert .el-alert__close-btn.is-customed{font-size:var(--el-alert-close-customed-font-size);font-style:normal;line-height:24px;top:8px}.el-alert-fade-enter-from,.el-alert-fade-leave-active{opacity:0}.el-card{--el-card-border-color:var(--el-border-color-light);--el-card-border-radius:4px;--el-card-padding:20px;--el-card-bg-color:var(--el-fill-color-blank);background-color:var(--el-card-bg-color);border:1px solid var(--el-card-border-color);border-radius:var(--el-card-border-radius);color:var(--el-text-color-primary);overflow:hidden;transition:var(--el-transition-duration)}.el-card.is-always-shadow,.el-card.is-hover-shadow:focus,.el-card.is-hover-shadow:hover{box-shadow:var(--el-box-shadow-light)}.el-card__header{border-bottom:1px solid var(--el-card-border-color);box-sizing:border-box;padding:calc(var(--el-card-padding) - 2px) var(--el-card-padding)}.el-card__body{padding:var(--el-card-padding)}.el-card__footer{border-top:1px solid var(--el-card-border-color);box-sizing:border-box;padding:calc(var(--el-card-padding) - 2px) var(--el-card-padding)} ');


System.register("./__entry.js", [], (function (exports, module) {
  'use strict';
  return {
    execute: (function () {

      var __getOwnPropNames = Object.getOwnPropertyNames;
      var __commonJS = (cb, mod) => function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var require_main_001 = __commonJS({
        "main-BJUgW66r.js"(exports, module$1) {
          const scriptRel = /* @__PURE__ */ function detectScriptRel() {
            const relList = typeof document !== "undefined" && document.createElement("link").relList;
            return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
          }();
          const assetsURL = function(dep) {
            return "/" + dep;
          };
          const seen = {};
          const __vitePreload = function preload(baseModule, deps, importerUrl) {
            let promise = Promise.resolve();
            if (deps && deps.length > 0) {
              let allSettled2 = function(promises$2) {
                return Promise.all(promises$2.map((p$1) => Promise.resolve(p$1).then((value$1) => ({
                  status: "fulfilled",
                  value: value$1
                }), (reason) => ({
                  status: "rejected",
                  reason
                }))));
              };
              document.getElementsByTagName("link");
              const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
              const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
              promise = allSettled2(deps.map((dep) => {
                dep = assetsURL(dep);
                if (dep in seen) return;
                seen[dep] = true;
                const isCss = dep.endsWith(".css");
                const cssSelector = isCss ? '[rel="stylesheet"]' : "";
                if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
                const link = document.createElement("link");
                link.rel = isCss ? "stylesheet" : scriptRel;
                if (!isCss) link.as = "script";
                link.crossOrigin = "";
                link.href = dep;
                if (cspNonce) link.setAttribute("nonce", cspNonce);
                document.head.appendChild(link);
                if (isCss) return new Promise((res, rej) => {
                  link.addEventListener("load", res);
                  link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
                });
              }));
            }
            function handlePreloadError(err$2) {
              const e$1 = new Event("vite:preloadError", { cancelable: true });
              e$1.payload = err$2;
              window.dispatchEvent(e$1);
              if (!e$1.defaultPrevented) throw err$2;
            }
            return promise.then((res) => {
              for (const item of res || []) {
                if (item.status !== "rejected") continue;
                handlePreloadError(item.reason);
              }
              return baseModule().catch(handlePreloadError);
            });
          };
          /**
          * @vue/shared v3.5.17
          * (c) 2018-present Yuxi (Evan) You and Vue contributors
          * @license MIT
          **/
          /*! #__NO_SIDE_EFFECTS__ */
          // @__NO_SIDE_EFFECTS__
          function makeMap(str) {
            const map = /* @__PURE__ */ Object.create(null);
            for (const key of str.split(",")) map[key] = 1;
            return (val) => val in map;
          }
          const EMPTY_OBJ = {};
          const EMPTY_ARR = [];
          const NOOP = () => {
          };
          const NO = () => false;
          const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
          (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
          const isModelListener = (key) => key.startsWith("onUpdate:");
          const extend = Object.assign;
          const remove = (arr, el) => {
            const i = arr.indexOf(el);
            if (i > -1) {
              arr.splice(i, 1);
            }
          };
          const hasOwnProperty$c = Object.prototype.hasOwnProperty;
          const hasOwn = (val, key) => hasOwnProperty$c.call(val, key);
          const isArray$1 = Array.isArray;
          const isMap$1 = (val) => toTypeString(val) === "[object Map]";
          const isSet$1 = (val) => toTypeString(val) === "[object Set]";
          const isFunction$1 = (val) => typeof val === "function";
          const isString$1 = (val) => typeof val === "string";
          const isSymbol$1 = (val) => typeof val === "symbol";
          const isObject$1 = (val) => val !== null && typeof val === "object";
          const isPromise = (val) => {
            return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
          };
          const objectToString$1 = Object.prototype.toString;
          const toTypeString = (value) => objectToString$1.call(value);
          const toRawType = (value) => {
            return toTypeString(value).slice(8, -1);
          };
          const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
          const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
          const isReservedProp = /* @__PURE__ */ makeMap(
            // the leading comma is intentional so empty string "" is also included
            ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
          );
          const cacheStringFunction = (fn2) => {
            const cache = /* @__PURE__ */ Object.create(null);
            return (str) => {
              const hit = cache[str];
              return hit || (cache[str] = fn2(str));
            };
          };
          const camelizeRE = /-(\w)/g;
          const camelize = cacheStringFunction(
            (str) => {
              return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
            }
          );
          const hyphenateRE = /\B([A-Z])/g;
          const hyphenate = cacheStringFunction(
            (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
          );
          const capitalize$1 = cacheStringFunction((str) => {
            return str.charAt(0).toUpperCase() + str.slice(1);
          });
          const toHandlerKey = cacheStringFunction(
            (str) => {
              const s = str ? `on${capitalize$1(str)}` : ``;
              return s;
            }
          );
          const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
          const invokeArrayFns = (fns, ...arg) => {
            for (let i = 0; i < fns.length; i++) {
              fns[i](...arg);
            }
          };
          const def = (obj, key, value, writable = false) => {
            Object.defineProperty(obj, key, {
              configurable: true,
              enumerable: false,
              writable,
              value
            });
          };
          const looseToNumber = (val) => {
            const n = parseFloat(val);
            return isNaN(n) ? val : n;
          };
          const toNumber$1 = (val) => {
            const n = isString$1(val) ? Number(val) : NaN;
            return isNaN(n) ? val : n;
          };
          let _globalThis;
          const getGlobalThis = () => {
            return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
          };
          function normalizeStyle(value) {
            if (isArray$1(value)) {
              const res = {};
              for (let i = 0; i < value.length; i++) {
                const item = value[i];
                const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
                if (normalized) {
                  for (const key in normalized) {
                    res[key] = normalized[key];
                  }
                }
              }
              return res;
            } else if (isString$1(value) || isObject$1(value)) {
              return value;
            }
          }
          const listDelimiterRE = /;(?![^(]*\))/g;
          const propertyDelimiterRE = /:([^]+)/;
          const styleCommentRE = /\/\*[^]*?\*\//g;
          function parseStringStyle(cssText) {
            const ret = {};
            cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
              if (item) {
                const tmp = item.split(propertyDelimiterRE);
                tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
              }
            });
            return ret;
          }
          function normalizeClass(value) {
            let res = "";
            if (isString$1(value)) {
              res = value;
            } else if (isArray$1(value)) {
              for (let i = 0; i < value.length; i++) {
                const normalized = normalizeClass(value[i]);
                if (normalized) {
                  res += normalized + " ";
                }
              }
            } else if (isObject$1(value)) {
              for (const name in value) {
                if (value[name]) {
                  res += name + " ";
                }
              }
            }
            return res.trim();
          }
          const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
          const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
          function includeBooleanAttr(value) {
            return !!value || value === "";
          }
          const isRef$1 = (val) => {
            return !!(val && val["__v_isRef"] === true);
          };
          const toDisplayString = (val) => {
            return isString$1(val) ? val : val == null ? "" : isArray$1(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
          };
          const replacer = (_key, val) => {
            if (isRef$1(val)) {
              return replacer(_key, val.value);
            } else if (isMap$1(val)) {
              return {
                [`Map(${val.size})`]: [...val.entries()].reduce(
                  (entries, [key, val2], i) => {
                    entries[stringifySymbol(key, i) + " =>"] = val2;
                    return entries;
                  },
                  {}
                )
              };
            } else if (isSet$1(val)) {
              return {
                [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
              };
            } else if (isSymbol$1(val)) {
              return stringifySymbol(val);
            } else if (isObject$1(val) && !isArray$1(val) && !isPlainObject$1(val)) {
              return String(val);
            }
            return val;
          };
          const stringifySymbol = (v, i = "") => {
            var _a2;
            return (
              // Symbol.description in es2019+ so we need to cast here to pass
              // the lib: es2016 check
              isSymbol$1(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i})` : v
            );
          };
          /**
          * @vue/reactivity v3.5.17
          * (c) 2018-present Yuxi (Evan) You and Vue contributors
          * @license MIT
          **/
          let activeEffectScope;
          class EffectScope {
            constructor(detached = false) {
              this.detached = detached;
              this._active = true;
              this._on = 0;
              this.effects = [];
              this.cleanups = [];
              this._isPaused = false;
              this.parent = activeEffectScope;
              if (!detached && activeEffectScope) {
                this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
                  this
                ) - 1;
              }
            }
            get active() {
              return this._active;
            }
            pause() {
              if (this._active) {
                this._isPaused = true;
                let i, l;
                if (this.scopes) {
                  for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].pause();
                  }
                }
                for (i = 0, l = this.effects.length; i < l; i++) {
                  this.effects[i].pause();
                }
              }
            }
            /**
             * Resumes the effect scope, including all child scopes and effects.
             */
            resume() {
              if (this._active) {
                if (this._isPaused) {
                  this._isPaused = false;
                  let i, l;
                  if (this.scopes) {
                    for (i = 0, l = this.scopes.length; i < l; i++) {
                      this.scopes[i].resume();
                    }
                  }
                  for (i = 0, l = this.effects.length; i < l; i++) {
                    this.effects[i].resume();
                  }
                }
              }
            }
            run(fn2) {
              if (this._active) {
                const currentEffectScope = activeEffectScope;
                try {
                  activeEffectScope = this;
                  return fn2();
                } finally {
                  activeEffectScope = currentEffectScope;
                }
              }
            }
            /**
             * This should only be called on non-detached scopes
             * @internal
             */
            on() {
              if (++this._on === 1) {
                this.prevScope = activeEffectScope;
                activeEffectScope = this;
              }
            }
            /**
             * This should only be called on non-detached scopes
             * @internal
             */
            off() {
              if (this._on > 0 && --this._on === 0) {
                activeEffectScope = this.prevScope;
                this.prevScope = void 0;
              }
            }
            stop(fromParent) {
              if (this._active) {
                this._active = false;
                let i, l;
                for (i = 0, l = this.effects.length; i < l; i++) {
                  this.effects[i].stop();
                }
                this.effects.length = 0;
                for (i = 0, l = this.cleanups.length; i < l; i++) {
                  this.cleanups[i]();
                }
                this.cleanups.length = 0;
                if (this.scopes) {
                  for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].stop(true);
                  }
                  this.scopes.length = 0;
                }
                if (!this.detached && this.parent && !fromParent) {
                  const last2 = this.parent.scopes.pop();
                  if (last2 && last2 !== this) {
                    this.parent.scopes[this.index] = last2;
                    last2.index = this.index;
                  }
                }
                this.parent = void 0;
              }
            }
          }
          function getCurrentScope() {
            return activeEffectScope;
          }
          function onScopeDispose(fn2, failSilently = false) {
            if (activeEffectScope) {
              activeEffectScope.cleanups.push(fn2);
            }
          }
          let activeSub;
          const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
          class ReactiveEffect {
            constructor(fn2) {
              this.fn = fn2;
              this.deps = void 0;
              this.depsTail = void 0;
              this.flags = 1 | 4;
              this.next = void 0;
              this.cleanup = void 0;
              this.scheduler = void 0;
              if (activeEffectScope && activeEffectScope.active) {
                activeEffectScope.effects.push(this);
              }
            }
            pause() {
              this.flags |= 64;
            }
            resume() {
              if (this.flags & 64) {
                this.flags &= -65;
                if (pausedQueueEffects.has(this)) {
                  pausedQueueEffects.delete(this);
                  this.trigger();
                }
              }
            }
            /**
             * @internal
             */
            notify() {
              if (this.flags & 2 && !(this.flags & 32)) {
                return;
              }
              if (!(this.flags & 8)) {
                batch(this);
              }
            }
            run() {
              if (!(this.flags & 1)) {
                return this.fn();
              }
              this.flags |= 2;
              cleanupEffect(this);
              prepareDeps(this);
              const prevEffect = activeSub;
              const prevShouldTrack = shouldTrack;
              activeSub = this;
              shouldTrack = true;
              try {
                return this.fn();
              } finally {
                cleanupDeps(this);
                activeSub = prevEffect;
                shouldTrack = prevShouldTrack;
                this.flags &= -3;
              }
            }
            stop() {
              if (this.flags & 1) {
                for (let link = this.deps; link; link = link.nextDep) {
                  removeSub(link);
                }
                this.deps = this.depsTail = void 0;
                cleanupEffect(this);
                this.onStop && this.onStop();
                this.flags &= -2;
              }
            }
            trigger() {
              if (this.flags & 64) {
                pausedQueueEffects.add(this);
              } else if (this.scheduler) {
                this.scheduler();
              } else {
                this.runIfDirty();
              }
            }
            /**
             * @internal
             */
            runIfDirty() {
              if (isDirty(this)) {
                this.run();
              }
            }
            get dirty() {
              return isDirty(this);
            }
          }
          let batchDepth = 0;
          let batchedSub;
          let batchedComputed;
          function batch(sub, isComputed = false) {
            sub.flags |= 8;
            if (isComputed) {
              sub.next = batchedComputed;
              batchedComputed = sub;
              return;
            }
            sub.next = batchedSub;
            batchedSub = sub;
          }
          function startBatch() {
            batchDepth++;
          }
          function endBatch() {
            if (--batchDepth > 0) {
              return;
            }
            if (batchedComputed) {
              let e = batchedComputed;
              batchedComputed = void 0;
              while (e) {
                const next = e.next;
                e.next = void 0;
                e.flags &= -9;
                e = next;
              }
            }
            let error;
            while (batchedSub) {
              let e = batchedSub;
              batchedSub = void 0;
              while (e) {
                const next = e.next;
                e.next = void 0;
                e.flags &= -9;
                if (e.flags & 1) {
                  try {
                    ;
                    e.trigger();
                  } catch (err) {
                    if (!error) error = err;
                  }
                }
                e = next;
              }
            }
            if (error) throw error;
          }
          function prepareDeps(sub) {
            for (let link = sub.deps; link; link = link.nextDep) {
              link.version = -1;
              link.prevActiveLink = link.dep.activeLink;
              link.dep.activeLink = link;
            }
          }
          function cleanupDeps(sub) {
            let head;
            let tail = sub.depsTail;
            let link = tail;
            while (link) {
              const prev = link.prevDep;
              if (link.version === -1) {
                if (link === tail) tail = prev;
                removeSub(link);
                removeDep(link);
              } else {
                head = link;
              }
              link.dep.activeLink = link.prevActiveLink;
              link.prevActiveLink = void 0;
              link = prev;
            }
            sub.deps = head;
            sub.depsTail = tail;
          }
          function isDirty(sub) {
            for (let link = sub.deps; link; link = link.nextDep) {
              if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
                return true;
              }
            }
            if (sub._dirty) {
              return true;
            }
            return false;
          }
          function refreshComputed(computed2) {
            if (computed2.flags & 4 && !(computed2.flags & 16)) {
              return;
            }
            computed2.flags &= -17;
            if (computed2.globalVersion === globalVersion) {
              return;
            }
            computed2.globalVersion = globalVersion;
            if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
              return;
            }
            computed2.flags |= 2;
            const dep = computed2.dep;
            const prevSub = activeSub;
            const prevShouldTrack = shouldTrack;
            activeSub = computed2;
            shouldTrack = true;
            try {
              prepareDeps(computed2);
              const value = computed2.fn(computed2._value);
              if (dep.version === 0 || hasChanged(value, computed2._value)) {
                computed2.flags |= 128;
                computed2._value = value;
                dep.version++;
              }
            } catch (err) {
              dep.version++;
              throw err;
            } finally {
              activeSub = prevSub;
              shouldTrack = prevShouldTrack;
              cleanupDeps(computed2);
              computed2.flags &= -3;
            }
          }
          function removeSub(link, soft = false) {
            const { dep, prevSub, nextSub } = link;
            if (prevSub) {
              prevSub.nextSub = nextSub;
              link.prevSub = void 0;
            }
            if (nextSub) {
              nextSub.prevSub = prevSub;
              link.nextSub = void 0;
            }
            if (dep.subs === link) {
              dep.subs = prevSub;
              if (!prevSub && dep.computed) {
                dep.computed.flags &= -5;
                for (let l = dep.computed.deps; l; l = l.nextDep) {
                  removeSub(l, true);
                }
              }
            }
            if (!soft && !--dep.sc && dep.map) {
              dep.map.delete(dep.key);
            }
          }
          function removeDep(link) {
            const { prevDep, nextDep } = link;
            if (prevDep) {
              prevDep.nextDep = nextDep;
              link.prevDep = void 0;
            }
            if (nextDep) {
              nextDep.prevDep = prevDep;
              link.nextDep = void 0;
            }
          }
          let shouldTrack = true;
          const trackStack = [];
          function pauseTracking() {
            trackStack.push(shouldTrack);
            shouldTrack = false;
          }
          function resetTracking() {
            const last2 = trackStack.pop();
            shouldTrack = last2 === void 0 ? true : last2;
          }
          function cleanupEffect(e) {
            const { cleanup } = e;
            e.cleanup = void 0;
            if (cleanup) {
              const prevSub = activeSub;
              activeSub = void 0;
              try {
                cleanup();
              } finally {
                activeSub = prevSub;
              }
            }
          }
          let globalVersion = 0;
          class Link {
            constructor(sub, dep) {
              this.sub = sub;
              this.dep = dep;
              this.version = dep.version;
              this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
            }
          }
          class Dep {
            // TODO isolatedDeclarations "__v_skip"
            constructor(computed2) {
              this.computed = computed2;
              this.version = 0;
              this.activeLink = void 0;
              this.subs = void 0;
              this.map = void 0;
              this.key = void 0;
              this.sc = 0;
              this.__v_skip = true;
            }
            track(debugInfo) {
              if (!activeSub || !shouldTrack || activeSub === this.computed) {
                return;
              }
              let link = this.activeLink;
              if (link === void 0 || link.sub !== activeSub) {
                link = this.activeLink = new Link(activeSub, this);
                if (!activeSub.deps) {
                  activeSub.deps = activeSub.depsTail = link;
                } else {
                  link.prevDep = activeSub.depsTail;
                  activeSub.depsTail.nextDep = link;
                  activeSub.depsTail = link;
                }
                addSub(link);
              } else if (link.version === -1) {
                link.version = this.version;
                if (link.nextDep) {
                  const next = link.nextDep;
                  next.prevDep = link.prevDep;
                  if (link.prevDep) {
                    link.prevDep.nextDep = next;
                  }
                  link.prevDep = activeSub.depsTail;
                  link.nextDep = void 0;
                  activeSub.depsTail.nextDep = link;
                  activeSub.depsTail = link;
                  if (activeSub.deps === link) {
                    activeSub.deps = next;
                  }
                }
              }
              return link;
            }
            trigger(debugInfo) {
              this.version++;
              globalVersion++;
              this.notify(debugInfo);
            }
            notify(debugInfo) {
              startBatch();
              try {
                if (false) ;
                for (let link = this.subs; link; link = link.prevSub) {
                  if (link.sub.notify()) {
                    ;
                    link.sub.dep.notify();
                  }
                }
              } finally {
                endBatch();
              }
            }
          }
          function addSub(link) {
            link.dep.sc++;
            if (link.sub.flags & 4) {
              const computed2 = link.dep.computed;
              if (computed2 && !link.dep.subs) {
                computed2.flags |= 4 | 16;
                for (let l = computed2.deps; l; l = l.nextDep) {
                  addSub(l);
                }
              }
              const currentTail = link.dep.subs;
              if (currentTail !== link) {
                link.prevSub = currentTail;
                if (currentTail) currentTail.nextSub = link;
              }
              link.dep.subs = link;
            }
          }
          const targetMap = /* @__PURE__ */ new WeakMap();
          const ITERATE_KEY = Symbol(
            ""
          );
          const MAP_KEY_ITERATE_KEY = Symbol(
            ""
          );
          const ARRAY_ITERATE_KEY = Symbol(
            ""
          );
          function track(target, type, key) {
            if (shouldTrack && activeSub) {
              let depsMap = targetMap.get(target);
              if (!depsMap) {
                targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
              }
              let dep = depsMap.get(key);
              if (!dep) {
                depsMap.set(key, dep = new Dep());
                dep.map = depsMap;
                dep.key = key;
              }
              {
                dep.track();
              }
            }
          }
          function trigger(target, type, key, newValue, oldValue, oldTarget) {
            const depsMap = targetMap.get(target);
            if (!depsMap) {
              globalVersion++;
              return;
            }
            const run = (dep) => {
              if (dep) {
                {
                  dep.trigger();
                }
              }
            };
            startBatch();
            if (type === "clear") {
              depsMap.forEach(run);
            } else {
              const targetIsArray = isArray$1(target);
              const isArrayIndex = targetIsArray && isIntegerKey(key);
              if (targetIsArray && key === "length") {
                const newLength = Number(newValue);
                depsMap.forEach((dep, key2) => {
                  if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol$1(key2) && key2 >= newLength) {
                    run(dep);
                  }
                });
              } else {
                if (key !== void 0 || depsMap.has(void 0)) {
                  run(depsMap.get(key));
                }
                if (isArrayIndex) {
                  run(depsMap.get(ARRAY_ITERATE_KEY));
                }
                switch (type) {
                  case "add":
                    if (!targetIsArray) {
                      run(depsMap.get(ITERATE_KEY));
                      if (isMap$1(target)) {
                        run(depsMap.get(MAP_KEY_ITERATE_KEY));
                      }
                    } else if (isArrayIndex) {
                      run(depsMap.get("length"));
                    }
                    break;
                  case "delete":
                    if (!targetIsArray) {
                      run(depsMap.get(ITERATE_KEY));
                      if (isMap$1(target)) {
                        run(depsMap.get(MAP_KEY_ITERATE_KEY));
                      }
                    }
                    break;
                  case "set":
                    if (isMap$1(target)) {
                      run(depsMap.get(ITERATE_KEY));
                    }
                    break;
                }
              }
            }
            endBatch();
          }
          function getDepFromReactive(object, key) {
            const depMap = targetMap.get(object);
            return depMap && depMap.get(key);
          }
          function reactiveReadArray(array) {
            const raw = toRaw(array);
            if (raw === array) return raw;
            track(raw, "iterate", ARRAY_ITERATE_KEY);
            return isShallow(array) ? raw : raw.map(toReactive);
          }
          function shallowReadArray(arr) {
            track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
            return arr;
          }
          const arrayInstrumentations = {
            __proto__: null,
            [Symbol.iterator]() {
              return iterator(this, Symbol.iterator, toReactive);
            },
            concat(...args) {
              return reactiveReadArray(this).concat(
                ...args.map((x) => isArray$1(x) ? reactiveReadArray(x) : x)
              );
            },
            entries() {
              return iterator(this, "entries", (value) => {
                value[1] = toReactive(value[1]);
                return value;
              });
            },
            every(fn2, thisArg) {
              return apply$1(this, "every", fn2, thisArg, void 0, arguments);
            },
            filter(fn2, thisArg) {
              return apply$1(this, "filter", fn2, thisArg, (v) => v.map(toReactive), arguments);
            },
            find(fn2, thisArg) {
              return apply$1(this, "find", fn2, thisArg, toReactive, arguments);
            },
            findIndex(fn2, thisArg) {
              return apply$1(this, "findIndex", fn2, thisArg, void 0, arguments);
            },
            findLast(fn2, thisArg) {
              return apply$1(this, "findLast", fn2, thisArg, toReactive, arguments);
            },
            findLastIndex(fn2, thisArg) {
              return apply$1(this, "findLastIndex", fn2, thisArg, void 0, arguments);
            },
            // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
            forEach(fn2, thisArg) {
              return apply$1(this, "forEach", fn2, thisArg, void 0, arguments);
            },
            includes(...args) {
              return searchProxy(this, "includes", args);
            },
            indexOf(...args) {
              return searchProxy(this, "indexOf", args);
            },
            join(separator) {
              return reactiveReadArray(this).join(separator);
            },
            // keys() iterator only reads `length`, no optimisation required
            lastIndexOf(...args) {
              return searchProxy(this, "lastIndexOf", args);
            },
            map(fn2, thisArg) {
              return apply$1(this, "map", fn2, thisArg, void 0, arguments);
            },
            pop() {
              return noTracking(this, "pop");
            },
            push(...args) {
              return noTracking(this, "push", args);
            },
            reduce(fn2, ...args) {
              return reduce(this, "reduce", fn2, args);
            },
            reduceRight(fn2, ...args) {
              return reduce(this, "reduceRight", fn2, args);
            },
            shift() {
              return noTracking(this, "shift");
            },
            // slice could use ARRAY_ITERATE but also seems to beg for range tracking
            some(fn2, thisArg) {
              return apply$1(this, "some", fn2, thisArg, void 0, arguments);
            },
            splice(...args) {
              return noTracking(this, "splice", args);
            },
            toReversed() {
              return reactiveReadArray(this).toReversed();
            },
            toSorted(comparer) {
              return reactiveReadArray(this).toSorted(comparer);
            },
            toSpliced(...args) {
              return reactiveReadArray(this).toSpliced(...args);
            },
            unshift(...args) {
              return noTracking(this, "unshift", args);
            },
            values() {
              return iterator(this, "values", toReactive);
            }
          };
          function iterator(self2, method, wrapValue) {
            const arr = shallowReadArray(self2);
            const iter = arr[method]();
            if (arr !== self2 && !isShallow(self2)) {
              iter._next = iter.next;
              iter.next = () => {
                const result = iter._next();
                if (result.value) {
                  result.value = wrapValue(result.value);
                }
                return result;
              };
            }
            return iter;
          }
          const arrayProto$1 = Array.prototype;
          function apply$1(self2, method, fn2, thisArg, wrappedRetFn, args) {
            const arr = shallowReadArray(self2);
            const needsWrap = arr !== self2 && !isShallow(self2);
            const methodFn = arr[method];
            if (methodFn !== arrayProto$1[method]) {
              const result2 = methodFn.apply(self2, args);
              return needsWrap ? toReactive(result2) : result2;
            }
            let wrappedFn = fn2;
            if (arr !== self2) {
              if (needsWrap) {
                wrappedFn = function(item, index) {
                  return fn2.call(this, toReactive(item), index, self2);
                };
              } else if (fn2.length > 2) {
                wrappedFn = function(item, index) {
                  return fn2.call(this, item, index, self2);
                };
              }
            }
            const result = methodFn.call(arr, wrappedFn, thisArg);
            return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
          }
          function reduce(self2, method, fn2, args) {
            const arr = shallowReadArray(self2);
            let wrappedFn = fn2;
            if (arr !== self2) {
              if (!isShallow(self2)) {
                wrappedFn = function(acc, item, index) {
                  return fn2.call(this, acc, toReactive(item), index, self2);
                };
              } else if (fn2.length > 3) {
                wrappedFn = function(acc, item, index) {
                  return fn2.call(this, acc, item, index, self2);
                };
              }
            }
            return arr[method](wrappedFn, ...args);
          }
          function searchProxy(self2, method, args) {
            const arr = toRaw(self2);
            track(arr, "iterate", ARRAY_ITERATE_KEY);
            const res = arr[method](...args);
            if ((res === -1 || res === false) && isProxy(args[0])) {
              args[0] = toRaw(args[0]);
              return arr[method](...args);
            }
            return res;
          }
          function noTracking(self2, method, args = []) {
            pauseTracking();
            startBatch();
            const res = toRaw(self2)[method].apply(self2, args);
            endBatch();
            resetTracking();
            return res;
          }
          const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
          const builtInSymbols = new Set(
            /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
          );
          function hasOwnProperty$b(key) {
            if (!isSymbol$1(key)) key = String(key);
            const obj = toRaw(this);
            track(obj, "has", key);
            return obj.hasOwnProperty(key);
          }
          class BaseReactiveHandler {
            constructor(_isReadonly = false, _isShallow = false) {
              this._isReadonly = _isReadonly;
              this._isShallow = _isShallow;
            }
            get(target, key, receiver) {
              if (key === "__v_skip") return target["__v_skip"];
              const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
              if (key === "__v_isReactive") {
                return !isReadonly2;
              } else if (key === "__v_isReadonly") {
                return isReadonly2;
              } else if (key === "__v_isShallow") {
                return isShallow2;
              } else if (key === "__v_raw") {
                if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
                // this means the receiver is a user proxy of the reactive proxy
                Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
                  return target;
                }
                return;
              }
              const targetIsArray = isArray$1(target);
              if (!isReadonly2) {
                let fn2;
                if (targetIsArray && (fn2 = arrayInstrumentations[key])) {
                  return fn2;
                }
                if (key === "hasOwnProperty") {
                  return hasOwnProperty$b;
                }
              }
              const res = Reflect.get(
                target,
                key,
                // if this is a proxy wrapping a ref, return methods using the raw ref
                // as receiver so that we don't have to call `toRaw` on the ref in all
                // its class methods
                isRef(target) ? target : receiver
              );
              if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
                return res;
              }
              if (!isReadonly2) {
                track(target, "get", key);
              }
              if (isShallow2) {
                return res;
              }
              if (isRef(res)) {
                return targetIsArray && isIntegerKey(key) ? res : res.value;
              }
              if (isObject$1(res)) {
                return isReadonly2 ? readonly(res) : reactive(res);
              }
              return res;
            }
          }
          class MutableReactiveHandler extends BaseReactiveHandler {
            constructor(isShallow2 = false) {
              super(false, isShallow2);
            }
            set(target, key, value, receiver) {
              let oldValue = target[key];
              if (!this._isShallow) {
                const isOldValueReadonly = isReadonly(oldValue);
                if (!isShallow(value) && !isReadonly(value)) {
                  oldValue = toRaw(oldValue);
                  value = toRaw(value);
                }
                if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
                  if (isOldValueReadonly) {
                    return false;
                  } else {
                    oldValue.value = value;
                    return true;
                  }
                }
              }
              const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
              const result = Reflect.set(
                target,
                key,
                value,
                isRef(target) ? target : receiver
              );
              if (target === toRaw(receiver)) {
                if (!hadKey) {
                  trigger(target, "add", key, value);
                } else if (hasChanged(value, oldValue)) {
                  trigger(target, "set", key, value);
                }
              }
              return result;
            }
            deleteProperty(target, key) {
              const hadKey = hasOwn(target, key);
              target[key];
              const result = Reflect.deleteProperty(target, key);
              if (result && hadKey) {
                trigger(target, "delete", key, void 0);
              }
              return result;
            }
            has(target, key) {
              const result = Reflect.has(target, key);
              if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
                track(target, "has", key);
              }
              return result;
            }
            ownKeys(target) {
              track(
                target,
                "iterate",
                isArray$1(target) ? "length" : ITERATE_KEY
              );
              return Reflect.ownKeys(target);
            }
          }
          class ReadonlyReactiveHandler extends BaseReactiveHandler {
            constructor(isShallow2 = false) {
              super(true, isShallow2);
            }
            set(target, key) {
              return true;
            }
            deleteProperty(target, key) {
              return true;
            }
          }
          const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
          const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
          const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
          const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
          const toShallow = (value) => value;
          const getProto = (v) => Reflect.getPrototypeOf(v);
          function createIterableMethod(method, isReadonly2, isShallow2) {
            return function(...args) {
              const target = this["__v_raw"];
              const rawTarget = toRaw(target);
              const targetIsMap = isMap$1(rawTarget);
              const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
              const isKeyOnly = method === "keys" && targetIsMap;
              const innerIterator = target[method](...args);
              const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
              !isReadonly2 && track(
                rawTarget,
                "iterate",
                isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
              );
              return {
                // iterator protocol
                next() {
                  const { value, done } = innerIterator.next();
                  return done ? { value, done } : {
                    value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                    done
                  };
                },
                // iterable protocol
                [Symbol.iterator]() {
                  return this;
                }
              };
            };
          }
          function createReadonlyMethod(type) {
            return function(...args) {
              return type === "delete" ? false : type === "clear" ? void 0 : this;
            };
          }
          function createInstrumentations(readonly2, shallow) {
            const instrumentations = {
              get(key) {
                const target = this["__v_raw"];
                const rawTarget = toRaw(target);
                const rawKey = toRaw(key);
                if (!readonly2) {
                  if (hasChanged(key, rawKey)) {
                    track(rawTarget, "get", key);
                  }
                  track(rawTarget, "get", rawKey);
                }
                const { has } = getProto(rawTarget);
                const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
                if (has.call(rawTarget, key)) {
                  return wrap(target.get(key));
                } else if (has.call(rawTarget, rawKey)) {
                  return wrap(target.get(rawKey));
                } else if (target !== rawTarget) {
                  target.get(key);
                }
              },
              get size() {
                const target = this["__v_raw"];
                !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
                return Reflect.get(target, "size", target);
              },
              has(key) {
                const target = this["__v_raw"];
                const rawTarget = toRaw(target);
                const rawKey = toRaw(key);
                if (!readonly2) {
                  if (hasChanged(key, rawKey)) {
                    track(rawTarget, "has", key);
                  }
                  track(rawTarget, "has", rawKey);
                }
                return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
              },
              forEach(callback, thisArg) {
                const observed = this;
                const target = observed["__v_raw"];
                const rawTarget = toRaw(target);
                const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
                !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
                return target.forEach((value, key) => {
                  return callback.call(thisArg, wrap(value), wrap(key), observed);
                });
              }
            };
            extend(
              instrumentations,
              readonly2 ? {
                add: createReadonlyMethod("add"),
                set: createReadonlyMethod("set"),
                delete: createReadonlyMethod("delete"),
                clear: createReadonlyMethod("clear")
              } : {
                add(value) {
                  if (!shallow && !isShallow(value) && !isReadonly(value)) {
                    value = toRaw(value);
                  }
                  const target = toRaw(this);
                  const proto = getProto(target);
                  const hadKey = proto.has.call(target, value);
                  if (!hadKey) {
                    target.add(value);
                    trigger(target, "add", value, value);
                  }
                  return this;
                },
                set(key, value) {
                  if (!shallow && !isShallow(value) && !isReadonly(value)) {
                    value = toRaw(value);
                  }
                  const target = toRaw(this);
                  const { has, get: get2 } = getProto(target);
                  let hadKey = has.call(target, key);
                  if (!hadKey) {
                    key = toRaw(key);
                    hadKey = has.call(target, key);
                  }
                  const oldValue = get2.call(target, key);
                  target.set(key, value);
                  if (!hadKey) {
                    trigger(target, "add", key, value);
                  } else if (hasChanged(value, oldValue)) {
                    trigger(target, "set", key, value);
                  }
                  return this;
                },
                delete(key) {
                  const target = toRaw(this);
                  const { has, get: get2 } = getProto(target);
                  let hadKey = has.call(target, key);
                  if (!hadKey) {
                    key = toRaw(key);
                    hadKey = has.call(target, key);
                  }
                  get2 ? get2.call(target, key) : void 0;
                  const result = target.delete(key);
                  if (hadKey) {
                    trigger(target, "delete", key, void 0);
                  }
                  return result;
                },
                clear() {
                  const target = toRaw(this);
                  const hadItems = target.size !== 0;
                  const result = target.clear();
                  if (hadItems) {
                    trigger(
                      target,
                      "clear",
                      void 0,
                      void 0
                    );
                  }
                  return result;
                }
              }
            );
            const iteratorMethods = [
              "keys",
              "values",
              "entries",
              Symbol.iterator
            ];
            iteratorMethods.forEach((method) => {
              instrumentations[method] = createIterableMethod(method, readonly2, shallow);
            });
            return instrumentations;
          }
          function createInstrumentationGetter(isReadonly2, shallow) {
            const instrumentations = createInstrumentations(isReadonly2, shallow);
            return (target, key, receiver) => {
              if (key === "__v_isReactive") {
                return !isReadonly2;
              } else if (key === "__v_isReadonly") {
                return isReadonly2;
              } else if (key === "__v_raw") {
                return target;
              }
              return Reflect.get(
                hasOwn(instrumentations, key) && key in target ? instrumentations : target,
                key,
                receiver
              );
            };
          }
          const mutableCollectionHandlers = {
            get: /* @__PURE__ */ createInstrumentationGetter(false, false)
          };
          const shallowCollectionHandlers = {
            get: /* @__PURE__ */ createInstrumentationGetter(false, true)
          };
          const readonlyCollectionHandlers = {
            get: /* @__PURE__ */ createInstrumentationGetter(true, false)
          };
          const shallowReadonlyCollectionHandlers = {
            get: /* @__PURE__ */ createInstrumentationGetter(true, true)
          };
          const reactiveMap = /* @__PURE__ */ new WeakMap();
          const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
          const readonlyMap = /* @__PURE__ */ new WeakMap();
          const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
          function targetTypeMap(rawType) {
            switch (rawType) {
              case "Object":
              case "Array":
                return 1;
              case "Map":
              case "Set":
              case "WeakMap":
              case "WeakSet":
                return 2;
              default:
                return 0;
            }
          }
          function getTargetType(value) {
            return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
          }
          function reactive(target) {
            if (isReadonly(target)) {
              return target;
            }
            return createReactiveObject(
              target,
              false,
              mutableHandlers,
              mutableCollectionHandlers,
              reactiveMap
            );
          }
          function shallowReactive(target) {
            return createReactiveObject(
              target,
              false,
              shallowReactiveHandlers,
              shallowCollectionHandlers,
              shallowReactiveMap
            );
          }
          function readonly(target) {
            return createReactiveObject(
              target,
              true,
              readonlyHandlers,
              readonlyCollectionHandlers,
              readonlyMap
            );
          }
          function shallowReadonly(target) {
            return createReactiveObject(
              target,
              true,
              shallowReadonlyHandlers,
              shallowReadonlyCollectionHandlers,
              shallowReadonlyMap
            );
          }
          function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
            if (!isObject$1(target)) {
              return target;
            }
            if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
              return target;
            }
            const targetType = getTargetType(target);
            if (targetType === 0) {
              return target;
            }
            const existingProxy = proxyMap.get(target);
            if (existingProxy) {
              return existingProxy;
            }
            const proxy = new Proxy(
              target,
              targetType === 2 ? collectionHandlers : baseHandlers
            );
            proxyMap.set(target, proxy);
            return proxy;
          }
          function isReactive(value) {
            if (isReadonly(value)) {
              return isReactive(value["__v_raw"]);
            }
            return !!(value && value["__v_isReactive"]);
          }
          function isReadonly(value) {
            return !!(value && value["__v_isReadonly"]);
          }
          function isShallow(value) {
            return !!(value && value["__v_isShallow"]);
          }
          function isProxy(value) {
            return value ? !!value["__v_raw"] : false;
          }
          function toRaw(observed) {
            const raw = observed && observed["__v_raw"];
            return raw ? toRaw(raw) : observed;
          }
          function markRaw(value) {
            if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
              def(value, "__v_skip", true);
            }
            return value;
          }
          const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
          const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
          function isRef(r) {
            return r ? r["__v_isRef"] === true : false;
          }
          function ref(value) {
            return createRef(value, false);
          }
          function shallowRef(value) {
            return createRef(value, true);
          }
          function createRef(rawValue, shallow) {
            if (isRef(rawValue)) {
              return rawValue;
            }
            return new RefImpl(rawValue, shallow);
          }
          class RefImpl {
            constructor(value, isShallow2) {
              this.dep = new Dep();
              this["__v_isRef"] = true;
              this["__v_isShallow"] = false;
              this._rawValue = isShallow2 ? value : toRaw(value);
              this._value = isShallow2 ? value : toReactive(value);
              this["__v_isShallow"] = isShallow2;
            }
            get value() {
              {
                this.dep.track();
              }
              return this._value;
            }
            set value(newValue) {
              const oldValue = this._rawValue;
              const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
              newValue = useDirectValue ? newValue : toRaw(newValue);
              if (hasChanged(newValue, oldValue)) {
                this._rawValue = newValue;
                this._value = useDirectValue ? newValue : toReactive(newValue);
                {
                  this.dep.trigger();
                }
              }
            }
          }
          function triggerRef(ref2) {
            if (ref2.dep) {
              {
                ref2.dep.trigger();
              }
            }
          }
          function unref(ref2) {
            return isRef(ref2) ? ref2.value : ref2;
          }
          const shallowUnwrapHandlers = {
            get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
            set: (target, key, value, receiver) => {
              const oldValue = target[key];
              if (isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
              } else {
                return Reflect.set(target, key, value, receiver);
              }
            }
          };
          function proxyRefs(objectWithRefs) {
            return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
          }
          function toRefs(object) {
            const ret = isArray$1(object) ? new Array(object.length) : {};
            for (const key in object) {
              ret[key] = propertyToRef(object, key);
            }
            return ret;
          }
          class ObjectRefImpl {
            constructor(_object, _key, _defaultValue) {
              this._object = _object;
              this._key = _key;
              this._defaultValue = _defaultValue;
              this["__v_isRef"] = true;
              this._value = void 0;
            }
            get value() {
              const val = this._object[this._key];
              return this._value = val === void 0 ? this._defaultValue : val;
            }
            set value(newVal) {
              this._object[this._key] = newVal;
            }
            get dep() {
              return getDepFromReactive(toRaw(this._object), this._key);
            }
          }
          class GetterRefImpl {
            constructor(_getter) {
              this._getter = _getter;
              this["__v_isRef"] = true;
              this["__v_isReadonly"] = true;
              this._value = void 0;
            }
            get value() {
              return this._value = this._getter();
            }
          }
          function toRef(source, key, defaultValue) {
            if (isRef(source)) {
              return source;
            } else if (isFunction$1(source)) {
              return new GetterRefImpl(source);
            } else if (isObject$1(source) && arguments.length > 1) {
              return propertyToRef(source, key, defaultValue);
            } else {
              return ref(source);
            }
          }
          function propertyToRef(source, key, defaultValue) {
            const val = source[key];
            return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
          }
          class ComputedRefImpl {
            constructor(fn2, setter, isSSR) {
              this.fn = fn2;
              this.setter = setter;
              this._value = void 0;
              this.dep = new Dep(this);
              this.__v_isRef = true;
              this.deps = void 0;
              this.depsTail = void 0;
              this.flags = 16;
              this.globalVersion = globalVersion - 1;
              this.next = void 0;
              this.effect = this;
              this["__v_isReadonly"] = !setter;
              this.isSSR = isSSR;
            }
            /**
             * @internal
             */
            notify() {
              this.flags |= 16;
              if (!(this.flags & 8) && // avoid infinite self recursion
              activeSub !== this) {
                batch(this, true);
                return true;
              }
            }
            get value() {
              const link = this.dep.track();
              refreshComputed(this);
              if (link) {
                link.version = this.dep.version;
              }
              return this._value;
            }
            set value(newValue) {
              if (this.setter) {
                this.setter(newValue);
              }
            }
          }
          function computed$1(getterOrOptions, debugOptions, isSSR = false) {
            let getter;
            let setter;
            if (isFunction$1(getterOrOptions)) {
              getter = getterOrOptions;
            } else {
              getter = getterOrOptions.get;
              setter = getterOrOptions.set;
            }
            const cRef = new ComputedRefImpl(getter, setter, isSSR);
            return cRef;
          }
          const INITIAL_WATCHER_VALUE = {};
          const cleanupMap = /* @__PURE__ */ new WeakMap();
          let activeWatcher = void 0;
          function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
            if (owner) {
              let cleanups = cleanupMap.get(owner);
              if (!cleanups) cleanupMap.set(owner, cleanups = []);
              cleanups.push(cleanupFn);
            }
          }
          function watch$1(source, cb, options = EMPTY_OBJ) {
            const { immediate, deep, once, scheduler, augmentJob, call } = options;
            const reactiveGetter = (source2) => {
              if (deep) return source2;
              if (isShallow(source2) || deep === false || deep === 0)
                return traverse(source2, 1);
              return traverse(source2);
            };
            let effect2;
            let getter;
            let cleanup;
            let boundCleanup;
            let forceTrigger = false;
            let isMultiSource = false;
            if (isRef(source)) {
              getter = () => source.value;
              forceTrigger = isShallow(source);
            } else if (isReactive(source)) {
              getter = () => reactiveGetter(source);
              forceTrigger = true;
            } else if (isArray$1(source)) {
              isMultiSource = true;
              forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
              getter = () => source.map((s) => {
                if (isRef(s)) {
                  return s.value;
                } else if (isReactive(s)) {
                  return reactiveGetter(s);
                } else if (isFunction$1(s)) {
                  return call ? call(s, 2) : s();
                } else ;
              });
            } else if (isFunction$1(source)) {
              if (cb) {
                getter = call ? () => call(source, 2) : source;
              } else {
                getter = () => {
                  if (cleanup) {
                    pauseTracking();
                    try {
                      cleanup();
                    } finally {
                      resetTracking();
                    }
                  }
                  const currentEffect = activeWatcher;
                  activeWatcher = effect2;
                  try {
                    return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
                  } finally {
                    activeWatcher = currentEffect;
                  }
                };
              }
            } else {
              getter = NOOP;
            }
            if (cb && deep) {
              const baseGetter = getter;
              const depth = deep === true ? Infinity : deep;
              getter = () => traverse(baseGetter(), depth);
            }
            const scope = getCurrentScope();
            const watchHandle = () => {
              effect2.stop();
              if (scope && scope.active) {
                remove(scope.effects, effect2);
              }
            };
            if (once && cb) {
              const _cb = cb;
              cb = (...args) => {
                _cb(...args);
                watchHandle();
              };
            }
            let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
            const job = (immediateFirstRun) => {
              if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
                return;
              }
              if (cb) {
                const newValue = effect2.run();
                if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
                  if (cleanup) {
                    cleanup();
                  }
                  const currentWatcher = activeWatcher;
                  activeWatcher = effect2;
                  try {
                    const args = [
                      newValue,
                      // pass undefined as the old value when it's changed for the first time
                      oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                      boundCleanup
                    ];
                    oldValue = newValue;
                    call ? call(cb, 3, args) : (
                      // @ts-expect-error
                      cb(...args)
                    );
                  } finally {
                    activeWatcher = currentWatcher;
                  }
                }
              } else {
                effect2.run();
              }
            };
            if (augmentJob) {
              augmentJob(job);
            }
            effect2 = new ReactiveEffect(getter);
            effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
            boundCleanup = (fn2) => onWatcherCleanup(fn2, false, effect2);
            cleanup = effect2.onStop = () => {
              const cleanups = cleanupMap.get(effect2);
              if (cleanups) {
                if (call) {
                  call(cleanups, 4);
                } else {
                  for (const cleanup2 of cleanups) cleanup2();
                }
                cleanupMap.delete(effect2);
              }
            };
            if (cb) {
              if (immediate) {
                job(true);
              } else {
                oldValue = effect2.run();
              }
            } else if (scheduler) {
              scheduler(job.bind(null, true), true);
            } else {
              effect2.run();
            }
            watchHandle.pause = effect2.pause.bind(effect2);
            watchHandle.resume = effect2.resume.bind(effect2);
            watchHandle.stop = watchHandle;
            return watchHandle;
          }
          function traverse(value, depth = Infinity, seen2) {
            if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
              return value;
            }
            seen2 = seen2 || /* @__PURE__ */ new Set();
            if (seen2.has(value)) {
              return value;
            }
            seen2.add(value);
            depth--;
            if (isRef(value)) {
              traverse(value.value, depth, seen2);
            } else if (isArray$1(value)) {
              for (let i = 0; i < value.length; i++) {
                traverse(value[i], depth, seen2);
              }
            } else if (isSet$1(value) || isMap$1(value)) {
              value.forEach((v) => {
                traverse(v, depth, seen2);
              });
            } else if (isPlainObject$1(value)) {
              for (const key in value) {
                traverse(value[key], depth, seen2);
              }
              for (const key of Object.getOwnPropertySymbols(value)) {
                if (Object.prototype.propertyIsEnumerable.call(value, key)) {
                  traverse(value[key], depth, seen2);
                }
              }
            }
            return value;
          }
          /**
          * @vue/runtime-core v3.5.17
          * (c) 2018-present Yuxi (Evan) You and Vue contributors
          * @license MIT
          **/
          const stack = [];
          let isWarning = false;
          function warn$1(msg, ...args) {
            if (isWarning) return;
            isWarning = true;
            pauseTracking();
            const instance = stack.length ? stack[stack.length - 1].component : null;
            const appWarnHandler = instance && instance.appContext.config.warnHandler;
            const trace = getComponentTrace();
            if (appWarnHandler) {
              callWithErrorHandling(
                appWarnHandler,
                instance,
                11,
                [
                  // eslint-disable-next-line no-restricted-syntax
                  msg + args.map((a) => {
                    var _a2, _b;
                    return (_b = (_a2 = a.toString) == null ? void 0 : _a2.call(a)) != null ? _b : JSON.stringify(a);
                  }).join(""),
                  instance && instance.proxy,
                  trace.map(
                    ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
                  ).join("\n"),
                  trace
                ]
              );
            } else {
              const warnArgs = [`[Vue warn]: ${msg}`, ...args];
              if (trace.length && // avoid spamming console during tests
              true) {
                warnArgs.push(`
`, ...formatTrace(trace));
              }
              console.warn(...warnArgs);
            }
            resetTracking();
            isWarning = false;
          }
          function getComponentTrace() {
            let currentVNode = stack[stack.length - 1];
            if (!currentVNode) {
              return [];
            }
            const normalizedStack = [];
            while (currentVNode) {
              const last2 = normalizedStack[0];
              if (last2 && last2.vnode === currentVNode) {
                last2.recurseCount++;
              } else {
                normalizedStack.push({
                  vnode: currentVNode,
                  recurseCount: 0
                });
              }
              const parentInstance = currentVNode.component && currentVNode.component.parent;
              currentVNode = parentInstance && parentInstance.vnode;
            }
            return normalizedStack;
          }
          function formatTrace(trace) {
            const logs = [];
            trace.forEach((entry, i) => {
              logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
            });
            return logs;
          }
          function formatTraceEntry({ vnode, recurseCount }) {
            const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
            const isRoot = vnode.component ? vnode.component.parent == null : false;
            const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
            const close = `>` + postfix;
            return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
          }
          function formatProps(props) {
            const res = [];
            const keys2 = Object.keys(props);
            keys2.slice(0, 3).forEach((key) => {
              res.push(...formatProp(key, props[key]));
            });
            if (keys2.length > 3) {
              res.push(` ...`);
            }
            return res;
          }
          function formatProp(key, value, raw) {
            if (isString$1(value)) {
              value = JSON.stringify(value);
              return raw ? value : [`${key}=${value}`];
            } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
              return raw ? value : [`${key}=${value}`];
            } else if (isRef(value)) {
              value = formatProp(key, toRaw(value.value), true);
              return raw ? value : [`${key}=Ref<`, value, `>`];
            } else if (isFunction$1(value)) {
              return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
            } else {
              value = toRaw(value);
              return raw ? value : [`${key}=`, value];
            }
          }
          function callWithErrorHandling(fn2, instance, type, args) {
            try {
              return args ? fn2(...args) : fn2();
            } catch (err) {
              handleError(err, instance, type);
            }
          }
          function callWithAsyncErrorHandling(fn2, instance, type, args) {
            if (isFunction$1(fn2)) {
              const res = callWithErrorHandling(fn2, instance, type, args);
              if (res && isPromise(res)) {
                res.catch((err) => {
                  handleError(err, instance, type);
                });
              }
              return res;
            }
            if (isArray$1(fn2)) {
              const values = [];
              for (let i = 0; i < fn2.length; i++) {
                values.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
              }
              return values;
            }
          }
          function handleError(err, instance, type, throwInDev = true) {
            const contextVNode = instance ? instance.vnode : null;
            const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
            if (instance) {
              let cur = instance.parent;
              const exposedInstance = instance.proxy;
              const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
              while (cur) {
                const errorCapturedHooks = cur.ec;
                if (errorCapturedHooks) {
                  for (let i = 0; i < errorCapturedHooks.length; i++) {
                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                      return;
                    }
                  }
                }
                cur = cur.parent;
              }
              if (errorHandler) {
                pauseTracking();
                callWithErrorHandling(errorHandler, null, 10, [
                  err,
                  exposedInstance,
                  errorInfo
                ]);
                resetTracking();
                return;
              }
            }
            logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
          }
          function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
            if (throwInProd) {
              throw err;
            } else {
              console.error(err);
            }
          }
          const queue = [];
          let flushIndex = -1;
          const pendingPostFlushCbs = [];
          let activePostFlushCbs = null;
          let postFlushIndex = 0;
          const resolvedPromise = /* @__PURE__ */ Promise.resolve();
          let currentFlushPromise = null;
          function nextTick(fn2) {
            const p2 = currentFlushPromise || resolvedPromise;
            return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
          }
          function findInsertionIndex(id) {
            let start = flushIndex + 1;
            let end = queue.length;
            while (start < end) {
              const middle = start + end >>> 1;
              const middleJob = queue[middle];
              const middleJobId = getId(middleJob);
              if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
                start = middle + 1;
              } else {
                end = middle;
              }
            }
            return start;
          }
          function queueJob(job) {
            if (!(job.flags & 1)) {
              const jobId = getId(job);
              const lastJob = queue[queue.length - 1];
              if (!lastJob || // fast path when the job id is larger than the tail
              !(job.flags & 2) && jobId >= getId(lastJob)) {
                queue.push(job);
              } else {
                queue.splice(findInsertionIndex(jobId), 0, job);
              }
              job.flags |= 1;
              queueFlush();
            }
          }
          function queueFlush() {
            if (!currentFlushPromise) {
              currentFlushPromise = resolvedPromise.then(flushJobs);
            }
          }
          function queuePostFlushCb(cb) {
            if (!isArray$1(cb)) {
              if (activePostFlushCbs && cb.id === -1) {
                activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
              } else if (!(cb.flags & 1)) {
                pendingPostFlushCbs.push(cb);
                cb.flags |= 1;
              }
            } else {
              pendingPostFlushCbs.push(...cb);
            }
            queueFlush();
          }
          function flushPreFlushCbs(instance, seen2, i = flushIndex + 1) {
            for (; i < queue.length; i++) {
              const cb = queue[i];
              if (cb && cb.flags & 2) {
                if (instance && cb.id !== instance.uid) {
                  continue;
                }
                queue.splice(i, 1);
                i--;
                if (cb.flags & 4) {
                  cb.flags &= -2;
                }
                cb();
                if (!(cb.flags & 4)) {
                  cb.flags &= -2;
                }
              }
            }
          }
          function flushPostFlushCbs(seen2) {
            if (pendingPostFlushCbs.length) {
              const deduped = [...new Set(pendingPostFlushCbs)].sort(
                (a, b) => getId(a) - getId(b)
              );
              pendingPostFlushCbs.length = 0;
              if (activePostFlushCbs) {
                activePostFlushCbs.push(...deduped);
                return;
              }
              activePostFlushCbs = deduped;
              for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
                const cb = activePostFlushCbs[postFlushIndex];
                if (cb.flags & 4) {
                  cb.flags &= -2;
                }
                if (!(cb.flags & 8)) cb();
                cb.flags &= -2;
              }
              activePostFlushCbs = null;
              postFlushIndex = 0;
            }
          }
          const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
          function flushJobs(seen2) {
            try {
              for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
                const job = queue[flushIndex];
                if (job && !(job.flags & 8)) {
                  if (false) ;
                  if (job.flags & 4) {
                    job.flags &= ~1;
                  }
                  callWithErrorHandling(
                    job,
                    job.i,
                    job.i ? 15 : 14
                  );
                  if (!(job.flags & 4)) {
                    job.flags &= ~1;
                  }
                }
              }
            } finally {
              for (; flushIndex < queue.length; flushIndex++) {
                const job = queue[flushIndex];
                if (job) {
                  job.flags &= -2;
                }
              }
              flushIndex = -1;
              queue.length = 0;
              flushPostFlushCbs();
              currentFlushPromise = null;
              if (queue.length || pendingPostFlushCbs.length) {
                flushJobs();
              }
            }
          }
          let currentRenderingInstance = null;
          let currentScopeId = null;
          function setCurrentRenderingInstance(instance) {
            const prev = currentRenderingInstance;
            currentRenderingInstance = instance;
            currentScopeId = instance && instance.type.__scopeId || null;
            return prev;
          }
          function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
            if (!ctx) return fn2;
            if (fn2._n) {
              return fn2;
            }
            const renderFnWithContext = (...args) => {
              if (renderFnWithContext._d) {
                setBlockTracking(-1);
              }
              const prevInstance = setCurrentRenderingInstance(ctx);
              let res;
              try {
                res = fn2(...args);
              } finally {
                setCurrentRenderingInstance(prevInstance);
                if (renderFnWithContext._d) {
                  setBlockTracking(1);
                }
              }
              return res;
            };
            renderFnWithContext._n = true;
            renderFnWithContext._c = true;
            renderFnWithContext._d = true;
            return renderFnWithContext;
          }
          function withDirectives(vnode, directives) {
            if (currentRenderingInstance === null) {
              return vnode;
            }
            const instance = getComponentPublicInstance(currentRenderingInstance);
            const bindings = vnode.dirs || (vnode.dirs = []);
            for (let i = 0; i < directives.length; i++) {
              let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
              if (dir) {
                if (isFunction$1(dir)) {
                  dir = {
                    mounted: dir,
                    updated: dir
                  };
                }
                if (dir.deep) {
                  traverse(value);
                }
                bindings.push({
                  dir,
                  instance,
                  value,
                  oldValue: void 0,
                  arg,
                  modifiers
                });
              }
            }
            return vnode;
          }
          function invokeDirectiveHook(vnode, prevVNode, instance, name) {
            const bindings = vnode.dirs;
            const oldBindings = prevVNode && prevVNode.dirs;
            for (let i = 0; i < bindings.length; i++) {
              const binding = bindings[i];
              if (oldBindings) {
                binding.oldValue = oldBindings[i].value;
              }
              let hook = binding.dir[name];
              if (hook) {
                pauseTracking();
                callWithAsyncErrorHandling(hook, instance, 8, [
                  vnode.el,
                  binding,
                  vnode,
                  prevVNode
                ]);
                resetTracking();
              }
            }
          }
          const TeleportEndKey = Symbol("_vte");
          const isTeleport = (type) => type.__isTeleport;
          const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
          const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
          const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
          const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
          const resolveTarget = (props, select) => {
            const targetSelector = props && props.to;
            if (isString$1(targetSelector)) {
              if (!select) {
                return null;
              } else {
                const target = select(targetSelector);
                return target;
              }
            } else {
              return targetSelector;
            }
          };
          const TeleportImpl = {
            name: "Teleport",
            __isTeleport: true,
            process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
              const {
                mc: mountChildren,
                pc: patchChildren,
                pbc: patchBlockChildren,
                o: { insert, querySelector, createText, createComment }
              } = internals;
              const disabled = isTeleportDisabled(n2.props);
              let { shapeFlag, children, dynamicChildren } = n2;
              if (n1 == null) {
                const placeholder = n2.el = createText("");
                const mainAnchor = n2.anchor = createText("");
                insert(placeholder, container, anchor);
                insert(mainAnchor, container, anchor);
                const mount = (container2, anchor2) => {
                  if (shapeFlag & 16) {
                    if (parentComponent && parentComponent.isCE) {
                      parentComponent.ce._teleportTarget = container2;
                    }
                    mountChildren(
                      children,
                      container2,
                      anchor2,
                      parentComponent,
                      parentSuspense,
                      namespace,
                      slotScopeIds,
                      optimized
                    );
                  }
                };
                const mountToTarget = () => {
                  const target = n2.target = resolveTarget(n2.props, querySelector);
                  const targetAnchor = prepareAnchor(target, n2, createText, insert);
                  if (target) {
                    if (namespace !== "svg" && isTargetSVG(target)) {
                      namespace = "svg";
                    } else if (namespace !== "mathml" && isTargetMathML(target)) {
                      namespace = "mathml";
                    }
                    if (!disabled) {
                      mount(target, targetAnchor);
                      updateCssVars(n2, false);
                    }
                  }
                };
                if (disabled) {
                  mount(container, mainAnchor);
                  updateCssVars(n2, true);
                }
                if (isTeleportDeferred(n2.props)) {
                  n2.el.__isMounted = false;
                  queuePostRenderEffect(() => {
                    mountToTarget();
                    delete n2.el.__isMounted;
                  }, parentSuspense);
                } else {
                  mountToTarget();
                }
              } else {
                if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
                  queuePostRenderEffect(() => {
                    TeleportImpl.process(
                      n1,
                      n2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      namespace,
                      slotScopeIds,
                      optimized,
                      internals
                    );
                  }, parentSuspense);
                  return;
                }
                n2.el = n1.el;
                n2.targetStart = n1.targetStart;
                const mainAnchor = n2.anchor = n1.anchor;
                const target = n2.target = n1.target;
                const targetAnchor = n2.targetAnchor = n1.targetAnchor;
                const wasDisabled = isTeleportDisabled(n1.props);
                const currentContainer = wasDisabled ? container : target;
                const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
                if (namespace === "svg" || isTargetSVG(target)) {
                  namespace = "svg";
                } else if (namespace === "mathml" || isTargetMathML(target)) {
                  namespace = "mathml";
                }
                if (dynamicChildren) {
                  patchBlockChildren(
                    n1.dynamicChildren,
                    dynamicChildren,
                    currentContainer,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds
                  );
                  traverseStaticChildren(n1, n2, true);
                } else if (!optimized) {
                  patchChildren(
                    n1,
                    n2,
                    currentContainer,
                    currentAnchor,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds,
                    false
                  );
                }
                if (disabled) {
                  if (!wasDisabled) {
                    moveTeleport(
                      n2,
                      container,
                      mainAnchor,
                      internals,
                      1
                    );
                  } else {
                    if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                      n2.props.to = n1.props.to;
                    }
                  }
                } else {
                  if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = n2.target = resolveTarget(
                      n2.props,
                      querySelector
                    );
                    if (nextTarget) {
                      moveTeleport(
                        n2,
                        nextTarget,
                        null,
                        internals,
                        0
                      );
                    }
                  } else if (wasDisabled) {
                    moveTeleport(
                      n2,
                      target,
                      targetAnchor,
                      internals,
                      1
                    );
                  }
                }
                updateCssVars(n2, disabled);
              }
            },
            remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
              const {
                shapeFlag,
                children,
                anchor,
                targetStart,
                targetAnchor,
                target,
                props
              } = vnode;
              if (target) {
                hostRemove(targetStart);
                hostRemove(targetAnchor);
              }
              doRemove && hostRemove(anchor);
              if (shapeFlag & 16) {
                const shouldRemove = doRemove || !isTeleportDisabled(props);
                for (let i = 0; i < children.length; i++) {
                  const child = children[i];
                  unmount(
                    child,
                    parentComponent,
                    parentSuspense,
                    shouldRemove,
                    !!child.dynamicChildren
                  );
                }
              }
            },
            move: moveTeleport,
            hydrate: hydrateTeleport
          };
          function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
            if (moveType === 0) {
              insert(vnode.targetAnchor, container, parentAnchor);
            }
            const { el, anchor, shapeFlag, children, props } = vnode;
            const isReorder = moveType === 2;
            if (isReorder) {
              insert(el, container, parentAnchor);
            }
            if (!isReorder || isTeleportDisabled(props)) {
              if (shapeFlag & 16) {
                for (let i = 0; i < children.length; i++) {
                  move(
                    children[i],
                    container,
                    parentAnchor,
                    2
                  );
                }
              }
            }
            if (isReorder) {
              insert(anchor, container, parentAnchor);
            }
          }
          function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
            o: { nextSibling, parentNode, querySelector, insert, createText }
          }, hydrateChildren) {
            const target = vnode.target = resolveTarget(
              vnode.props,
              querySelector
            );
            if (target) {
              const disabled = isTeleportDisabled(vnode.props);
              const targetNode = target._lpa || target.firstChild;
              if (vnode.shapeFlag & 16) {
                if (disabled) {
                  vnode.anchor = hydrateChildren(
                    nextSibling(node),
                    vnode,
                    parentNode(node),
                    parentComponent,
                    parentSuspense,
                    slotScopeIds,
                    optimized
                  );
                  vnode.targetStart = targetNode;
                  vnode.targetAnchor = targetNode && nextSibling(targetNode);
                } else {
                  vnode.anchor = nextSibling(node);
                  let targetAnchor = targetNode;
                  while (targetAnchor) {
                    if (targetAnchor && targetAnchor.nodeType === 8) {
                      if (targetAnchor.data === "teleport start anchor") {
                        vnode.targetStart = targetAnchor;
                      } else if (targetAnchor.data === "teleport anchor") {
                        vnode.targetAnchor = targetAnchor;
                        target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                        break;
                      }
                    }
                    targetAnchor = nextSibling(targetAnchor);
                  }
                  if (!vnode.targetAnchor) {
                    prepareAnchor(target, vnode, createText, insert);
                  }
                  hydrateChildren(
                    targetNode && nextSibling(targetNode),
                    vnode,
                    target,
                    parentComponent,
                    parentSuspense,
                    slotScopeIds,
                    optimized
                  );
                }
              }
              updateCssVars(vnode, disabled);
            }
            return vnode.anchor && nextSibling(vnode.anchor);
          }
          const Teleport$1 = TeleportImpl;
          function updateCssVars(vnode, isDisabled) {
            const ctx = vnode.ctx;
            if (ctx && ctx.ut) {
              let node, anchor;
              if (isDisabled) {
                node = vnode.el;
                anchor = vnode.anchor;
              } else {
                node = vnode.targetStart;
                anchor = vnode.targetAnchor;
              }
              while (node && node !== anchor) {
                if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
                node = node.nextSibling;
              }
              ctx.ut();
            }
          }
          function prepareAnchor(target, vnode, createText, insert) {
            const targetStart = vnode.targetStart = createText("");
            const targetAnchor = vnode.targetAnchor = createText("");
            targetStart[TeleportEndKey] = targetAnchor;
            if (target) {
              insert(targetStart, target);
              insert(targetAnchor, target);
            }
            return targetAnchor;
          }
          const leaveCbKey = Symbol("_leaveCb");
          const enterCbKey$1 = Symbol("_enterCb");
          function useTransitionState() {
            const state = {
              isMounted: false,
              isLeaving: false,
              isUnmounting: false,
              leavingVNodes: /* @__PURE__ */ new Map()
            };
            onMounted(() => {
              state.isMounted = true;
            });
            onBeforeUnmount(() => {
              state.isUnmounting = true;
            });
            return state;
          }
          const TransitionHookValidator = [Function, Array];
          const BaseTransitionPropsValidators = {
            mode: String,
            appear: Boolean,
            persisted: Boolean,
            // enter
            onBeforeEnter: TransitionHookValidator,
            onEnter: TransitionHookValidator,
            onAfterEnter: TransitionHookValidator,
            onEnterCancelled: TransitionHookValidator,
            // leave
            onBeforeLeave: TransitionHookValidator,
            onLeave: TransitionHookValidator,
            onAfterLeave: TransitionHookValidator,
            onLeaveCancelled: TransitionHookValidator,
            // appear
            onBeforeAppear: TransitionHookValidator,
            onAppear: TransitionHookValidator,
            onAfterAppear: TransitionHookValidator,
            onAppearCancelled: TransitionHookValidator
          };
          const recursiveGetSubtree = (instance) => {
            const subTree = instance.subTree;
            return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
          };
          const BaseTransitionImpl = {
            name: `BaseTransition`,
            props: BaseTransitionPropsValidators,
            setup(props, { slots }) {
              const instance = getCurrentInstance();
              const state = useTransitionState();
              return () => {
                const children = slots.default && getTransitionRawChildren(slots.default(), true);
                if (!children || !children.length) {
                  return;
                }
                const child = findNonCommentChild(children);
                const rawProps = toRaw(props);
                const { mode } = rawProps;
                if (state.isLeaving) {
                  return emptyPlaceholder(child);
                }
                const innerChild = getInnerChild$1(child);
                if (!innerChild) {
                  return emptyPlaceholder(child);
                }
                let enterHooks = resolveTransitionHooks(
                  innerChild,
                  rawProps,
                  state,
                  instance,
                  // #11061, ensure enterHooks is fresh after clone
                  (hooks) => enterHooks = hooks
                );
                if (innerChild.type !== Comment) {
                  setTransitionHooks(innerChild, enterHooks);
                }
                let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
                if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
                  let leavingHooks = resolveTransitionHooks(
                    oldInnerChild,
                    rawProps,
                    state,
                    instance
                  );
                  setTransitionHooks(oldInnerChild, leavingHooks);
                  if (mode === "out-in" && innerChild.type !== Comment) {
                    state.isLeaving = true;
                    leavingHooks.afterLeave = () => {
                      state.isLeaving = false;
                      if (!(instance.job.flags & 8)) {
                        instance.update();
                      }
                      delete leavingHooks.afterLeave;
                      oldInnerChild = void 0;
                    };
                    return emptyPlaceholder(child);
                  } else if (mode === "in-out" && innerChild.type !== Comment) {
                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                      const leavingVNodesCache = getLeavingNodesForType(
                        state,
                        oldInnerChild
                      );
                      leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                      el[leaveCbKey] = () => {
                        earlyRemove();
                        el[leaveCbKey] = void 0;
                        delete enterHooks.delayedLeave;
                        oldInnerChild = void 0;
                      };
                      enterHooks.delayedLeave = () => {
                        delayedLeave();
                        delete enterHooks.delayedLeave;
                        oldInnerChild = void 0;
                      };
                    };
                  } else {
                    oldInnerChild = void 0;
                  }
                } else if (oldInnerChild) {
                  oldInnerChild = void 0;
                }
                return child;
              };
            }
          };
          function findNonCommentChild(children) {
            let child = children[0];
            if (children.length > 1) {
              for (const c of children) {
                if (c.type !== Comment) {
                  child = c;
                  break;
                }
              }
            }
            return child;
          }
          const BaseTransition = BaseTransitionImpl;
          function getLeavingNodesForType(state, vnode) {
            const { leavingVNodes } = state;
            let leavingVNodesCache = leavingVNodes.get(vnode.type);
            if (!leavingVNodesCache) {
              leavingVNodesCache = /* @__PURE__ */ Object.create(null);
              leavingVNodes.set(vnode.type, leavingVNodesCache);
            }
            return leavingVNodesCache;
          }
          function resolveTransitionHooks(vnode, props, state, instance, postClone) {
            const {
              appear,
              mode,
              persisted = false,
              onBeforeEnter,
              onEnter,
              onAfterEnter,
              onEnterCancelled,
              onBeforeLeave,
              onLeave,
              onAfterLeave,
              onLeaveCancelled,
              onBeforeAppear,
              onAppear,
              onAfterAppear,
              onAppearCancelled
            } = props;
            const key = String(vnode.key);
            const leavingVNodesCache = getLeavingNodesForType(state, vnode);
            const callHook2 = (hook, args) => {
              hook && callWithAsyncErrorHandling(
                hook,
                instance,
                9,
                args
              );
            };
            const callAsyncHook = (hook, args) => {
              const done = args[1];
              callHook2(hook, args);
              if (isArray$1(hook)) {
                if (hook.every((hook2) => hook2.length <= 1)) done();
              } else if (hook.length <= 1) {
                done();
              }
            };
            const hooks = {
              mode,
              persisted,
              beforeEnter(el) {
                let hook = onBeforeEnter;
                if (!state.isMounted) {
                  if (appear) {
                    hook = onBeforeAppear || onBeforeEnter;
                  } else {
                    return;
                  }
                }
                if (el[leaveCbKey]) {
                  el[leaveCbKey](
                    true
                    /* cancelled */
                  );
                }
                const leavingVNode = leavingVNodesCache[key];
                if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
                  leavingVNode.el[leaveCbKey]();
                }
                callHook2(hook, [el]);
              },
              enter(el) {
                let hook = onEnter;
                let afterHook = onAfterEnter;
                let cancelHook = onEnterCancelled;
                if (!state.isMounted) {
                  if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                  } else {
                    return;
                  }
                }
                let called = false;
                const done = el[enterCbKey$1] = (cancelled) => {
                  if (called) return;
                  called = true;
                  if (cancelled) {
                    callHook2(cancelHook, [el]);
                  } else {
                    callHook2(afterHook, [el]);
                  }
                  if (hooks.delayedLeave) {
                    hooks.delayedLeave();
                  }
                  el[enterCbKey$1] = void 0;
                };
                if (hook) {
                  callAsyncHook(hook, [el, done]);
                } else {
                  done();
                }
              },
              leave(el, remove2) {
                const key2 = String(vnode.key);
                if (el[enterCbKey$1]) {
                  el[enterCbKey$1](
                    true
                    /* cancelled */
                  );
                }
                if (state.isUnmounting) {
                  return remove2();
                }
                callHook2(onBeforeLeave, [el]);
                let called = false;
                const done = el[leaveCbKey] = (cancelled) => {
                  if (called) return;
                  called = true;
                  remove2();
                  if (cancelled) {
                    callHook2(onLeaveCancelled, [el]);
                  } else {
                    callHook2(onAfterLeave, [el]);
                  }
                  el[leaveCbKey] = void 0;
                  if (leavingVNodesCache[key2] === vnode) {
                    delete leavingVNodesCache[key2];
                  }
                };
                leavingVNodesCache[key2] = vnode;
                if (onLeave) {
                  callAsyncHook(onLeave, [el, done]);
                } else {
                  done();
                }
              },
              clone(vnode2) {
                const hooks2 = resolveTransitionHooks(
                  vnode2,
                  props,
                  state,
                  instance,
                  postClone
                );
                if (postClone) postClone(hooks2);
                return hooks2;
              }
            };
            return hooks;
          }
          function emptyPlaceholder(vnode) {
            if (isKeepAlive(vnode)) {
              vnode = cloneVNode(vnode);
              vnode.children = null;
              return vnode;
            }
          }
          function getInnerChild$1(vnode) {
            if (!isKeepAlive(vnode)) {
              if (isTeleport(vnode.type) && vnode.children) {
                return findNonCommentChild(vnode.children);
              }
              return vnode;
            }
            if (vnode.component) {
              return vnode.component.subTree;
            }
            const { shapeFlag, children } = vnode;
            if (children) {
              if (shapeFlag & 16) {
                return children[0];
              }
              if (shapeFlag & 32 && isFunction$1(children.default)) {
                return children.default();
              }
            }
          }
          function setTransitionHooks(vnode, hooks) {
            if (vnode.shapeFlag & 6 && vnode.component) {
              vnode.transition = hooks;
              setTransitionHooks(vnode.component.subTree, hooks);
            } else if (vnode.shapeFlag & 128) {
              vnode.ssContent.transition = hooks.clone(vnode.ssContent);
              vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
            } else {
              vnode.transition = hooks;
            }
          }
          function getTransitionRawChildren(children, keepComment = false, parentKey) {
            let ret = [];
            let keyedFragmentCount = 0;
            for (let i = 0; i < children.length; i++) {
              let child = children[i];
              const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
              if (child.type === Fragment) {
                if (child.patchFlag & 128) keyedFragmentCount++;
                ret = ret.concat(
                  getTransitionRawChildren(child.children, keepComment, key)
                );
              } else if (keepComment || child.type !== Comment) {
                ret.push(key != null ? cloneVNode(child, { key }) : child);
              }
            }
            if (keyedFragmentCount > 1) {
              for (let i = 0; i < ret.length; i++) {
                ret[i].patchFlag = -2;
              }
            }
            return ret;
          }
          /*! #__NO_SIDE_EFFECTS__ */
          // @__NO_SIDE_EFFECTS__
          function defineComponent(options, extraOptions) {
            return isFunction$1(options) ? (
              // #8236: extend call and options.name access are considered side-effects
              // by Rollup, so we have to wrap it in a pure-annotated IIFE.
              /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
            ) : options;
          }
          function markAsyncBoundary(instance) {
            instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
          }
          function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
            if (isArray$1(rawRef)) {
              rawRef.forEach(
                (r, i) => setRef(
                  r,
                  oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
                  parentSuspense,
                  vnode,
                  isUnmount
                )
              );
              return;
            }
            if (isAsyncWrapper(vnode) && !isUnmount) {
              if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
                setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
              }
              return;
            }
            const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
            const value = isUnmount ? null : refValue;
            const { i: owner, r: ref3 } = rawRef;
            const oldRef = oldRawRef && oldRawRef.r;
            const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
            const setupState = owner.setupState;
            const rawSetupState = toRaw(setupState);
            const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
              return hasOwn(rawSetupState, key);
            };
            if (oldRef != null && oldRef !== ref3) {
              if (isString$1(oldRef)) {
                refs[oldRef] = null;
                if (canSetSetupRef(oldRef)) {
                  setupState[oldRef] = null;
                }
              } else if (isRef(oldRef)) {
                oldRef.value = null;
              }
            }
            if (isFunction$1(ref3)) {
              callWithErrorHandling(ref3, owner, 12, [value, refs]);
            } else {
              const _isString = isString$1(ref3);
              const _isRef = isRef(ref3);
              if (_isString || _isRef) {
                const doSet = () => {
                  if (rawRef.f) {
                    const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
                    if (isUnmount) {
                      isArray$1(existing) && remove(existing, refValue);
                    } else {
                      if (!isArray$1(existing)) {
                        if (_isString) {
                          refs[ref3] = [refValue];
                          if (canSetSetupRef(ref3)) {
                            setupState[ref3] = refs[ref3];
                          }
                        } else {
                          ref3.value = [refValue];
                          if (rawRef.k) refs[rawRef.k] = ref3.value;
                        }
                      } else if (!existing.includes(refValue)) {
                        existing.push(refValue);
                      }
                    }
                  } else if (_isString) {
                    refs[ref3] = value;
                    if (canSetSetupRef(ref3)) {
                      setupState[ref3] = value;
                    }
                  } else if (_isRef) {
                    ref3.value = value;
                    if (rawRef.k) refs[rawRef.k] = value;
                  } else ;
                };
                if (value) {
                  doSet.id = -1;
                  queuePostRenderEffect(doSet, parentSuspense);
                } else {
                  doSet();
                }
              }
            }
          }
          getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
          getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
          const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
          const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
          function onActivated(hook, target) {
            registerKeepAliveHook(hook, "a", target);
          }
          function onDeactivated(hook, target) {
            registerKeepAliveHook(hook, "da", target);
          }
          function registerKeepAliveHook(hook, type, target = currentInstance) {
            const wrappedHook = hook.__wdc || (hook.__wdc = () => {
              let current = target;
              while (current) {
                if (current.isDeactivated) {
                  return;
                }
                current = current.parent;
              }
              return hook();
            });
            injectHook(type, wrappedHook, target);
            if (target) {
              let current = target.parent;
              while (current && current.parent) {
                if (isKeepAlive(current.parent.vnode)) {
                  injectToKeepAliveRoot(wrappedHook, type, target, current);
                }
                current = current.parent;
              }
            }
          }
          function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
            const injected = injectHook(
              type,
              hook,
              keepAliveRoot,
              true
              /* prepend */
            );
            onUnmounted(() => {
              remove(keepAliveRoot[type], injected);
            }, target);
          }
          function injectHook(type, hook, target = currentInstance, prepend = false) {
            if (target) {
              const hooks = target[type] || (target[type] = []);
              const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
                pauseTracking();
                const reset = setCurrentInstance(target);
                const res = callWithAsyncErrorHandling(hook, target, type, args);
                reset();
                resetTracking();
                return res;
              });
              if (prepend) {
                hooks.unshift(wrappedHook);
              } else {
                hooks.push(wrappedHook);
              }
              return wrappedHook;
            }
          }
          const createHook = (lifecycle) => (hook, target = currentInstance) => {
            if (!isInSSRComponentSetup || lifecycle === "sp") {
              injectHook(lifecycle, (...args) => hook(...args), target);
            }
          };
          const onBeforeMount = createHook("bm");
          const onMounted = createHook("m");
          const onBeforeUpdate = createHook(
            "bu"
          );
          const onUpdated = createHook("u");
          const onBeforeUnmount = createHook(
            "bum"
          );
          const onUnmounted = createHook("um");
          const onServerPrefetch = createHook(
            "sp"
          );
          const onRenderTriggered = createHook("rtg");
          const onRenderTracked = createHook("rtc");
          function onErrorCaptured(hook, target = currentInstance) {
            injectHook("ec", hook, target);
          }
          const COMPONENTS = "components";
          function resolveComponent(name, maybeSelfReference) {
            return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
          }
          const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
          function resolveDynamicComponent(component) {
            if (isString$1(component)) {
              return resolveAsset(COMPONENTS, component, false) || component;
            } else {
              return component || NULL_DYNAMIC_COMPONENT;
            }
          }
          function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
            const instance = currentRenderingInstance || currentInstance;
            if (instance) {
              const Component = instance.type;
              {
                const selfName = getComponentName(
                  Component,
                  false
                );
                if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
                  return Component;
                }
              }
              const res = (
                // local registration
                // check instance[type] first which is resolved for options API
                resolve(instance[type] || Component[type], name) || // global registration
                resolve(instance.appContext[type], name)
              );
              if (!res && maybeSelfReference) {
                return Component;
              }
              return res;
            }
          }
          function resolve(registry, name) {
            return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
          }
          function renderList(source, renderItem, cache, index) {
            let ret;
            const cached = cache;
            const sourceIsArray = isArray$1(source);
            if (sourceIsArray || isString$1(source)) {
              const sourceIsReactiveArray = sourceIsArray && isReactive(source);
              let needsWrap = false;
              let isReadonlySource = false;
              if (sourceIsReactiveArray) {
                needsWrap = !isShallow(source);
                isReadonlySource = isReadonly(source);
                source = shallowReadArray(source);
              }
              ret = new Array(source.length);
              for (let i = 0, l = source.length; i < l; i++) {
                ret[i] = renderItem(
                  needsWrap ? isReadonlySource ? toReadonly(toReactive(source[i])) : toReactive(source[i]) : source[i],
                  i,
                  void 0,
                  cached
                );
              }
            } else if (typeof source === "number") {
              ret = new Array(source);
              for (let i = 0; i < source; i++) {
                ret[i] = renderItem(i + 1, i, void 0, cached);
              }
            } else if (isObject$1(source)) {
              if (source[Symbol.iterator]) {
                ret = Array.from(
                  source,
                  (item, i) => renderItem(item, i, void 0, cached)
                );
              } else {
                const keys2 = Object.keys(source);
                ret = new Array(keys2.length);
                for (let i = 0, l = keys2.length; i < l; i++) {
                  const key = keys2[i];
                  ret[i] = renderItem(source[key], key, i, cached);
                }
              }
            } else {
              ret = [];
            }
            return ret;
          }
          function createSlots(slots, dynamicSlots) {
            for (let i = 0; i < dynamicSlots.length; i++) {
              const slot = dynamicSlots[i];
              if (isArray$1(slot)) {
                for (let j = 0; j < slot.length; j++) {
                  slots[slot[j].name] = slot[j].fn;
                }
              } else if (slot) {
                slots[slot.name] = slot.key ? (...args) => {
                  const res = slot.fn(...args);
                  if (res) res.key = slot.key;
                  return res;
                } : slot.fn;
              }
            }
            return slots;
          }
          function renderSlot(slots, name, props = {}, fallback, noSlotted) {
            if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
              if (name !== "default") props.name = name;
              return openBlock(), createBlock(
                Fragment,
                null,
                [createVNode("slot", props, fallback && fallback())],
                64
              );
            }
            let slot = slots[name];
            if (slot && slot._c) {
              slot._d = false;
            }
            openBlock();
            const validSlotContent = slot && ensureValidVNode(slot(props));
            const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
            // key attached in the `createSlots` helper, respect that
            validSlotContent && validSlotContent.key;
            const rendered = createBlock(
              Fragment,
              {
                key: (slotKey && !isSymbol$1(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
                (!validSlotContent && fallback ? "_fb" : "")
              },
              validSlotContent || (fallback ? fallback() : []),
              validSlotContent && slots._ === 1 ? 64 : -2
            );
            if (rendered.scopeId) {
              rendered.slotScopeIds = [rendered.scopeId + "-s"];
            }
            if (slot && slot._c) {
              slot._d = true;
            }
            return rendered;
          }
          function ensureValidVNode(vnodes) {
            return vnodes.some((child) => {
              if (!isVNode(child)) return true;
              if (child.type === Comment) return false;
              if (child.type === Fragment && !ensureValidVNode(child.children))
                return false;
              return true;
            }) ? vnodes : null;
          }
          function toHandlers(obj, preserveCaseIfNecessary) {
            const ret = {};
            for (const key in obj) {
              ret[toHandlerKey(key)] = obj[key];
            }
            return ret;
          }
          const getPublicInstance = (i) => {
            if (!i) return null;
            if (isStatefulComponent(i)) return getComponentPublicInstance(i);
            return getPublicInstance(i.parent);
          };
          const publicPropertiesMap = (
            // Move PURE marker to new line to workaround compiler discarding it
            // due to type annotation
            /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
              $: (i) => i,
              $el: (i) => i.vnode.el,
              $data: (i) => i.data,
              $props: (i) => i.props,
              $attrs: (i) => i.attrs,
              $slots: (i) => i.slots,
              $refs: (i) => i.refs,
              $parent: (i) => getPublicInstance(i.parent),
              $root: (i) => getPublicInstance(i.root),
              $host: (i) => i.ce,
              $emit: (i) => i.emit,
              $options: (i) => resolveMergedOptions(i),
              $forceUpdate: (i) => i.f || (i.f = () => {
                queueJob(i.update);
              }),
              $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
              $watch: (i) => instanceWatch.bind(i)
            })
          );
          const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
          const PublicInstanceProxyHandlers = {
            get({ _: instance }, key) {
              if (key === "__v_skip") {
                return true;
              }
              const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
              let normalizedProps;
              if (key[0] !== "$") {
                const n = accessCache[key];
                if (n !== void 0) {
                  switch (n) {
                    case 1:
                      return setupState[key];
                    case 2:
                      return data[key];
                    case 4:
                      return ctx[key];
                    case 3:
                      return props[key];
                  }
                } else if (hasSetupBinding(setupState, key)) {
                  accessCache[key] = 1;
                  return setupState[key];
                } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
                  accessCache[key] = 2;
                  return data[key];
                } else if (
                  // only cache other properties when instance has declared (thus stable)
                  // props
                  (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
                ) {
                  accessCache[key] = 3;
                  return props[key];
                } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
                  accessCache[key] = 4;
                  return ctx[key];
                } else if (shouldCacheAccess) {
                  accessCache[key] = 0;
                }
              }
              const publicGetter = publicPropertiesMap[key];
              let cssModule, globalProperties;
              if (publicGetter) {
                if (key === "$attrs") {
                  track(instance.attrs, "get", "");
                }
                return publicGetter(instance);
              } else if (
                // css module (injected by vue-loader)
                (cssModule = type.__cssModules) && (cssModule = cssModule[key])
              ) {
                return cssModule;
              } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
                accessCache[key] = 4;
                return ctx[key];
              } else if (
                // global properties
                globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
              ) {
                {
                  return globalProperties[key];
                }
              } else ;
            },
            set({ _: instance }, key, value) {
              const { data, setupState, ctx } = instance;
              if (hasSetupBinding(setupState, key)) {
                setupState[key] = value;
                return true;
              } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
                data[key] = value;
                return true;
              } else if (hasOwn(instance.props, key)) {
                return false;
              }
              if (key[0] === "$" && key.slice(1) in instance) {
                return false;
              } else {
                {
                  ctx[key] = value;
                }
              }
              return true;
            },
            has({
              _: { data, setupState, accessCache, ctx, appContext, propsOptions }
            }, key) {
              let normalizedProps;
              return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
            },
            defineProperty(target, key, descriptor) {
              if (descriptor.get != null) {
                target._.accessCache[key] = 0;
              } else if (hasOwn(descriptor, "value")) {
                this.set(target, key, descriptor.value, null);
              }
              return Reflect.defineProperty(target, key, descriptor);
            }
          };
          function useSlots() {
            return getContext().slots;
          }
          function useAttrs$1() {
            return getContext().attrs;
          }
          function getContext() {
            const i = getCurrentInstance();
            return i.setupContext || (i.setupContext = createSetupContext(i));
          }
          function normalizePropsOrEmits(props) {
            return isArray$1(props) ? props.reduce(
              (normalized, p2) => (normalized[p2] = null, normalized),
              {}
            ) : props;
          }
          let shouldCacheAccess = true;
          function applyOptions(instance) {
            const options = resolveMergedOptions(instance);
            const publicThis = instance.proxy;
            const ctx = instance.ctx;
            shouldCacheAccess = false;
            if (options.beforeCreate) {
              callHook$1(options.beforeCreate, instance, "bc");
            }
            const {
              // state
              data: dataOptions,
              computed: computedOptions,
              methods,
              watch: watchOptions,
              provide: provideOptions,
              inject: injectOptions,
              // lifecycle
              created,
              beforeMount,
              mounted,
              beforeUpdate,
              updated,
              activated,
              deactivated,
              beforeDestroy,
              beforeUnmount,
              destroyed,
              unmounted,
              render: render2,
              renderTracked,
              renderTriggered,
              errorCaptured,
              serverPrefetch,
              // public API
              expose,
              inheritAttrs,
              // assets
              components,
              directives,
              filters
            } = options;
            const checkDuplicateProperties = null;
            if (injectOptions) {
              resolveInjections(injectOptions, ctx, checkDuplicateProperties);
            }
            if (methods) {
              for (const key in methods) {
                const methodHandler = methods[key];
                if (isFunction$1(methodHandler)) {
                  {
                    ctx[key] = methodHandler.bind(publicThis);
                  }
                }
              }
            }
            if (dataOptions) {
              const data = dataOptions.call(publicThis, publicThis);
              if (!isObject$1(data)) ;
              else {
                instance.data = reactive(data);
              }
            }
            shouldCacheAccess = true;
            if (computedOptions) {
              for (const key in computedOptions) {
                const opt = computedOptions[key];
                const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
                const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
                const c = computed({
                  get: get2,
                  set: set2
                });
                Object.defineProperty(ctx, key, {
                  enumerable: true,
                  configurable: true,
                  get: () => c.value,
                  set: (v) => c.value = v
                });
              }
            }
            if (watchOptions) {
              for (const key in watchOptions) {
                createWatcher(watchOptions[key], ctx, publicThis, key);
              }
            }
            if (provideOptions) {
              const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
              Reflect.ownKeys(provides).forEach((key) => {
                provide(key, provides[key]);
              });
            }
            if (created) {
              callHook$1(created, instance, "c");
            }
            function registerLifecycleHook(register, hook) {
              if (isArray$1(hook)) {
                hook.forEach((_hook) => register(_hook.bind(publicThis)));
              } else if (hook) {
                register(hook.bind(publicThis));
              }
            }
            registerLifecycleHook(onBeforeMount, beforeMount);
            registerLifecycleHook(onMounted, mounted);
            registerLifecycleHook(onBeforeUpdate, beforeUpdate);
            registerLifecycleHook(onUpdated, updated);
            registerLifecycleHook(onActivated, activated);
            registerLifecycleHook(onDeactivated, deactivated);
            registerLifecycleHook(onErrorCaptured, errorCaptured);
            registerLifecycleHook(onRenderTracked, renderTracked);
            registerLifecycleHook(onRenderTriggered, renderTriggered);
            registerLifecycleHook(onBeforeUnmount, beforeUnmount);
            registerLifecycleHook(onUnmounted, unmounted);
            registerLifecycleHook(onServerPrefetch, serverPrefetch);
            if (isArray$1(expose)) {
              if (expose.length) {
                const exposed = instance.exposed || (instance.exposed = {});
                expose.forEach((key) => {
                  Object.defineProperty(exposed, key, {
                    get: () => publicThis[key],
                    set: (val) => publicThis[key] = val
                  });
                });
              } else if (!instance.exposed) {
                instance.exposed = {};
              }
            }
            if (render2 && instance.render === NOOP) {
              instance.render = render2;
            }
            if (inheritAttrs != null) {
              instance.inheritAttrs = inheritAttrs;
            }
            if (components) instance.components = components;
            if (directives) instance.directives = directives;
            if (serverPrefetch) {
              markAsyncBoundary(instance);
            }
          }
          function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
            if (isArray$1(injectOptions)) {
              injectOptions = normalizeInject(injectOptions);
            }
            for (const key in injectOptions) {
              const opt = injectOptions[key];
              let injected;
              if (isObject$1(opt)) {
                if ("default" in opt) {
                  injected = inject(
                    opt.from || key,
                    opt.default,
                    true
                  );
                } else {
                  injected = inject(opt.from || key);
                }
              } else {
                injected = inject(opt);
              }
              if (isRef(injected)) {
                Object.defineProperty(ctx, key, {
                  enumerable: true,
                  configurable: true,
                  get: () => injected.value,
                  set: (v) => injected.value = v
                });
              } else {
                ctx[key] = injected;
              }
            }
          }
          function callHook$1(hook, instance, type) {
            callWithAsyncErrorHandling(
              isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
              instance,
              type
            );
          }
          function createWatcher(raw, ctx, publicThis, key) {
            let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
            if (isString$1(raw)) {
              const handler = ctx[raw];
              if (isFunction$1(handler)) {
                {
                  watch(getter, handler);
                }
              }
            } else if (isFunction$1(raw)) {
              {
                watch(getter, raw.bind(publicThis));
              }
            } else if (isObject$1(raw)) {
              if (isArray$1(raw)) {
                raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
              } else {
                const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
                if (isFunction$1(handler)) {
                  watch(getter, handler, raw);
                }
              }
            } else ;
          }
          function resolveMergedOptions(instance) {
            const base = instance.type;
            const { mixins, extends: extendsOptions } = base;
            const {
              mixins: globalMixins,
              optionsCache: cache,
              config: { optionMergeStrategies }
            } = instance.appContext;
            const cached = cache.get(base);
            let resolved;
            if (cached) {
              resolved = cached;
            } else if (!globalMixins.length && !mixins && !extendsOptions) {
              {
                resolved = base;
              }
            } else {
              resolved = {};
              if (globalMixins.length) {
                globalMixins.forEach(
                  (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
                );
              }
              mergeOptions(resolved, base, optionMergeStrategies);
            }
            if (isObject$1(base)) {
              cache.set(base, resolved);
            }
            return resolved;
          }
          function mergeOptions(to, from, strats, asMixin = false) {
            const { mixins, extends: extendsOptions } = from;
            if (extendsOptions) {
              mergeOptions(to, extendsOptions, strats, true);
            }
            if (mixins) {
              mixins.forEach(
                (m) => mergeOptions(to, m, strats, true)
              );
            }
            for (const key in from) {
              if (asMixin && key === "expose") ;
              else {
                const strat = internalOptionMergeStrats[key] || strats && strats[key];
                to[key] = strat ? strat(to[key], from[key]) : from[key];
              }
            }
            return to;
          }
          const internalOptionMergeStrats = {
            data: mergeDataFn,
            props: mergeEmitsOrPropsOptions,
            emits: mergeEmitsOrPropsOptions,
            // objects
            methods: mergeObjectOptions,
            computed: mergeObjectOptions,
            // lifecycle
            beforeCreate: mergeAsArray,
            created: mergeAsArray,
            beforeMount: mergeAsArray,
            mounted: mergeAsArray,
            beforeUpdate: mergeAsArray,
            updated: mergeAsArray,
            beforeDestroy: mergeAsArray,
            beforeUnmount: mergeAsArray,
            destroyed: mergeAsArray,
            unmounted: mergeAsArray,
            activated: mergeAsArray,
            deactivated: mergeAsArray,
            errorCaptured: mergeAsArray,
            serverPrefetch: mergeAsArray,
            // assets
            components: mergeObjectOptions,
            directives: mergeObjectOptions,
            // watch
            watch: mergeWatchOptions,
            // provide / inject
            provide: mergeDataFn,
            inject: mergeInject
          };
          function mergeDataFn(to, from) {
            if (!from) {
              return to;
            }
            if (!to) {
              return from;
            }
            return function mergedDataFn() {
              return extend(
                isFunction$1(to) ? to.call(this, this) : to,
                isFunction$1(from) ? from.call(this, this) : from
              );
            };
          }
          function mergeInject(to, from) {
            return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
          }
          function normalizeInject(raw) {
            if (isArray$1(raw)) {
              const res = {};
              for (let i = 0; i < raw.length; i++) {
                res[raw[i]] = raw[i];
              }
              return res;
            }
            return raw;
          }
          function mergeAsArray(to, from) {
            return to ? [...new Set([].concat(to, from))] : from;
          }
          function mergeObjectOptions(to, from) {
            return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
          }
          function mergeEmitsOrPropsOptions(to, from) {
            if (to) {
              if (isArray$1(to) && isArray$1(from)) {
                return [.../* @__PURE__ */ new Set([...to, ...from])];
              }
              return extend(
                /* @__PURE__ */ Object.create(null),
                normalizePropsOrEmits(to),
                normalizePropsOrEmits(from != null ? from : {})
              );
            } else {
              return from;
            }
          }
          function mergeWatchOptions(to, from) {
            if (!to) return from;
            if (!from) return to;
            const merged = extend(/* @__PURE__ */ Object.create(null), to);
            for (const key in from) {
              merged[key] = mergeAsArray(to[key], from[key]);
            }
            return merged;
          }
          function createAppContext() {
            return {
              app: null,
              config: {
                isNativeTag: NO,
                performance: false,
                globalProperties: {},
                optionMergeStrategies: {},
                errorHandler: void 0,
                warnHandler: void 0,
                compilerOptions: {}
              },
              mixins: [],
              components: {},
              directives: {},
              provides: /* @__PURE__ */ Object.create(null),
              optionsCache: /* @__PURE__ */ new WeakMap(),
              propsCache: /* @__PURE__ */ new WeakMap(),
              emitsCache: /* @__PURE__ */ new WeakMap()
            };
          }
          let uid$1 = 0;
          function createAppAPI(render2, hydrate) {
            return function createApp2(rootComponent, rootProps = null) {
              if (!isFunction$1(rootComponent)) {
                rootComponent = extend({}, rootComponent);
              }
              if (rootProps != null && !isObject$1(rootProps)) {
                rootProps = null;
              }
              const context = createAppContext();
              const installedPlugins = /* @__PURE__ */ new WeakSet();
              const pluginCleanupFns = [];
              let isMounted = false;
              const app = context.app = {
                _uid: uid$1++,
                _component: rootComponent,
                _props: rootProps,
                _container: null,
                _context: context,
                _instance: null,
                version,
                get config() {
                  return context.config;
                },
                set config(v) {
                },
                use(plugin, ...options) {
                  if (installedPlugins.has(plugin)) ;
                  else if (plugin && isFunction$1(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                  } else if (isFunction$1(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                  } else ;
                  return app;
                },
                mixin(mixin) {
                  {
                    if (!context.mixins.includes(mixin)) {
                      context.mixins.push(mixin);
                    }
                  }
                  return app;
                },
                component(name, component) {
                  if (!component) {
                    return context.components[name];
                  }
                  context.components[name] = component;
                  return app;
                },
                directive(name, directive) {
                  if (!directive) {
                    return context.directives[name];
                  }
                  context.directives[name] = directive;
                  return app;
                },
                mount(rootContainer, isHydrate, namespace) {
                  if (!isMounted) {
                    const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
                    vnode.appContext = context;
                    if (namespace === true) {
                      namespace = "svg";
                    } else if (namespace === false) {
                      namespace = void 0;
                    }
                    {
                      render2(vnode, rootContainer, namespace);
                    }
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    return getComponentPublicInstance(vnode.component);
                  }
                },
                onUnmount(cleanupFn) {
                  pluginCleanupFns.push(cleanupFn);
                },
                unmount() {
                  if (isMounted) {
                    callWithAsyncErrorHandling(
                      pluginCleanupFns,
                      app._instance,
                      16
                    );
                    render2(null, app._container);
                    delete app._container.__vue_app__;
                  }
                },
                provide(key, value) {
                  context.provides[key] = value;
                  return app;
                },
                runWithContext(fn2) {
                  const lastApp = currentApp;
                  currentApp = app;
                  try {
                    return fn2();
                  } finally {
                    currentApp = lastApp;
                  }
                }
              };
              return app;
            };
          }
          let currentApp = null;
          function provide(key, value) {
            if (!currentInstance) ;
            else {
              let provides = currentInstance.provides;
              const parentProvides = currentInstance.parent && currentInstance.parent.provides;
              if (parentProvides === provides) {
                provides = currentInstance.provides = Object.create(parentProvides);
              }
              provides[key] = value;
            }
          }
          function inject(key, defaultValue, treatDefaultAsFactory = false) {
            const instance = currentInstance || currentRenderingInstance;
            if (instance || currentApp) {
              let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
              if (provides && key in provides) {
                return provides[key];
              } else if (arguments.length > 1) {
                return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
              } else ;
            }
          }
          const internalObjectProto = {};
          const createInternalObject = () => Object.create(internalObjectProto);
          const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
          function initProps(instance, rawProps, isStateful, isSSR = false) {
            const props = {};
            const attrs = createInternalObject();
            instance.propsDefaults = /* @__PURE__ */ Object.create(null);
            setFullProps(instance, rawProps, props, attrs);
            for (const key in instance.propsOptions[0]) {
              if (!(key in props)) {
                props[key] = void 0;
              }
            }
            if (isStateful) {
              instance.props = isSSR ? props : shallowReactive(props);
            } else {
              if (!instance.type.props) {
                instance.props = attrs;
              } else {
                instance.props = props;
              }
            }
            instance.attrs = attrs;
          }
          function updateProps(instance, rawProps, rawPrevProps, optimized) {
            const {
              props,
              attrs,
              vnode: { patchFlag }
            } = instance;
            const rawCurrentProps = toRaw(props);
            const [options] = instance.propsOptions;
            let hasAttrsChanged = false;
            if (
              // always force full diff in dev
              // - #1942 if hmr is enabled with sfc component
              // - vite#872 non-sfc component used by sfc component
              (optimized || patchFlag > 0) && !(patchFlag & 16)
            ) {
              if (patchFlag & 8) {
                const propsToUpdate = instance.vnode.dynamicProps;
                for (let i = 0; i < propsToUpdate.length; i++) {
                  let key = propsToUpdate[i];
                  if (isEmitListener(instance.emitsOptions, key)) {
                    continue;
                  }
                  const value = rawProps[key];
                  if (options) {
                    if (hasOwn(attrs, key)) {
                      if (value !== attrs[key]) {
                        attrs[key] = value;
                        hasAttrsChanged = true;
                      }
                    } else {
                      const camelizedKey = camelize(key);
                      props[camelizedKey] = resolvePropValue(
                        options,
                        rawCurrentProps,
                        camelizedKey,
                        value,
                        instance,
                        false
                      );
                    }
                  } else {
                    if (value !== attrs[key]) {
                      attrs[key] = value;
                      hasAttrsChanged = true;
                    }
                  }
                }
              }
            } else {
              if (setFullProps(instance, rawProps, props, attrs)) {
                hasAttrsChanged = true;
              }
              let kebabKey;
              for (const key in rawCurrentProps) {
                if (!rawProps || // for camelCase
                !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
                // and converted to camelCase (#955)
                ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
                  if (options) {
                    if (rawPrevProps && // for camelCase
                    (rawPrevProps[key] !== void 0 || // for kebab-case
                    rawPrevProps[kebabKey] !== void 0)) {
                      props[key] = resolvePropValue(
                        options,
                        rawCurrentProps,
                        key,
                        void 0,
                        instance,
                        true
                      );
                    }
                  } else {
                    delete props[key];
                  }
                }
              }
              if (attrs !== rawCurrentProps) {
                for (const key in attrs) {
                  if (!rawProps || !hasOwn(rawProps, key) && true) {
                    delete attrs[key];
                    hasAttrsChanged = true;
                  }
                }
              }
            }
            if (hasAttrsChanged) {
              trigger(instance.attrs, "set", "");
            }
          }
          function setFullProps(instance, rawProps, props, attrs) {
            const [options, needCastKeys] = instance.propsOptions;
            let hasAttrsChanged = false;
            let rawCastValues;
            if (rawProps) {
              for (let key in rawProps) {
                if (isReservedProp(key)) {
                  continue;
                }
                const value = rawProps[key];
                let camelKey;
                if (options && hasOwn(options, camelKey = camelize(key))) {
                  if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                    props[camelKey] = value;
                  } else {
                    (rawCastValues || (rawCastValues = {}))[camelKey] = value;
                  }
                } else if (!isEmitListener(instance.emitsOptions, key)) {
                  if (!(key in attrs) || value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                  }
                }
              }
            }
            if (needCastKeys) {
              const rawCurrentProps = toRaw(props);
              const castValues = rawCastValues || EMPTY_OBJ;
              for (let i = 0; i < needCastKeys.length; i++) {
                const key = needCastKeys[i];
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  castValues[key],
                  instance,
                  !hasOwn(castValues, key)
                );
              }
            }
            return hasAttrsChanged;
          }
          function resolvePropValue(options, props, key, value, instance, isAbsent) {
            const opt = options[key];
            if (opt != null) {
              const hasDefault = hasOwn(opt, "default");
              if (hasDefault && value === void 0) {
                const defaultValue = opt.default;
                if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
                  const { propsDefaults } = instance;
                  if (key in propsDefaults) {
                    value = propsDefaults[key];
                  } else {
                    const reset = setCurrentInstance(instance);
                    value = propsDefaults[key] = defaultValue.call(
                      null,
                      props
                    );
                    reset();
                  }
                } else {
                  value = defaultValue;
                }
                if (instance.ce) {
                  instance.ce._setProp(key, value);
                }
              }
              if (opt[
                0
                /* shouldCast */
              ]) {
                if (isAbsent && !hasDefault) {
                  value = false;
                } else if (opt[
                  1
                  /* shouldCastTrue */
                ] && (value === "" || value === hyphenate(key))) {
                  value = true;
                }
              }
            }
            return value;
          }
          const mixinPropsCache = /* @__PURE__ */ new WeakMap();
          function normalizePropsOptions(comp, appContext, asMixin = false) {
            const cache = asMixin ? mixinPropsCache : appContext.propsCache;
            const cached = cache.get(comp);
            if (cached) {
              return cached;
            }
            const raw = comp.props;
            const normalized = {};
            const needCastKeys = [];
            let hasExtends = false;
            if (!isFunction$1(comp)) {
              const extendProps = (raw2) => {
                hasExtends = true;
                const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
                extend(normalized, props);
                if (keys2) needCastKeys.push(...keys2);
              };
              if (!asMixin && appContext.mixins.length) {
                appContext.mixins.forEach(extendProps);
              }
              if (comp.extends) {
                extendProps(comp.extends);
              }
              if (comp.mixins) {
                comp.mixins.forEach(extendProps);
              }
            }
            if (!raw && !hasExtends) {
              if (isObject$1(comp)) {
                cache.set(comp, EMPTY_ARR);
              }
              return EMPTY_ARR;
            }
            if (isArray$1(raw)) {
              for (let i = 0; i < raw.length; i++) {
                const normalizedKey = camelize(raw[i]);
                if (validatePropName(normalizedKey)) {
                  normalized[normalizedKey] = EMPTY_OBJ;
                }
              }
            } else if (raw) {
              for (const key in raw) {
                const normalizedKey = camelize(key);
                if (validatePropName(normalizedKey)) {
                  const opt = raw[key];
                  const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
                  const propType = prop.type;
                  let shouldCast = false;
                  let shouldCastTrue = true;
                  if (isArray$1(propType)) {
                    for (let index = 0; index < propType.length; ++index) {
                      const type = propType[index];
                      const typeName = isFunction$1(type) && type.name;
                      if (typeName === "Boolean") {
                        shouldCast = true;
                        break;
                      } else if (typeName === "String") {
                        shouldCastTrue = false;
                      }
                    }
                  } else {
                    shouldCast = isFunction$1(propType) && propType.name === "Boolean";
                  }
                  prop[
                    0
                    /* shouldCast */
                  ] = shouldCast;
                  prop[
                    1
                    /* shouldCastTrue */
                  ] = shouldCastTrue;
                  if (shouldCast || hasOwn(prop, "default")) {
                    needCastKeys.push(normalizedKey);
                  }
                }
              }
            }
            const res = [normalized, needCastKeys];
            if (isObject$1(comp)) {
              cache.set(comp, res);
            }
            return res;
          }
          function validatePropName(key) {
            if (key[0] !== "$" && !isReservedProp(key)) {
              return true;
            }
            return false;
          }
          const isInternalKey = (key) => key[0] === "_" || key === "$stable";
          const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
          const normalizeSlot = (key, rawSlot, ctx) => {
            if (rawSlot._n) {
              return rawSlot;
            }
            const normalized = withCtx((...args) => {
              if (false) ;
              return normalizeSlotValue(rawSlot(...args));
            }, ctx);
            normalized._c = false;
            return normalized;
          };
          const normalizeObjectSlots = (rawSlots, slots, instance) => {
            const ctx = rawSlots._ctx;
            for (const key in rawSlots) {
              if (isInternalKey(key)) continue;
              const value = rawSlots[key];
              if (isFunction$1(value)) {
                slots[key] = normalizeSlot(key, value, ctx);
              } else if (value != null) {
                const normalized = normalizeSlotValue(value);
                slots[key] = () => normalized;
              }
            }
          };
          const normalizeVNodeSlots = (instance, children) => {
            const normalized = normalizeSlotValue(children);
            instance.slots.default = () => normalized;
          };
          const assignSlots = (slots, children, optimized) => {
            for (const key in children) {
              if (optimized || !isInternalKey(key)) {
                slots[key] = children[key];
              }
            }
          };
          const initSlots = (instance, children, optimized) => {
            const slots = instance.slots = createInternalObject();
            if (instance.vnode.shapeFlag & 32) {
              const cacheIndexes = children.__;
              if (cacheIndexes) def(slots, "__", cacheIndexes, true);
              const type = children._;
              if (type) {
                assignSlots(slots, children, optimized);
                if (optimized) {
                  def(slots, "_", type, true);
                }
              } else {
                normalizeObjectSlots(children, slots);
              }
            } else if (children) {
              normalizeVNodeSlots(instance, children);
            }
          };
          const updateSlots = (instance, children, optimized) => {
            const { vnode, slots } = instance;
            let needDeletionCheck = true;
            let deletionComparisonTarget = EMPTY_OBJ;
            if (vnode.shapeFlag & 32) {
              const type = children._;
              if (type) {
                if (optimized && type === 1) {
                  needDeletionCheck = false;
                } else {
                  assignSlots(slots, children, optimized);
                }
              } else {
                needDeletionCheck = !children.$stable;
                normalizeObjectSlots(children, slots);
              }
              deletionComparisonTarget = children;
            } else if (children) {
              normalizeVNodeSlots(instance, children);
              deletionComparisonTarget = { default: 1 };
            }
            if (needDeletionCheck) {
              for (const key in slots) {
                if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
                  delete slots[key];
                }
              }
            }
          };
          const queuePostRenderEffect = queueEffectWithSuspense;
          function createRenderer(options) {
            return baseCreateRenderer(options);
          }
          function baseCreateRenderer(options, createHydrationFns) {
            const target = getGlobalThis();
            target.__VUE__ = true;
            const {
              insert: hostInsert,
              remove: hostRemove,
              patchProp: hostPatchProp,
              createElement: hostCreateElement,
              createText: hostCreateText,
              createComment: hostCreateComment,
              setText: hostSetText,
              setElementText: hostSetElementText,
              parentNode: hostParentNode,
              nextSibling: hostNextSibling,
              setScopeId: hostSetScopeId = NOOP,
              insertStaticContent: hostInsertStaticContent
            } = options;
            const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
              if (n1 === n2) {
                return;
              }
              if (n1 && !isSameVNodeType(n1, n2)) {
                anchor = getNextHostNode(n1);
                unmount(n1, parentComponent, parentSuspense, true);
                n1 = null;
              }
              if (n2.patchFlag === -2) {
                optimized = false;
                n2.dynamicChildren = null;
              }
              const { type, ref: ref3, shapeFlag } = n2;
              switch (type) {
                case Text:
                  processText(n1, n2, container, anchor);
                  break;
                case Comment:
                  processCommentNode(n1, n2, container, anchor);
                  break;
                case Static:
                  if (n1 == null) {
                    mountStaticNode(n2, container, anchor, namespace);
                  }
                  break;
                case Fragment:
                  processFragment(
                    n1,
                    n2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds,
                    optimized
                  );
                  break;
                default:
                  if (shapeFlag & 1) {
                    processElement(
                      n1,
                      n2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      namespace,
                      slotScopeIds,
                      optimized
                    );
                  } else if (shapeFlag & 6) {
                    processComponent(
                      n1,
                      n2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      namespace,
                      slotScopeIds,
                      optimized
                    );
                  } else if (shapeFlag & 64) {
                    type.process(
                      n1,
                      n2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      namespace,
                      slotScopeIds,
                      optimized,
                      internals
                    );
                  } else if (shapeFlag & 128) {
                    type.process(
                      n1,
                      n2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      namespace,
                      slotScopeIds,
                      optimized,
                      internals
                    );
                  } else ;
              }
              if (ref3 != null && parentComponent) {
                setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
              } else if (ref3 == null && n1 && n1.ref != null) {
                setRef(n1.ref, null, parentSuspense, n1, true);
              }
            };
            const processText = (n1, n2, container, anchor) => {
              if (n1 == null) {
                hostInsert(
                  n2.el = hostCreateText(n2.children),
                  container,
                  anchor
                );
              } else {
                const el = n2.el = n1.el;
                if (n2.children !== n1.children) {
                  hostSetText(el, n2.children);
                }
              }
            };
            const processCommentNode = (n1, n2, container, anchor) => {
              if (n1 == null) {
                hostInsert(
                  n2.el = hostCreateComment(n2.children || ""),
                  container,
                  anchor
                );
              } else {
                n2.el = n1.el;
              }
            };
            const mountStaticNode = (n2, container, anchor, namespace) => {
              [n2.el, n2.anchor] = hostInsertStaticContent(
                n2.children,
                container,
                anchor,
                namespace,
                n2.el,
                n2.anchor
              );
            };
            const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
              let next;
              while (el && el !== anchor) {
                next = hostNextSibling(el);
                hostInsert(el, container, nextSibling);
                el = next;
              }
              hostInsert(anchor, container, nextSibling);
            };
            const removeStaticNode = ({ el, anchor }) => {
              let next;
              while (el && el !== anchor) {
                next = hostNextSibling(el);
                hostRemove(el);
                el = next;
              }
              hostRemove(anchor);
            };
            const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
              if (n2.type === "svg") {
                namespace = "svg";
              } else if (n2.type === "math") {
                namespace = "mathml";
              }
              if (n1 == null) {
                mountElement(
                  n2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else {
                patchElement(
                  n1,
                  n2,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              }
            };
            const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
              let el;
              let vnodeHook;
              const { props, shapeFlag, transition, dirs } = vnode;
              el = vnode.el = hostCreateElement(
                vnode.type,
                namespace,
                props && props.is,
                props
              );
              if (shapeFlag & 8) {
                hostSetElementText(el, vnode.children);
              } else if (shapeFlag & 16) {
                mountChildren(
                  vnode.children,
                  el,
                  null,
                  parentComponent,
                  parentSuspense,
                  resolveChildrenNamespace(vnode, namespace),
                  slotScopeIds,
                  optimized
                );
              }
              if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, "created");
              }
              setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
              if (props) {
                for (const key in props) {
                  if (key !== "value" && !isReservedProp(key)) {
                    hostPatchProp(el, key, null, props[key], namespace, parentComponent);
                  }
                }
                if ("value" in props) {
                  hostPatchProp(el, "value", null, props.value, namespace);
                }
                if (vnodeHook = props.onVnodeBeforeMount) {
                  invokeVNodeHook(vnodeHook, parentComponent, vnode);
                }
              }
              if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
              }
              const needCallTransitionHooks = needTransition(parentSuspense, transition);
              if (needCallTransitionHooks) {
                transition.beforeEnter(el);
              }
              hostInsert(el, container, anchor);
              if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
                queuePostRenderEffect(() => {
                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                  needCallTransitionHooks && transition.enter(el);
                  dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
                }, parentSuspense);
              }
            };
            const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
              if (scopeId) {
                hostSetScopeId(el, scopeId);
              }
              if (slotScopeIds) {
                for (let i = 0; i < slotScopeIds.length; i++) {
                  hostSetScopeId(el, slotScopeIds[i]);
                }
              }
              if (parentComponent) {
                let subTree = parentComponent.subTree;
                if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
                  const parentVNode = parentComponent.vnode;
                  setScopeId(
                    el,
                    parentVNode,
                    parentVNode.scopeId,
                    parentVNode.slotScopeIds,
                    parentComponent.parent
                  );
                }
              }
            };
            const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
              for (let i = start; i < children.length; i++) {
                const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
                patch(
                  null,
                  child,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              }
            };
            const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
              const el = n2.el = n1.el;
              let { patchFlag, dynamicChildren, dirs } = n2;
              patchFlag |= n1.patchFlag & 16;
              const oldProps = n1.props || EMPTY_OBJ;
              const newProps = n2.props || EMPTY_OBJ;
              let vnodeHook;
              parentComponent && toggleRecurse(parentComponent, false);
              if (vnodeHook = newProps.onVnodeBeforeUpdate) {
                invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
              }
              if (dirs) {
                invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
              }
              parentComponent && toggleRecurse(parentComponent, true);
              if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
                hostSetElementText(el, "");
              }
              if (dynamicChildren) {
                patchBlockChildren(
                  n1.dynamicChildren,
                  dynamicChildren,
                  el,
                  parentComponent,
                  parentSuspense,
                  resolveChildrenNamespace(n2, namespace),
                  slotScopeIds
                );
              } else if (!optimized) {
                patchChildren(
                  n1,
                  n2,
                  el,
                  null,
                  parentComponent,
                  parentSuspense,
                  resolveChildrenNamespace(n2, namespace),
                  slotScopeIds,
                  false
                );
              }
              if (patchFlag > 0) {
                if (patchFlag & 16) {
                  patchProps(el, oldProps, newProps, parentComponent, namespace);
                } else {
                  if (patchFlag & 2) {
                    if (oldProps.class !== newProps.class) {
                      hostPatchProp(el, "class", null, newProps.class, namespace);
                    }
                  }
                  if (patchFlag & 4) {
                    hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
                  }
                  if (patchFlag & 8) {
                    const propsToUpdate = n2.dynamicProps;
                    for (let i = 0; i < propsToUpdate.length; i++) {
                      const key = propsToUpdate[i];
                      const prev = oldProps[key];
                      const next = newProps[key];
                      if (next !== prev || key === "value") {
                        hostPatchProp(el, key, prev, next, namespace, parentComponent);
                      }
                    }
                  }
                }
                if (patchFlag & 1) {
                  if (n1.children !== n2.children) {
                    hostSetElementText(el, n2.children);
                  }
                }
              } else if (!optimized && dynamicChildren == null) {
                patchProps(el, oldProps, newProps, parentComponent, namespace);
              }
              if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
                queuePostRenderEffect(() => {
                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                  dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
                }, parentSuspense);
              }
            };
            const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
              for (let i = 0; i < newChildren.length; i++) {
                const oldVNode = oldChildren[i];
                const newVNode = newChildren[i];
                const container = (
                  // oldVNode may be an errored async setup() component inside Suspense
                  // which will not have a mounted element
                  oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
                  // of the Fragment itself so it can move its children.
                  (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
                  // which also requires the correct parent container
                  !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
                  oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
                    // In other cases, the parent container is not actually used so we
                    // just pass the block element here to avoid a DOM parentNode call.
                    fallbackContainer
                  )
                );
                patch(
                  oldVNode,
                  newVNode,
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  true
                );
              }
            };
            const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
              if (oldProps !== newProps) {
                if (oldProps !== EMPTY_OBJ) {
                  for (const key in oldProps) {
                    if (!isReservedProp(key) && !(key in newProps)) {
                      hostPatchProp(
                        el,
                        key,
                        oldProps[key],
                        null,
                        namespace,
                        parentComponent
                      );
                    }
                  }
                }
                for (const key in newProps) {
                  if (isReservedProp(key)) continue;
                  const next = newProps[key];
                  const prev = oldProps[key];
                  if (next !== prev && key !== "value") {
                    hostPatchProp(el, key, prev, next, namespace, parentComponent);
                  }
                }
                if ("value" in newProps) {
                  hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
                }
              }
            };
            const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
              const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
              const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
              let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
              if (fragmentSlotScopeIds) {
                slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
              }
              if (n1 == null) {
                hostInsert(fragmentStartAnchor, container, anchor);
                hostInsert(fragmentEndAnchor, container, anchor);
                mountChildren(
                  // #10007
                  // such fragment like `<></>` will be compiled into
                  // a fragment which doesn't have a children.
                  // In this case fallback to an empty array
                  n2.children || [],
                  container,
                  fragmentEndAnchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              } else {
                if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
                // of renderSlot() with no valid children
                n1.dynamicChildren) {
                  patchBlockChildren(
                    n1.dynamicChildren,
                    dynamicChildren,
                    container,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds
                  );
                  if (
                    // #2080 if the stable fragment has a key, it's a <template v-for> that may
                    //  get moved around. Make sure all root level vnodes inherit el.
                    // #2134 or if it's a component root, it may also get moved around
                    // as the component is being moved.
                    n2.key != null || parentComponent && n2 === parentComponent.subTree
                  ) {
                    traverseStaticChildren(
                      n1,
                      n2,
                      true
                      /* shallow */
                    );
                  }
                } else {
                  patchChildren(
                    n1,
                    n2,
                    container,
                    fragmentEndAnchor,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds,
                    optimized
                  );
                }
              }
            };
            const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
              n2.slotScopeIds = slotScopeIds;
              if (n1 == null) {
                if (n2.shapeFlag & 512) {
                  parentComponent.ctx.activate(
                    n2,
                    container,
                    anchor,
                    namespace,
                    optimized
                  );
                } else {
                  mountComponent(
                    n2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    optimized
                  );
                }
              } else {
                updateComponent(n1, n2, optimized);
              }
            };
            const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
              const instance = initialVNode.component = createComponentInstance(
                initialVNode,
                parentComponent,
                parentSuspense
              );
              if (isKeepAlive(initialVNode)) {
                instance.ctx.renderer = internals;
              }
              {
                setupComponent(instance, false, optimized);
              }
              if (instance.asyncDep) {
                parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
                if (!initialVNode.el) {
                  const placeholder = instance.subTree = createVNode(Comment);
                  processCommentNode(null, placeholder, container, anchor);
                }
              } else {
                setupRenderEffect(
                  instance,
                  initialVNode,
                  container,
                  anchor,
                  parentSuspense,
                  namespace,
                  optimized
                );
              }
            };
            const updateComponent = (n1, n2, optimized) => {
              const instance = n2.component = n1.component;
              if (shouldUpdateComponent(n1, n2, optimized)) {
                if (instance.asyncDep && !instance.asyncResolved) {
                  updateComponentPreRender(instance, n2, optimized);
                  return;
                } else {
                  instance.next = n2;
                  instance.update();
                }
              } else {
                n2.el = n1.el;
                instance.vnode = n2;
              }
            };
            const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
              const componentUpdateFn = () => {
                if (!instance.isMounted) {
                  let vnodeHook;
                  const { el, props } = initialVNode;
                  const { bm, m, parent: parent2, root: root2, type } = instance;
                  const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                  toggleRecurse(instance, false);
                  if (bm) {
                    invokeArrayFns(bm);
                  }
                  if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parent2, initialVNode);
                  }
                  toggleRecurse(instance, true);
                  {
                    if (root2.ce && // @ts-expect-error _def is private
                    root2.ce._def.shadowRoot !== false) {
                      root2.ce._injectChildStyle(type);
                    }
                    const subTree = instance.subTree = renderComponentRoot(instance);
                    patch(
                      null,
                      subTree,
                      container,
                      anchor,
                      instance,
                      parentSuspense,
                      namespace
                    );
                    initialVNode.el = subTree.el;
                  }
                  if (m) {
                    queuePostRenderEffect(m, parentSuspense);
                  }
                  if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(
                      () => invokeVNodeHook(vnodeHook, parent2, scopedInitialVNode),
                      parentSuspense
                    );
                  }
                  if (initialVNode.shapeFlag & 256 || parent2 && isAsyncWrapper(parent2.vnode) && parent2.vnode.shapeFlag & 256) {
                    instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                  }
                  instance.isMounted = true;
                  initialVNode = container = anchor = null;
                } else {
                  let { next, bu, u, parent: parent2, vnode } = instance;
                  {
                    const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
                    if (nonHydratedAsyncRoot) {
                      if (next) {
                        next.el = vnode.el;
                        updateComponentPreRender(instance, next, optimized);
                      }
                      nonHydratedAsyncRoot.asyncDep.then(() => {
                        if (!instance.isUnmounted) {
                          componentUpdateFn();
                        }
                      });
                      return;
                    }
                  }
                  let originNext = next;
                  let vnodeHook;
                  toggleRecurse(instance, false);
                  if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                  } else {
                    next = vnode;
                  }
                  if (bu) {
                    invokeArrayFns(bu);
                  }
                  if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
                    invokeVNodeHook(vnodeHook, parent2, next, vnode);
                  }
                  toggleRecurse(instance, true);
                  const nextTree = renderComponentRoot(instance);
                  const prevTree = instance.subTree;
                  instance.subTree = nextTree;
                  patch(
                    prevTree,
                    nextTree,
                    // parent may have changed if it's in a teleport
                    hostParentNode(prevTree.el),
                    // anchor may have changed if it's in a fragment
                    getNextHostNode(prevTree),
                    instance,
                    parentSuspense,
                    namespace
                  );
                  next.el = nextTree.el;
                  if (originNext === null) {
                    updateHOCHostEl(instance, nextTree.el);
                  }
                  if (u) {
                    queuePostRenderEffect(u, parentSuspense);
                  }
                  if (vnodeHook = next.props && next.props.onVnodeUpdated) {
                    queuePostRenderEffect(
                      () => invokeVNodeHook(vnodeHook, parent2, next, vnode),
                      parentSuspense
                    );
                  }
                }
              };
              instance.scope.on();
              const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
              instance.scope.off();
              const update = instance.update = effect2.run.bind(effect2);
              const job = instance.job = effect2.runIfDirty.bind(effect2);
              job.i = instance;
              job.id = instance.uid;
              effect2.scheduler = () => queueJob(job);
              toggleRecurse(instance, true);
              update();
            };
            const updateComponentPreRender = (instance, nextVNode, optimized) => {
              nextVNode.component = instance;
              const prevProps = instance.vnode.props;
              instance.vnode = nextVNode;
              instance.next = null;
              updateProps(instance, nextVNode.props, prevProps, optimized);
              updateSlots(instance, nextVNode.children, optimized);
              pauseTracking();
              flushPreFlushCbs(instance);
              resetTracking();
            };
            const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
              const c1 = n1 && n1.children;
              const prevShapeFlag = n1 ? n1.shapeFlag : 0;
              const c2 = n2.children;
              const { patchFlag, shapeFlag } = n2;
              if (patchFlag > 0) {
                if (patchFlag & 128) {
                  patchKeyedChildren(
                    c1,
                    c2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds,
                    optimized
                  );
                  return;
                } else if (patchFlag & 256) {
                  patchUnkeyedChildren(
                    c1,
                    c2,
                    container,
                    anchor,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds,
                    optimized
                  );
                  return;
                }
              }
              if (shapeFlag & 8) {
                if (prevShapeFlag & 16) {
                  unmountChildren(c1, parentComponent, parentSuspense);
                }
                if (c2 !== c1) {
                  hostSetElementText(container, c2);
                }
              } else {
                if (prevShapeFlag & 16) {
                  if (shapeFlag & 16) {
                    patchKeyedChildren(
                      c1,
                      c2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      namespace,
                      slotScopeIds,
                      optimized
                    );
                  } else {
                    unmountChildren(c1, parentComponent, parentSuspense, true);
                  }
                } else {
                  if (prevShapeFlag & 8) {
                    hostSetElementText(container, "");
                  }
                  if (shapeFlag & 16) {
                    mountChildren(
                      c2,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      namespace,
                      slotScopeIds,
                      optimized
                    );
                  }
                }
              }
            };
            const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
              c1 = c1 || EMPTY_ARR;
              c2 = c2 || EMPTY_ARR;
              const oldLength = c1.length;
              const newLength = c2.length;
              const commonLength = Math.min(oldLength, newLength);
              let i;
              for (i = 0; i < commonLength; i++) {
                const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                patch(
                  c1[i],
                  nextChild,
                  container,
                  null,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized
                );
              }
              if (oldLength > newLength) {
                unmountChildren(
                  c1,
                  parentComponent,
                  parentSuspense,
                  true,
                  false,
                  commonLength
                );
              } else {
                mountChildren(
                  c2,
                  container,
                  anchor,
                  parentComponent,
                  parentSuspense,
                  namespace,
                  slotScopeIds,
                  optimized,
                  commonLength
                );
              }
            };
            const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
              let i = 0;
              const l2 = c2.length;
              let e1 = c1.length - 1;
              let e2 = l2 - 1;
              while (i <= e1 && i <= e2) {
                const n1 = c1[i];
                const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                if (isSameVNodeType(n1, n2)) {
                  patch(
                    n1,
                    n2,
                    container,
                    null,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds,
                    optimized
                  );
                } else {
                  break;
                }
                i++;
              }
              while (i <= e1 && i <= e2) {
                const n1 = c1[e1];
                const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
                if (isSameVNodeType(n1, n2)) {
                  patch(
                    n1,
                    n2,
                    container,
                    null,
                    parentComponent,
                    parentSuspense,
                    namespace,
                    slotScopeIds,
                    optimized
                  );
                } else {
                  break;
                }
                e1--;
                e2--;
              }
              if (i > e1) {
                if (i <= e2) {
                  const nextPos = e2 + 1;
                  const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                  while (i <= e2) {
                    patch(
                      null,
                      c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      namespace,
                      slotScopeIds,
                      optimized
                    );
                    i++;
                  }
                }
              } else if (i > e2) {
                while (i <= e1) {
                  unmount(c1[i], parentComponent, parentSuspense, true);
                  i++;
                }
              } else {
                const s1 = i;
                const s2 = i;
                const keyToNewIndexMap = /* @__PURE__ */ new Map();
                for (i = s2; i <= e2; i++) {
                  const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                  if (nextChild.key != null) {
                    keyToNewIndexMap.set(nextChild.key, i);
                  }
                }
                let j;
                let patched = 0;
                const toBePatched = e2 - s2 + 1;
                let moved = false;
                let maxNewIndexSoFar = 0;
                const newIndexToOldIndexMap = new Array(toBePatched);
                for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
                for (i = s1; i <= e1; i++) {
                  const prevChild = c1[i];
                  if (patched >= toBePatched) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                  }
                  let newIndex;
                  if (prevChild.key != null) {
                    newIndex = keyToNewIndexMap.get(prevChild.key);
                  } else {
                    for (j = s2; j <= e2; j++) {
                      if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                        newIndex = j;
                        break;
                      }
                    }
                  }
                  if (newIndex === void 0) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                  } else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) {
                      maxNewIndexSoFar = newIndex;
                    } else {
                      moved = true;
                    }
                    patch(
                      prevChild,
                      c2[newIndex],
                      container,
                      null,
                      parentComponent,
                      parentSuspense,
                      namespace,
                      slotScopeIds,
                      optimized
                    );
                    patched++;
                  }
                }
                const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
                j = increasingNewIndexSequence.length - 1;
                for (i = toBePatched - 1; i >= 0; i--) {
                  const nextIndex = s2 + i;
                  const nextChild = c2[nextIndex];
                  const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                  if (newIndexToOldIndexMap[i] === 0) {
                    patch(
                      null,
                      nextChild,
                      container,
                      anchor,
                      parentComponent,
                      parentSuspense,
                      namespace,
                      slotScopeIds,
                      optimized
                    );
                  } else if (moved) {
                    if (j < 0 || i !== increasingNewIndexSequence[j]) {
                      move(nextChild, container, anchor, 2);
                    } else {
                      j--;
                    }
                  }
                }
              }
            };
            const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
              const { el, type, transition, children, shapeFlag } = vnode;
              if (shapeFlag & 6) {
                move(vnode.component.subTree, container, anchor, moveType);
                return;
              }
              if (shapeFlag & 128) {
                vnode.suspense.move(container, anchor, moveType);
                return;
              }
              if (shapeFlag & 64) {
                type.move(vnode, container, anchor, internals);
                return;
              }
              if (type === Fragment) {
                hostInsert(el, container, anchor);
                for (let i = 0; i < children.length; i++) {
                  move(children[i], container, anchor, moveType);
                }
                hostInsert(vnode.anchor, container, anchor);
                return;
              }
              if (type === Static) {
                moveStaticNode(vnode, container, anchor);
                return;
              }
              const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
              if (needTransition2) {
                if (moveType === 0) {
                  transition.beforeEnter(el);
                  hostInsert(el, container, anchor);
                  queuePostRenderEffect(() => transition.enter(el), parentSuspense);
                } else {
                  const { leave, delayLeave, afterLeave } = transition;
                  const remove22 = () => {
                    if (vnode.ctx.isUnmounted) {
                      hostRemove(el);
                    } else {
                      hostInsert(el, container, anchor);
                    }
                  };
                  const performLeave = () => {
                    leave(el, () => {
                      remove22();
                      afterLeave && afterLeave();
                    });
                  };
                  if (delayLeave) {
                    delayLeave(el, remove22, performLeave);
                  } else {
                    performLeave();
                  }
                }
              } else {
                hostInsert(el, container, anchor);
              }
            };
            const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
              const {
                type,
                props,
                ref: ref3,
                children,
                dynamicChildren,
                shapeFlag,
                patchFlag,
                dirs,
                cacheIndex
              } = vnode;
              if (patchFlag === -2) {
                optimized = false;
              }
              if (ref3 != null) {
                pauseTracking();
                setRef(ref3, null, parentSuspense, vnode, true);
                resetTracking();
              }
              if (cacheIndex != null) {
                parentComponent.renderCache[cacheIndex] = void 0;
              }
              if (shapeFlag & 256) {
                parentComponent.ctx.deactivate(vnode);
                return;
              }
              const shouldInvokeDirs = shapeFlag & 1 && dirs;
              const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
              let vnodeHook;
              if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
                invokeVNodeHook(vnodeHook, parentComponent, vnode);
              }
              if (shapeFlag & 6) {
                unmountComponent(vnode.component, parentSuspense, doRemove);
              } else {
                if (shapeFlag & 128) {
                  vnode.suspense.unmount(parentSuspense, doRemove);
                  return;
                }
                if (shouldInvokeDirs) {
                  invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
                }
                if (shapeFlag & 64) {
                  vnode.type.remove(
                    vnode,
                    parentComponent,
                    parentSuspense,
                    internals,
                    doRemove
                  );
                } else if (dynamicChildren && // #5154
                // when v-once is used inside a block, setBlockTracking(-1) marks the
                // parent block with hasOnce: true
                // so that it doesn't take the fast path during unmount - otherwise
                // components nested in v-once are never unmounted.
                !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
                (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
                  unmountChildren(
                    dynamicChildren,
                    parentComponent,
                    parentSuspense,
                    false,
                    true
                  );
                } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
                  unmountChildren(children, parentComponent, parentSuspense);
                }
                if (doRemove) {
                  remove2(vnode);
                }
              }
              if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
                queuePostRenderEffect(() => {
                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                  shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
                }, parentSuspense);
              }
            };
            const remove2 = (vnode) => {
              const { type, el, anchor, transition } = vnode;
              if (type === Fragment) {
                {
                  removeFragment(el, anchor);
                }
                return;
              }
              if (type === Static) {
                removeStaticNode(vnode);
                return;
              }
              const performRemove = () => {
                hostRemove(el);
                if (transition && !transition.persisted && transition.afterLeave) {
                  transition.afterLeave();
                }
              };
              if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
                const { leave, delayLeave } = transition;
                const performLeave = () => leave(el, performRemove);
                if (delayLeave) {
                  delayLeave(vnode.el, performRemove, performLeave);
                } else {
                  performLeave();
                }
              } else {
                performRemove();
              }
            };
            const removeFragment = (cur, end) => {
              let next;
              while (cur !== end) {
                next = hostNextSibling(cur);
                hostRemove(cur);
                cur = next;
              }
              hostRemove(end);
            };
            const unmountComponent = (instance, parentSuspense, doRemove) => {
              const {
                bum,
                scope,
                job,
                subTree,
                um,
                m,
                a,
                parent: parent2,
                slots: { __: slotCacheKeys }
              } = instance;
              invalidateMount(m);
              invalidateMount(a);
              if (bum) {
                invokeArrayFns(bum);
              }
              if (parent2 && isArray$1(slotCacheKeys)) {
                slotCacheKeys.forEach((v) => {
                  parent2.renderCache[v] = void 0;
                });
              }
              scope.stop();
              if (job) {
                job.flags |= 8;
                unmount(subTree, instance, parentSuspense, doRemove);
              }
              if (um) {
                queuePostRenderEffect(um, parentSuspense);
              }
              queuePostRenderEffect(() => {
                instance.isUnmounted = true;
              }, parentSuspense);
              if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
                parentSuspense.deps--;
                if (parentSuspense.deps === 0) {
                  parentSuspense.resolve();
                }
              }
            };
            const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
              for (let i = start; i < children.length; i++) {
                unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
              }
            };
            const getNextHostNode = (vnode) => {
              if (vnode.shapeFlag & 6) {
                return getNextHostNode(vnode.component.subTree);
              }
              if (vnode.shapeFlag & 128) {
                return vnode.suspense.next();
              }
              const el = hostNextSibling(vnode.anchor || vnode.el);
              const teleportEnd = el && el[TeleportEndKey];
              return teleportEnd ? hostNextSibling(teleportEnd) : el;
            };
            let isFlushing = false;
            const render2 = (vnode, container, namespace) => {
              if (vnode == null) {
                if (container._vnode) {
                  unmount(container._vnode, null, null, true);
                }
              } else {
                patch(
                  container._vnode || null,
                  vnode,
                  container,
                  null,
                  null,
                  null,
                  namespace
                );
              }
              container._vnode = vnode;
              if (!isFlushing) {
                isFlushing = true;
                flushPreFlushCbs();
                flushPostFlushCbs();
                isFlushing = false;
              }
            };
            const internals = {
              p: patch,
              um: unmount,
              m: move,
              r: remove2,
              mt: mountComponent,
              mc: mountChildren,
              pc: patchChildren,
              pbc: patchBlockChildren,
              n: getNextHostNode,
              o: options
            };
            let hydrate;
            return {
              render: render2,
              hydrate,
              createApp: createAppAPI(render2)
            };
          }
          function resolveChildrenNamespace({ type, props }, currentNamespace) {
            return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
          }
          function toggleRecurse({ effect: effect2, job }, allowed) {
            if (allowed) {
              effect2.flags |= 32;
              job.flags |= 4;
            } else {
              effect2.flags &= -33;
              job.flags &= -5;
            }
          }
          function needTransition(parentSuspense, transition) {
            return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
          }
          function traverseStaticChildren(n1, n2, shallow = false) {
            const ch1 = n1.children;
            const ch2 = n2.children;
            if (isArray$1(ch1) && isArray$1(ch2)) {
              for (let i = 0; i < ch1.length; i++) {
                const c1 = ch1[i];
                let c2 = ch2[i];
                if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
                  if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                    c2 = ch2[i] = cloneIfMounted(ch2[i]);
                    c2.el = c1.el;
                  }
                  if (!shallow && c2.patchFlag !== -2)
                    traverseStaticChildren(c1, c2);
                }
                if (c2.type === Text) {
                  c2.el = c1.el;
                }
                if (c2.type === Comment && !c2.el) {
                  c2.el = c1.el;
                }
              }
            }
          }
          function getSequence(arr) {
            const p2 = arr.slice();
            const result = [0];
            let i, j, u, v, c;
            const len = arr.length;
            for (i = 0; i < len; i++) {
              const arrI = arr[i];
              if (arrI !== 0) {
                j = result[result.length - 1];
                if (arr[j] < arrI) {
                  p2[i] = j;
                  result.push(i);
                  continue;
                }
                u = 0;
                v = result.length - 1;
                while (u < v) {
                  c = u + v >> 1;
                  if (arr[result[c]] < arrI) {
                    u = c + 1;
                  } else {
                    v = c;
                  }
                }
                if (arrI < arr[result[u]]) {
                  if (u > 0) {
                    p2[i] = result[u - 1];
                  }
                  result[u] = i;
                }
              }
            }
            u = result.length;
            v = result[u - 1];
            while (u-- > 0) {
              result[u] = v;
              v = p2[v];
            }
            return result;
          }
          function locateNonHydratedAsyncRoot(instance) {
            const subComponent = instance.subTree.component;
            if (subComponent) {
              if (subComponent.asyncDep && !subComponent.asyncResolved) {
                return subComponent;
              } else {
                return locateNonHydratedAsyncRoot(subComponent);
              }
            }
          }
          function invalidateMount(hooks) {
            if (hooks) {
              for (let i = 0; i < hooks.length; i++)
                hooks[i].flags |= 8;
            }
          }
          const ssrContextKey = Symbol.for("v-scx");
          const useSSRContext = () => {
            {
              const ctx = inject(ssrContextKey);
              return ctx;
            }
          };
          function watchEffect(effect2, options) {
            return doWatch(effect2, null, options);
          }
          function watch(source, cb, options) {
            return doWatch(source, cb, options);
          }
          function doWatch(source, cb, options = EMPTY_OBJ) {
            const { immediate, deep, flush, once } = options;
            const baseWatchOptions = extend({}, options);
            const runsImmediately = cb && immediate || !cb && flush !== "post";
            let ssrCleanup;
            if (isInSSRComponentSetup) {
              if (flush === "sync") {
                const ctx = useSSRContext();
                ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
              } else if (!runsImmediately) {
                const watchStopHandle = () => {
                };
                watchStopHandle.stop = NOOP;
                watchStopHandle.resume = NOOP;
                watchStopHandle.pause = NOOP;
                return watchStopHandle;
              }
            }
            const instance = currentInstance;
            baseWatchOptions.call = (fn2, type, args) => callWithAsyncErrorHandling(fn2, instance, type, args);
            let isPre = false;
            if (flush === "post") {
              baseWatchOptions.scheduler = (job) => {
                queuePostRenderEffect(job, instance && instance.suspense);
              };
            } else if (flush !== "sync") {
              isPre = true;
              baseWatchOptions.scheduler = (job, isFirstRun) => {
                if (isFirstRun) {
                  job();
                } else {
                  queueJob(job);
                }
              };
            }
            baseWatchOptions.augmentJob = (job) => {
              if (cb) {
                job.flags |= 4;
              }
              if (isPre) {
                job.flags |= 2;
                if (instance) {
                  job.id = instance.uid;
                  job.i = instance;
                }
              }
            };
            const watchHandle = watch$1(source, cb, baseWatchOptions);
            if (isInSSRComponentSetup) {
              if (ssrCleanup) {
                ssrCleanup.push(watchHandle);
              } else if (runsImmediately) {
                watchHandle();
              }
            }
            return watchHandle;
          }
          function instanceWatch(source, value, options) {
            const publicThis = this.proxy;
            const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
            let cb;
            if (isFunction$1(value)) {
              cb = value;
            } else {
              cb = value.handler;
              options = value;
            }
            const reset = setCurrentInstance(this);
            const res = doWatch(getter, cb.bind(publicThis), options);
            reset();
            return res;
          }
          function createPathGetter(ctx, path) {
            const segments = path.split(".");
            return () => {
              let cur = ctx;
              for (let i = 0; i < segments.length && cur; i++) {
                cur = cur[segments[i]];
              }
              return cur;
            };
          }
          const getModelModifiers = (props, modelName) => {
            return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
          };
          function emit(instance, event, ...rawArgs) {
            if (instance.isUnmounted) return;
            const props = instance.vnode.props || EMPTY_OBJ;
            let args = rawArgs;
            const isModelListener2 = event.startsWith("update:");
            const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
            if (modifiers) {
              if (modifiers.trim) {
                args = rawArgs.map((a) => isString$1(a) ? a.trim() : a);
              }
              if (modifiers.number) {
                args = rawArgs.map(looseToNumber);
              }
            }
            let handlerName;
            let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
            props[handlerName = toHandlerKey(camelize(event))];
            if (!handler && isModelListener2) {
              handler = props[handlerName = toHandlerKey(hyphenate(event))];
            }
            if (handler) {
              callWithAsyncErrorHandling(
                handler,
                instance,
                6,
                args
              );
            }
            const onceHandler = props[handlerName + `Once`];
            if (onceHandler) {
              if (!instance.emitted) {
                instance.emitted = {};
              } else if (instance.emitted[handlerName]) {
                return;
              }
              instance.emitted[handlerName] = true;
              callWithAsyncErrorHandling(
                onceHandler,
                instance,
                6,
                args
              );
            }
          }
          function normalizeEmitsOptions(comp, appContext, asMixin = false) {
            const cache = appContext.emitsCache;
            const cached = cache.get(comp);
            if (cached !== void 0) {
              return cached;
            }
            const raw = comp.emits;
            let normalized = {};
            let hasExtends = false;
            if (!isFunction$1(comp)) {
              const extendEmits = (raw2) => {
                const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
                if (normalizedFromExtend) {
                  hasExtends = true;
                  extend(normalized, normalizedFromExtend);
                }
              };
              if (!asMixin && appContext.mixins.length) {
                appContext.mixins.forEach(extendEmits);
              }
              if (comp.extends) {
                extendEmits(comp.extends);
              }
              if (comp.mixins) {
                comp.mixins.forEach(extendEmits);
              }
            }
            if (!raw && !hasExtends) {
              if (isObject$1(comp)) {
                cache.set(comp, null);
              }
              return null;
            }
            if (isArray$1(raw)) {
              raw.forEach((key) => normalized[key] = null);
            } else {
              extend(normalized, raw);
            }
            if (isObject$1(comp)) {
              cache.set(comp, normalized);
            }
            return normalized;
          }
          function isEmitListener(options, key) {
            if (!options || !isOn(key)) {
              return false;
            }
            key = key.slice(2).replace(/Once$/, "");
            return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
          }
          function markAttrsAccessed() {
          }
          function renderComponentRoot(instance) {
            const {
              type: Component,
              vnode,
              proxy,
              withProxy,
              propsOptions: [propsOptions],
              slots,
              attrs,
              emit: emit2,
              render: render2,
              renderCache,
              props,
              data,
              setupState,
              ctx,
              inheritAttrs
            } = instance;
            const prev = setCurrentRenderingInstance(instance);
            let result;
            let fallthroughAttrs;
            try {
              if (vnode.shapeFlag & 4) {
                const proxyToUse = withProxy || proxy;
                const thisProxy = false ? new Proxy(proxyToUse, {
                  get(target, key, receiver) {
                    warn$1(
                      `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
                    );
                    return Reflect.get(target, key, receiver);
                  }
                }) : proxyToUse;
                result = normalizeVNode(
                  render2.call(
                    thisProxy,
                    proxyToUse,
                    renderCache,
                    false ? shallowReadonly(props) : props,
                    setupState,
                    data,
                    ctx
                  )
                );
                fallthroughAttrs = attrs;
              } else {
                const render22 = Component;
                if (false) ;
                result = normalizeVNode(
                  render22.length > 1 ? render22(
                    false ? shallowReadonly(props) : props,
                    false ? {
                      get attrs() {
                        markAttrsAccessed();
                        return shallowReadonly(attrs);
                      },
                      slots,
                      emit: emit2
                    } : { attrs, slots, emit: emit2 }
                  ) : render22(
                    false ? shallowReadonly(props) : props,
                    null
                  )
                );
                fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
              }
            } catch (err) {
              blockStack.length = 0;
              handleError(err, instance, 1);
              result = createVNode(Comment);
            }
            let root2 = result;
            if (fallthroughAttrs && inheritAttrs !== false) {
              const keys2 = Object.keys(fallthroughAttrs);
              const { shapeFlag } = root2;
              if (keys2.length) {
                if (shapeFlag & (1 | 6)) {
                  if (propsOptions && keys2.some(isModelListener)) {
                    fallthroughAttrs = filterModelListeners(
                      fallthroughAttrs,
                      propsOptions
                    );
                  }
                  root2 = cloneVNode(root2, fallthroughAttrs, false, true);
                }
              }
            }
            if (vnode.dirs) {
              root2 = cloneVNode(root2, null, false, true);
              root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
            }
            if (vnode.transition) {
              setTransitionHooks(root2, vnode.transition);
            }
            {
              result = root2;
            }
            setCurrentRenderingInstance(prev);
            return result;
          }
          const getFunctionalFallthrough = (attrs) => {
            let res;
            for (const key in attrs) {
              if (key === "class" || key === "style" || isOn(key)) {
                (res || (res = {}))[key] = attrs[key];
              }
            }
            return res;
          };
          const filterModelListeners = (attrs, props) => {
            const res = {};
            for (const key in attrs) {
              if (!isModelListener(key) || !(key.slice(9) in props)) {
                res[key] = attrs[key];
              }
            }
            return res;
          };
          function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
            const { props: prevProps, children: prevChildren, component } = prevVNode;
            const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
            const emits = component.emitsOptions;
            if (nextVNode.dirs || nextVNode.transition) {
              return true;
            }
            if (optimized && patchFlag >= 0) {
              if (patchFlag & 1024) {
                return true;
              }
              if (patchFlag & 16) {
                if (!prevProps) {
                  return !!nextProps;
                }
                return hasPropsChanged(prevProps, nextProps, emits);
              } else if (patchFlag & 8) {
                const dynamicProps = nextVNode.dynamicProps;
                for (let i = 0; i < dynamicProps.length; i++) {
                  const key = dynamicProps[i];
                  if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
                    return true;
                  }
                }
              }
            } else {
              if (prevChildren || nextChildren) {
                if (!nextChildren || !nextChildren.$stable) {
                  return true;
                }
              }
              if (prevProps === nextProps) {
                return false;
              }
              if (!prevProps) {
                return !!nextProps;
              }
              if (!nextProps) {
                return true;
              }
              return hasPropsChanged(prevProps, nextProps, emits);
            }
            return false;
          }
          function hasPropsChanged(prevProps, nextProps, emitsOptions) {
            const nextKeys = Object.keys(nextProps);
            if (nextKeys.length !== Object.keys(prevProps).length) {
              return true;
            }
            for (let i = 0; i < nextKeys.length; i++) {
              const key = nextKeys[i];
              if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
                return true;
              }
            }
            return false;
          }
          function updateHOCHostEl({ vnode, parent: parent2 }, el) {
            while (parent2) {
              const root2 = parent2.subTree;
              if (root2.suspense && root2.suspense.activeBranch === vnode) {
                root2.el = vnode.el;
              }
              if (root2 === vnode) {
                (vnode = parent2.vnode).el = el;
                parent2 = parent2.parent;
              } else {
                break;
              }
            }
          }
          const isSuspense = (type) => type.__isSuspense;
          function queueEffectWithSuspense(fn2, suspense) {
            if (suspense && suspense.pendingBranch) {
              if (isArray$1(fn2)) {
                suspense.effects.push(...fn2);
              } else {
                suspense.effects.push(fn2);
              }
            } else {
              queuePostFlushCb(fn2);
            }
          }
          const Fragment = Symbol.for("v-fgt");
          const Text = Symbol.for("v-txt");
          const Comment = Symbol.for("v-cmt");
          const Static = Symbol.for("v-stc");
          const blockStack = [];
          let currentBlock = null;
          function openBlock(disableTracking = false) {
            blockStack.push(currentBlock = disableTracking ? null : []);
          }
          function closeBlock() {
            blockStack.pop();
            currentBlock = blockStack[blockStack.length - 1] || null;
          }
          let isBlockTreeEnabled = 1;
          function setBlockTracking(value, inVOnce = false) {
            isBlockTreeEnabled += value;
            if (value < 0 && currentBlock && inVOnce) {
              currentBlock.hasOnce = true;
            }
          }
          function setupBlock(vnode) {
            vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
            closeBlock();
            if (isBlockTreeEnabled > 0 && currentBlock) {
              currentBlock.push(vnode);
            }
            return vnode;
          }
          function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
            return setupBlock(
              createBaseVNode(
                type,
                props,
                children,
                patchFlag,
                dynamicProps,
                shapeFlag,
                true
              )
            );
          }
          function createBlock(type, props, children, patchFlag, dynamicProps) {
            return setupBlock(
              createVNode(
                type,
                props,
                children,
                patchFlag,
                dynamicProps,
                true
              )
            );
          }
          function isVNode(value) {
            return value ? value.__v_isVNode === true : false;
          }
          function isSameVNodeType(n1, n2) {
            return n1.type === n2.type && n1.key === n2.key;
          }
          const normalizeKey = ({ key }) => key != null ? key : null;
          const normalizeRef = ({
            ref: ref3,
            ref_key,
            ref_for
          }) => {
            if (typeof ref3 === "number") {
              ref3 = "" + ref3;
            }
            return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
          };
          function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
            const vnode = {
              __v_isVNode: true,
              __v_skip: true,
              type,
              props,
              key: props && normalizeKey(props),
              ref: props && normalizeRef(props),
              scopeId: currentScopeId,
              slotScopeIds: null,
              children,
              component: null,
              suspense: null,
              ssContent: null,
              ssFallback: null,
              dirs: null,
              transition: null,
              el: null,
              anchor: null,
              target: null,
              targetStart: null,
              targetAnchor: null,
              staticCount: 0,
              shapeFlag,
              patchFlag,
              dynamicProps,
              dynamicChildren: null,
              appContext: null,
              ctx: currentRenderingInstance
            };
            if (needFullChildrenNormalization) {
              normalizeChildren(vnode, children);
              if (shapeFlag & 128) {
                type.normalize(vnode);
              }
            } else if (children) {
              vnode.shapeFlag |= isString$1(children) ? 8 : 16;
            }
            if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
            !isBlockNode && // has current parent block
            currentBlock && // presence of a patch flag indicates this node needs patching on updates.
            // component nodes also should always be patched, because even if the
            // component doesn't need to update, it needs to persist the instance on to
            // the next vnode so that it can be properly unmounted later.
            (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
            // vnode should not be considered dynamic due to handler caching.
            vnode.patchFlag !== 32) {
              currentBlock.push(vnode);
            }
            return vnode;
          }
          const createVNode = _createVNode;
          function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
            if (!type || type === NULL_DYNAMIC_COMPONENT) {
              type = Comment;
            }
            if (isVNode(type)) {
              const cloned = cloneVNode(
                type,
                props,
                true
                /* mergeRef: true */
              );
              if (children) {
                normalizeChildren(cloned, children);
              }
              if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
                if (cloned.shapeFlag & 6) {
                  currentBlock[currentBlock.indexOf(type)] = cloned;
                } else {
                  currentBlock.push(cloned);
                }
              }
              cloned.patchFlag = -2;
              return cloned;
            }
            if (isClassComponent(type)) {
              type = type.__vccOpts;
            }
            if (props) {
              props = guardReactiveProps(props);
              let { class: klass, style } = props;
              if (klass && !isString$1(klass)) {
                props.class = normalizeClass(klass);
              }
              if (isObject$1(style)) {
                if (isProxy(style) && !isArray$1(style)) {
                  style = extend({}, style);
                }
                props.style = normalizeStyle(style);
              }
            }
            const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
            return createBaseVNode(
              type,
              props,
              children,
              patchFlag,
              dynamicProps,
              shapeFlag,
              isBlockNode,
              true
            );
          }
          function guardReactiveProps(props) {
            if (!props) return null;
            return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
          }
          function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
            const { props, ref: ref3, patchFlag, children, transition } = vnode;
            const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
            const cloned = {
              __v_isVNode: true,
              __v_skip: true,
              type: vnode.type,
              props: mergedProps,
              key: mergedProps && normalizeKey(mergedProps),
              ref: extraProps && extraProps.ref ? (
                // #2078 in the case of <component :is="vnode" ref="extra"/>
                // if the vnode itself already has a ref, cloneVNode will need to merge
                // the refs so the single vnode can be set on multiple refs
                mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
              ) : ref3,
              scopeId: vnode.scopeId,
              slotScopeIds: vnode.slotScopeIds,
              children,
              target: vnode.target,
              targetStart: vnode.targetStart,
              targetAnchor: vnode.targetAnchor,
              staticCount: vnode.staticCount,
              shapeFlag: vnode.shapeFlag,
              // if the vnode is cloned with extra props, we can no longer assume its
              // existing patch flag to be reliable and need to add the FULL_PROPS flag.
              // note: preserve flag for fragments since they use the flag for children
              // fast paths only.
              patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
              dynamicProps: vnode.dynamicProps,
              dynamicChildren: vnode.dynamicChildren,
              appContext: vnode.appContext,
              dirs: vnode.dirs,
              transition,
              // These should technically only be non-null on mounted VNodes. However,
              // they *should* be copied for kept-alive vnodes. So we just always copy
              // them since them being non-null during a mount doesn't affect the logic as
              // they will simply be overwritten.
              component: vnode.component,
              suspense: vnode.suspense,
              ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
              ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
              el: vnode.el,
              anchor: vnode.anchor,
              ctx: vnode.ctx,
              ce: vnode.ce
            };
            if (transition && cloneTransition) {
              setTransitionHooks(
                cloned,
                transition.clone(cloned)
              );
            }
            return cloned;
          }
          function createTextVNode(text = " ", flag = 0) {
            return createVNode(Text, null, text, flag);
          }
          function createCommentVNode(text = "", asBlock = false) {
            return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
          }
          function normalizeVNode(child) {
            if (child == null || typeof child === "boolean") {
              return createVNode(Comment);
            } else if (isArray$1(child)) {
              return createVNode(
                Fragment,
                null,
                // #3666, avoid reference pollution when reusing vnode
                child.slice()
              );
            } else if (isVNode(child)) {
              return cloneIfMounted(child);
            } else {
              return createVNode(Text, null, String(child));
            }
          }
          function cloneIfMounted(child) {
            return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
          }
          function normalizeChildren(vnode, children) {
            let type = 0;
            const { shapeFlag } = vnode;
            if (children == null) {
              children = null;
            } else if (isArray$1(children)) {
              type = 16;
            } else if (typeof children === "object") {
              if (shapeFlag & (1 | 64)) {
                const slot = children.default;
                if (slot) {
                  slot._c && (slot._d = false);
                  normalizeChildren(vnode, slot());
                  slot._c && (slot._d = true);
                }
                return;
              } else {
                type = 32;
                const slotFlag = children._;
                if (!slotFlag && !isInternalObject(children)) {
                  children._ctx = currentRenderingInstance;
                } else if (slotFlag === 3 && currentRenderingInstance) {
                  if (currentRenderingInstance.slots._ === 1) {
                    children._ = 1;
                  } else {
                    children._ = 2;
                    vnode.patchFlag |= 1024;
                  }
                }
              }
            } else if (isFunction$1(children)) {
              children = { default: children, _ctx: currentRenderingInstance };
              type = 32;
            } else {
              children = String(children);
              if (shapeFlag & 64) {
                type = 16;
                children = [createTextVNode(children)];
              } else {
                type = 8;
              }
            }
            vnode.children = children;
            vnode.shapeFlag |= type;
          }
          function mergeProps(...args) {
            const ret = {};
            for (let i = 0; i < args.length; i++) {
              const toMerge = args[i];
              for (const key in toMerge) {
                if (key === "class") {
                  if (ret.class !== toMerge.class) {
                    ret.class = normalizeClass([ret.class, toMerge.class]);
                  }
                } else if (key === "style") {
                  ret.style = normalizeStyle([ret.style, toMerge.style]);
                } else if (isOn(key)) {
                  const existing = ret[key];
                  const incoming = toMerge[key];
                  if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
                    ret[key] = existing ? [].concat(existing, incoming) : incoming;
                  }
                } else if (key !== "") {
                  ret[key] = toMerge[key];
                }
              }
            }
            return ret;
          }
          function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
            callWithAsyncErrorHandling(hook, instance, 7, [
              vnode,
              prevVNode
            ]);
          }
          const emptyAppContext = createAppContext();
          let uid = 0;
          function createComponentInstance(vnode, parent2, suspense) {
            const type = vnode.type;
            const appContext = (parent2 ? parent2.appContext : vnode.appContext) || emptyAppContext;
            const instance = {
              uid: uid++,
              vnode,
              type,
              parent: parent2,
              appContext,
              root: null,
              // to be immediately set
              next: null,
              subTree: null,
              // will be set synchronously right after creation
              effect: null,
              update: null,
              // will be set synchronously right after creation
              job: null,
              scope: new EffectScope(
                true
                /* detached */
              ),
              render: null,
              proxy: null,
              exposed: null,
              exposeProxy: null,
              withProxy: null,
              provides: parent2 ? parent2.provides : Object.create(appContext.provides),
              ids: parent2 ? parent2.ids : ["", 0, 0],
              accessCache: null,
              renderCache: [],
              // local resolved assets
              components: null,
              directives: null,
              // resolved props and emits options
              propsOptions: normalizePropsOptions(type, appContext),
              emitsOptions: normalizeEmitsOptions(type, appContext),
              // emit
              emit: null,
              // to be set immediately
              emitted: null,
              // props default value
              propsDefaults: EMPTY_OBJ,
              // inheritAttrs
              inheritAttrs: type.inheritAttrs,
              // state
              ctx: EMPTY_OBJ,
              data: EMPTY_OBJ,
              props: EMPTY_OBJ,
              attrs: EMPTY_OBJ,
              slots: EMPTY_OBJ,
              refs: EMPTY_OBJ,
              setupState: EMPTY_OBJ,
              setupContext: null,
              // suspense related
              suspense,
              suspenseId: suspense ? suspense.pendingId : 0,
              asyncDep: null,
              asyncResolved: false,
              // lifecycle hooks
              // not using enums here because it results in computed properties
              isMounted: false,
              isUnmounted: false,
              isDeactivated: false,
              bc: null,
              c: null,
              bm: null,
              m: null,
              bu: null,
              u: null,
              um: null,
              bum: null,
              da: null,
              a: null,
              rtg: null,
              rtc: null,
              ec: null,
              sp: null
            };
            {
              instance.ctx = { _: instance };
            }
            instance.root = parent2 ? parent2.root : instance;
            instance.emit = emit.bind(null, instance);
            if (vnode.ce) {
              vnode.ce(instance);
            }
            return instance;
          }
          let currentInstance = null;
          const getCurrentInstance = () => currentInstance || currentRenderingInstance;
          let internalSetCurrentInstance;
          let setInSSRSetupState;
          {
            const g = getGlobalThis();
            const registerGlobalSetter = (key, setter) => {
              let setters;
              if (!(setters = g[key])) setters = g[key] = [];
              setters.push(setter);
              return (v) => {
                if (setters.length > 1) setters.forEach((set2) => set2(v));
                else setters[0](v);
              };
            };
            internalSetCurrentInstance = registerGlobalSetter(
              `__VUE_INSTANCE_SETTERS__`,
              (v) => currentInstance = v
            );
            setInSSRSetupState = registerGlobalSetter(
              `__VUE_SSR_SETTERS__`,
              (v) => isInSSRComponentSetup = v
            );
          }
          const setCurrentInstance = (instance) => {
            const prev = currentInstance;
            internalSetCurrentInstance(instance);
            instance.scope.on();
            return () => {
              instance.scope.off();
              internalSetCurrentInstance(prev);
            };
          };
          const unsetCurrentInstance = () => {
            currentInstance && currentInstance.scope.off();
            internalSetCurrentInstance(null);
          };
          function isStatefulComponent(instance) {
            return instance.vnode.shapeFlag & 4;
          }
          let isInSSRComponentSetup = false;
          function setupComponent(instance, isSSR = false, optimized = false) {
            isSSR && setInSSRSetupState(isSSR);
            const { props, children } = instance.vnode;
            const isStateful = isStatefulComponent(instance);
            initProps(instance, props, isStateful, isSSR);
            initSlots(instance, children, optimized || isSSR);
            const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
            isSSR && setInSSRSetupState(false);
            return setupResult;
          }
          function setupStatefulComponent(instance, isSSR) {
            const Component = instance.type;
            instance.accessCache = /* @__PURE__ */ Object.create(null);
            instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
            const { setup } = Component;
            if (setup) {
              pauseTracking();
              const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
              const reset = setCurrentInstance(instance);
              const setupResult = callWithErrorHandling(
                setup,
                instance,
                0,
                [
                  instance.props,
                  setupContext
                ]
              );
              const isAsyncSetup = isPromise(setupResult);
              resetTracking();
              reset();
              if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
                markAsyncBoundary(instance);
              }
              if (isAsyncSetup) {
                setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
                if (isSSR) {
                  return setupResult.then((resolvedResult) => {
                    handleSetupResult(instance, resolvedResult);
                  }).catch((e) => {
                    handleError(e, instance, 0);
                  });
                } else {
                  instance.asyncDep = setupResult;
                }
              } else {
                handleSetupResult(instance, setupResult);
              }
            } else {
              finishComponentSetup(instance);
            }
          }
          function handleSetupResult(instance, setupResult, isSSR) {
            if (isFunction$1(setupResult)) {
              if (instance.type.__ssrInlineRender) {
                instance.ssrRender = setupResult;
              } else {
                instance.render = setupResult;
              }
            } else if (isObject$1(setupResult)) {
              instance.setupState = proxyRefs(setupResult);
            } else ;
            finishComponentSetup(instance);
          }
          function finishComponentSetup(instance, isSSR, skipOptions) {
            const Component = instance.type;
            if (!instance.render) {
              instance.render = Component.render || NOOP;
            }
            {
              const reset = setCurrentInstance(instance);
              pauseTracking();
              try {
                applyOptions(instance);
              } finally {
                resetTracking();
                reset();
              }
            }
          }
          const attrsProxyHandlers = {
            get(target, key) {
              track(target, "get", "");
              return target[key];
            }
          };
          function createSetupContext(instance) {
            const expose = (exposed) => {
              instance.exposed = exposed || {};
            };
            {
              return {
                attrs: new Proxy(instance.attrs, attrsProxyHandlers),
                slots: instance.slots,
                emit: instance.emit,
                expose
              };
            }
          }
          function getComponentPublicInstance(instance) {
            if (instance.exposed) {
              return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
                get(target, key) {
                  if (key in target) {
                    return target[key];
                  } else if (key in publicPropertiesMap) {
                    return publicPropertiesMap[key](instance);
                  }
                },
                has(target, key) {
                  return key in target || key in publicPropertiesMap;
                }
              }));
            } else {
              return instance.proxy;
            }
          }
          const classifyRE = /(?:^|[-_])(\w)/g;
          const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
          function getComponentName(Component, includeInferred = true) {
            return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
          }
          function formatComponentName(instance, Component, isRoot = false) {
            let name = getComponentName(Component);
            if (!name && Component.__file) {
              const match = Component.__file.match(/([^/\\]+)\.\w+$/);
              if (match) {
                name = match[1];
              }
            }
            if (!name && instance && instance.parent) {
              const inferFromRegistry = (registry) => {
                for (const key in registry) {
                  if (registry[key] === Component) {
                    return key;
                  }
                }
              };
              name = inferFromRegistry(
                instance.components || instance.parent.type.components
              ) || inferFromRegistry(instance.appContext.components);
            }
            return name ? classify(name) : isRoot ? `App` : `Anonymous`;
          }
          function isClassComponent(value) {
            return isFunction$1(value) && "__vccOpts" in value;
          }
          const computed = (getterOrOptions, debugOptions) => {
            const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
            return c;
          };
          function h(type, propsOrChildren, children) {
            const l = arguments.length;
            if (l === 2) {
              if (isObject$1(propsOrChildren) && !isArray$1(propsOrChildren)) {
                if (isVNode(propsOrChildren)) {
                  return createVNode(type, null, [propsOrChildren]);
                }
                return createVNode(type, propsOrChildren);
              } else {
                return createVNode(type, null, propsOrChildren);
              }
            } else {
              if (l > 3) {
                children = Array.prototype.slice.call(arguments, 2);
              } else if (l === 3 && isVNode(children)) {
                children = [children];
              }
              return createVNode(type, propsOrChildren, children);
            }
          }
          const version = "3.5.17";
          const warn = NOOP;
          /**
          * @vue/runtime-dom v3.5.17
          * (c) 2018-present Yuxi (Evan) You and Vue contributors
          * @license MIT
          **/
          let policy = void 0;
          const tt$1 = typeof window !== "undefined" && window.trustedTypes;
          if (tt$1) {
            try {
              policy = /* @__PURE__ */ tt$1.createPolicy("vue", {
                createHTML: (val) => val
              });
            } catch (e) {
            }
          }
          const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
          const svgNS = "http://www.w3.org/2000/svg";
          const mathmlNS = "http://www.w3.org/1998/Math/MathML";
          const doc = typeof document !== "undefined" ? document : null;
          const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
          const nodeOps = {
            insert: (child, parent2, anchor) => {
              parent2.insertBefore(child, anchor || null);
            },
            remove: (child) => {
              const parent2 = child.parentNode;
              if (parent2) {
                parent2.removeChild(child);
              }
            },
            createElement: (tag, namespace, is, props) => {
              const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
              if (tag === "select" && props && props.multiple != null) {
                el.setAttribute("multiple", props.multiple);
              }
              return el;
            },
            createText: (text) => doc.createTextNode(text),
            createComment: (text) => doc.createComment(text),
            setText: (node, text) => {
              node.nodeValue = text;
            },
            setElementText: (el, text) => {
              el.textContent = text;
            },
            parentNode: (node) => node.parentNode,
            nextSibling: (node) => node.nextSibling,
            querySelector: (selector) => doc.querySelector(selector),
            setScopeId(el, id) {
              el.setAttribute(id, "");
            },
            // __UNSAFE__
            // Reason: innerHTML.
            // Static content here can only come from compiled templates.
            // As long as the user only uses trusted templates, this is safe.
            insertStaticContent(content, parent2, anchor, namespace, start, end) {
              const before = anchor ? anchor.previousSibling : parent2.lastChild;
              if (start && (start === end || start.nextSibling)) {
                while (true) {
                  parent2.insertBefore(start.cloneNode(true), anchor);
                  if (start === end || !(start = start.nextSibling)) break;
                }
              } else {
                templateContainer.innerHTML = unsafeToTrustedHTML(
                  namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
                );
                const template = templateContainer.content;
                if (namespace === "svg" || namespace === "mathml") {
                  const wrapper = template.firstChild;
                  while (wrapper.firstChild) {
                    template.appendChild(wrapper.firstChild);
                  }
                  template.removeChild(wrapper);
                }
                parent2.insertBefore(template, anchor);
              }
              return [
                // first
                before ? before.nextSibling : parent2.firstChild,
                // last
                anchor ? anchor.previousSibling : parent2.lastChild
              ];
            }
          };
          const TRANSITION = "transition";
          const ANIMATION = "animation";
          const vtcKey = Symbol("_vtc");
          const DOMTransitionPropsValidators = {
            name: String,
            type: String,
            css: {
              type: Boolean,
              default: true
            },
            duration: [String, Number, Object],
            enterFromClass: String,
            enterActiveClass: String,
            enterToClass: String,
            appearFromClass: String,
            appearActiveClass: String,
            appearToClass: String,
            leaveFromClass: String,
            leaveActiveClass: String,
            leaveToClass: String
          };
          const TransitionPropsValidators = /* @__PURE__ */ extend(
            {},
            BaseTransitionPropsValidators,
            DOMTransitionPropsValidators
          );
          const decorate$1 = (t) => {
            t.displayName = "Transition";
            t.props = TransitionPropsValidators;
            return t;
          };
          const Transition = /* @__PURE__ */ decorate$1(
            (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
          );
          const callHook = (hook, args = []) => {
            if (isArray$1(hook)) {
              hook.forEach((h2) => h2(...args));
            } else if (hook) {
              hook(...args);
            }
          };
          const hasExplicitCallback = (hook) => {
            return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
          };
          function resolveTransitionProps(rawProps) {
            const baseProps = {};
            for (const key in rawProps) {
              if (!(key in DOMTransitionPropsValidators)) {
                baseProps[key] = rawProps[key];
              }
            }
            if (rawProps.css === false) {
              return baseProps;
            }
            const {
              name = "v",
              type,
              duration,
              enterFromClass = `${name}-enter-from`,
              enterActiveClass = `${name}-enter-active`,
              enterToClass = `${name}-enter-to`,
              appearFromClass = enterFromClass,
              appearActiveClass = enterActiveClass,
              appearToClass = enterToClass,
              leaveFromClass = `${name}-leave-from`,
              leaveActiveClass = `${name}-leave-active`,
              leaveToClass = `${name}-leave-to`
            } = rawProps;
            const durations = normalizeDuration(duration);
            const enterDuration = durations && durations[0];
            const leaveDuration = durations && durations[1];
            const {
              onBeforeEnter,
              onEnter,
              onEnterCancelled,
              onLeave,
              onLeaveCancelled,
              onBeforeAppear = onBeforeEnter,
              onAppear = onEnter,
              onAppearCancelled = onEnterCancelled
            } = baseProps;
            const finishEnter = (el, isAppear, done, isCancelled) => {
              el._enterCancelled = isCancelled;
              removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
              removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
              done && done();
            };
            const finishLeave = (el, done) => {
              el._isLeaving = false;
              removeTransitionClass(el, leaveFromClass);
              removeTransitionClass(el, leaveToClass);
              removeTransitionClass(el, leaveActiveClass);
              done && done();
            };
            const makeEnterHook = (isAppear) => {
              return (el, done) => {
                const hook = isAppear ? onAppear : onEnter;
                const resolve2 = () => finishEnter(el, isAppear, done);
                callHook(hook, [el, resolve2]);
                nextFrame(() => {
                  removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                  addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                  if (!hasExplicitCallback(hook)) {
                    whenTransitionEnds(el, type, enterDuration, resolve2);
                  }
                });
              };
            };
            return extend(baseProps, {
              onBeforeEnter(el) {
                callHook(onBeforeEnter, [el]);
                addTransitionClass(el, enterFromClass);
                addTransitionClass(el, enterActiveClass);
              },
              onBeforeAppear(el) {
                callHook(onBeforeAppear, [el]);
                addTransitionClass(el, appearFromClass);
                addTransitionClass(el, appearActiveClass);
              },
              onEnter: makeEnterHook(false),
              onAppear: makeEnterHook(true),
              onLeave(el, done) {
                el._isLeaving = true;
                const resolve2 = () => finishLeave(el, done);
                addTransitionClass(el, leaveFromClass);
                if (!el._enterCancelled) {
                  forceReflow();
                  addTransitionClass(el, leaveActiveClass);
                } else {
                  addTransitionClass(el, leaveActiveClass);
                  forceReflow();
                }
                nextFrame(() => {
                  if (!el._isLeaving) {
                    return;
                  }
                  removeTransitionClass(el, leaveFromClass);
                  addTransitionClass(el, leaveToClass);
                  if (!hasExplicitCallback(onLeave)) {
                    whenTransitionEnds(el, type, leaveDuration, resolve2);
                  }
                });
                callHook(onLeave, [el, resolve2]);
              },
              onEnterCancelled(el) {
                finishEnter(el, false, void 0, true);
                callHook(onEnterCancelled, [el]);
              },
              onAppearCancelled(el) {
                finishEnter(el, true, void 0, true);
                callHook(onAppearCancelled, [el]);
              },
              onLeaveCancelled(el) {
                finishLeave(el);
                callHook(onLeaveCancelled, [el]);
              }
            });
          }
          function normalizeDuration(duration) {
            if (duration == null) {
              return null;
            } else if (isObject$1(duration)) {
              return [NumberOf(duration.enter), NumberOf(duration.leave)];
            } else {
              const n = NumberOf(duration);
              return [n, n];
            }
          }
          function NumberOf(val) {
            const res = toNumber$1(val);
            return res;
          }
          function addTransitionClass(el, cls) {
            cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
            (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
          }
          function removeTransitionClass(el, cls) {
            cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
            const _vtc = el[vtcKey];
            if (_vtc) {
              _vtc.delete(cls);
              if (!_vtc.size) {
                el[vtcKey] = void 0;
              }
            }
          }
          function nextFrame(cb) {
            requestAnimationFrame(() => {
              requestAnimationFrame(cb);
            });
          }
          let endId = 0;
          function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
            const id = el._endId = ++endId;
            const resolveIfNotStale = () => {
              if (id === el._endId) {
                resolve2();
              }
            };
            if (explicitTimeout != null) {
              return setTimeout(resolveIfNotStale, explicitTimeout);
            }
            const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
            if (!type) {
              return resolve2();
            }
            const endEvent = type + "end";
            let ended = 0;
            const end = () => {
              el.removeEventListener(endEvent, onEnd);
              resolveIfNotStale();
            };
            const onEnd = (e) => {
              if (e.target === el && ++ended >= propCount) {
                end();
              }
            };
            setTimeout(() => {
              if (ended < propCount) {
                end();
              }
            }, timeout + 1);
            el.addEventListener(endEvent, onEnd);
          }
          function getTransitionInfo(el, expectedType) {
            const styles = window.getComputedStyle(el);
            const getStyleProperties = (key) => (styles[key] || "").split(", ");
            const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
            const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
            const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
            const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
            const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
            const animationTimeout = getTimeout(animationDelays, animationDurations);
            let type = null;
            let timeout = 0;
            let propCount = 0;
            if (expectedType === TRANSITION) {
              if (transitionTimeout > 0) {
                type = TRANSITION;
                timeout = transitionTimeout;
                propCount = transitionDurations.length;
              }
            } else if (expectedType === ANIMATION) {
              if (animationTimeout > 0) {
                type = ANIMATION;
                timeout = animationTimeout;
                propCount = animationDurations.length;
              }
            } else {
              timeout = Math.max(transitionTimeout, animationTimeout);
              type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
              propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
            }
            const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
              getStyleProperties(`${TRANSITION}Property`).toString()
            );
            return {
              type,
              timeout,
              propCount,
              hasTransform
            };
          }
          function getTimeout(delays, durations) {
            while (delays.length < durations.length) {
              delays = delays.concat(delays);
            }
            return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
          }
          function toMs(s) {
            if (s === "auto") return 0;
            return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
          }
          function forceReflow() {
            return document.body.offsetHeight;
          }
          function patchClass(el, value, isSVG) {
            const transitionClasses = el[vtcKey];
            if (transitionClasses) {
              value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
            }
            if (value == null) {
              el.removeAttribute("class");
            } else if (isSVG) {
              el.setAttribute("class", value);
            } else {
              el.className = value;
            }
          }
          const vShowOriginalDisplay = Symbol("_vod");
          const vShowHidden = Symbol("_vsh");
          const vShow = {
            beforeMount(el, { value }, { transition }) {
              el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
              if (transition && value) {
                transition.beforeEnter(el);
              } else {
                setDisplay(el, value);
              }
            },
            mounted(el, { value }, { transition }) {
              if (transition && value) {
                transition.enter(el);
              }
            },
            updated(el, { value, oldValue }, { transition }) {
              if (!value === !oldValue) return;
              if (transition) {
                if (value) {
                  transition.beforeEnter(el);
                  setDisplay(el, true);
                  transition.enter(el);
                } else {
                  transition.leave(el, () => {
                    setDisplay(el, false);
                  });
                }
              } else {
                setDisplay(el, value);
              }
            },
            beforeUnmount(el, { value }) {
              setDisplay(el, value);
            }
          };
          function setDisplay(el, value) {
            el.style.display = value ? el[vShowOriginalDisplay] : "none";
            el[vShowHidden] = !value;
          }
          const CSS_VAR_TEXT = Symbol("");
          const displayRE = /(^|;)\s*display\s*:/;
          function patchStyle(el, prev, next) {
            const style = el.style;
            const isCssString = isString$1(next);
            let hasControlledDisplay = false;
            if (next && !isCssString) {
              if (prev) {
                if (!isString$1(prev)) {
                  for (const key in prev) {
                    if (next[key] == null) {
                      setStyle(style, key, "");
                    }
                  }
                } else {
                  for (const prevStyle of prev.split(";")) {
                    const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
                    if (next[key] == null) {
                      setStyle(style, key, "");
                    }
                  }
                }
              }
              for (const key in next) {
                if (key === "display") {
                  hasControlledDisplay = true;
                }
                setStyle(style, key, next[key]);
              }
            } else {
              if (isCssString) {
                if (prev !== next) {
                  const cssVarText = style[CSS_VAR_TEXT];
                  if (cssVarText) {
                    next += ";" + cssVarText;
                  }
                  style.cssText = next;
                  hasControlledDisplay = displayRE.test(next);
                }
              } else if (prev) {
                el.removeAttribute("style");
              }
            }
            if (vShowOriginalDisplay in el) {
              el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
              if (el[vShowHidden]) {
                style.display = "none";
              }
            }
          }
          const importantRE = /\s*!important$/;
          function setStyle(style, name, val) {
            if (isArray$1(val)) {
              val.forEach((v) => setStyle(style, name, v));
            } else {
              if (val == null) val = "";
              if (name.startsWith("--")) {
                style.setProperty(name, val);
              } else {
                const prefixed = autoPrefix(style, name);
                if (importantRE.test(val)) {
                  style.setProperty(
                    hyphenate(prefixed),
                    val.replace(importantRE, ""),
                    "important"
                  );
                } else {
                  style[prefixed] = val;
                }
              }
            }
          }
          const prefixes = ["Webkit", "Moz", "ms"];
          const prefixCache = {};
          function autoPrefix(style, rawName) {
            const cached = prefixCache[rawName];
            if (cached) {
              return cached;
            }
            let name = camelize(rawName);
            if (name !== "filter" && name in style) {
              return prefixCache[rawName] = name;
            }
            name = capitalize$1(name);
            for (let i = 0; i < prefixes.length; i++) {
              const prefixed = prefixes[i] + name;
              if (prefixed in style) {
                return prefixCache[rawName] = prefixed;
              }
            }
            return rawName;
          }
          const xlinkNS = "http://www.w3.org/1999/xlink";
          function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
            if (isSVG && key.startsWith("xlink:")) {
              if (value == null) {
                el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
              } else {
                el.setAttributeNS(xlinkNS, key, value);
              }
            } else {
              if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
                el.removeAttribute(key);
              } else {
                el.setAttribute(
                  key,
                  isBoolean2 ? "" : isSymbol$1(value) ? String(value) : value
                );
              }
            }
          }
          function patchDOMProp(el, key, value, parentComponent, attrName) {
            if (key === "innerHTML" || key === "textContent") {
              if (value != null) {
                el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
              }
              return;
            }
            const tag = el.tagName;
            if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
            !tag.includes("-")) {
              const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
              const newValue = value == null ? (
                // #11647: value should be set as empty string for null and undefined,
                // but <input type="checkbox"> should be set as 'on'.
                el.type === "checkbox" ? "on" : ""
              ) : String(value);
              if (oldValue !== newValue || !("_value" in el)) {
                el.value = newValue;
              }
              if (value == null) {
                el.removeAttribute(key);
              }
              el._value = value;
              return;
            }
            let needRemove = false;
            if (value === "" || value == null) {
              const type = typeof el[key];
              if (type === "boolean") {
                value = includeBooleanAttr(value);
              } else if (value == null && type === "string") {
                value = "";
                needRemove = true;
              } else if (type === "number") {
                value = 0;
                needRemove = true;
              }
            }
            try {
              el[key] = value;
            } catch (e) {
            }
            needRemove && el.removeAttribute(attrName || key);
          }
          function addEventListener(el, event, handler, options) {
            el.addEventListener(event, handler, options);
          }
          function removeEventListener(el, event, handler, options) {
            el.removeEventListener(event, handler, options);
          }
          const veiKey = Symbol("_vei");
          function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
            const invokers = el[veiKey] || (el[veiKey] = {});
            const existingInvoker = invokers[rawName];
            if (nextValue && existingInvoker) {
              existingInvoker.value = nextValue;
            } else {
              const [name, options] = parseName(rawName);
              if (nextValue) {
                const invoker = invokers[rawName] = createInvoker(
                  nextValue,
                  instance
                );
                addEventListener(el, name, invoker, options);
              } else if (existingInvoker) {
                removeEventListener(el, name, existingInvoker, options);
                invokers[rawName] = void 0;
              }
            }
          }
          const optionsModifierRE = /(?:Once|Passive|Capture)$/;
          function parseName(name) {
            let options;
            if (optionsModifierRE.test(name)) {
              options = {};
              let m;
              while (m = name.match(optionsModifierRE)) {
                name = name.slice(0, name.length - m[0].length);
                options[m[0].toLowerCase()] = true;
              }
            }
            const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
            return [event, options];
          }
          let cachedNow = 0;
          const p = /* @__PURE__ */ Promise.resolve();
          const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
          function createInvoker(initialValue, instance) {
            const invoker = (e) => {
              if (!e._vts) {
                e._vts = Date.now();
              } else if (e._vts <= invoker.attached) {
                return;
              }
              callWithAsyncErrorHandling(
                patchStopImmediatePropagation(e, invoker.value),
                instance,
                5,
                [e]
              );
            };
            invoker.value = initialValue;
            invoker.attached = getNow();
            return invoker;
          }
          function patchStopImmediatePropagation(e, value) {
            if (isArray$1(value)) {
              const originalStop = e.stopImmediatePropagation;
              e.stopImmediatePropagation = () => {
                originalStop.call(e);
                e._stopped = true;
              };
              return value.map(
                (fn2) => (e2) => !e2._stopped && fn2 && fn2(e2)
              );
            } else {
              return value;
            }
          }
          const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
          key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
          const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
            const isSVG = namespace === "svg";
            if (key === "class") {
              patchClass(el, nextValue, isSVG);
            } else if (key === "style") {
              patchStyle(el, prevValue, nextValue);
            } else if (isOn(key)) {
              if (!isModelListener(key)) {
                patchEvent(el, key, prevValue, nextValue, parentComponent);
              }
            } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
              patchDOMProp(el, key, nextValue);
              if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
                patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
              }
            } else if (
              // #11081 force set props for possible async custom element
              el._isVueCE && (/[A-Z]/.test(key) || !isString$1(nextValue))
            ) {
              patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
            } else {
              if (key === "true-value") {
                el._trueValue = nextValue;
              } else if (key === "false-value") {
                el._falseValue = nextValue;
              }
              patchAttr(el, key, nextValue, isSVG);
            }
          };
          function shouldSetAsProp(el, key, value, isSVG) {
            if (isSVG) {
              if (key === "innerHTML" || key === "textContent") {
                return true;
              }
              if (key in el && isNativeOn(key) && isFunction$1(value)) {
                return true;
              }
              return false;
            }
            if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
              return false;
            }
            if (key === "form") {
              return false;
            }
            if (key === "list" && el.tagName === "INPUT") {
              return false;
            }
            if (key === "type" && el.tagName === "TEXTAREA") {
              return false;
            }
            if (key === "width" || key === "height") {
              const tag = el.tagName;
              if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
                return false;
              }
            }
            if (isNativeOn(key) && isString$1(value)) {
              return false;
            }
            return key in el;
          }
          const positionMap = /* @__PURE__ */ new WeakMap();
          const newPositionMap = /* @__PURE__ */ new WeakMap();
          const moveCbKey = Symbol("_moveCb");
          const enterCbKey = Symbol("_enterCb");
          const decorate = (t) => {
            delete t.props.mode;
            return t;
          };
          const TransitionGroupImpl = /* @__PURE__ */ decorate({
            name: "TransitionGroup",
            props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
              tag: String,
              moveClass: String
            }),
            setup(props, { slots }) {
              const instance = getCurrentInstance();
              const state = useTransitionState();
              let prevChildren;
              let children;
              onUpdated(() => {
                if (!prevChildren.length) {
                  return;
                }
                const moveClass = props.moveClass || `${props.name || "v"}-move`;
                if (!hasCSSTransform(
                  prevChildren[0].el,
                  instance.vnode.el,
                  moveClass
                )) {
                  prevChildren = [];
                  return;
                }
                prevChildren.forEach(callPendingCbs);
                prevChildren.forEach(recordPosition);
                const movedChildren = prevChildren.filter(applyTranslation);
                forceReflow();
                movedChildren.forEach((c) => {
                  const el = c.el;
                  const style = el.style;
                  addTransitionClass(el, moveClass);
                  style.transform = style.webkitTransform = style.transitionDuration = "";
                  const cb = el[moveCbKey] = (e) => {
                    if (e && e.target !== el) {
                      return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                      el.removeEventListener("transitionend", cb);
                      el[moveCbKey] = null;
                      removeTransitionClass(el, moveClass);
                    }
                  };
                  el.addEventListener("transitionend", cb);
                });
                prevChildren = [];
              });
              return () => {
                const rawProps = toRaw(props);
                const cssTransitionProps = resolveTransitionProps(rawProps);
                let tag = rawProps.tag || Fragment;
                prevChildren = [];
                if (children) {
                  for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    if (child.el && child.el instanceof Element) {
                      prevChildren.push(child);
                      setTransitionHooks(
                        child,
                        resolveTransitionHooks(
                          child,
                          cssTransitionProps,
                          state,
                          instance
                        )
                      );
                      positionMap.set(
                        child,
                        child.el.getBoundingClientRect()
                      );
                    }
                  }
                }
                children = slots.default ? getTransitionRawChildren(slots.default()) : [];
                for (let i = 0; i < children.length; i++) {
                  const child = children[i];
                  if (child.key != null) {
                    setTransitionHooks(
                      child,
                      resolveTransitionHooks(child, cssTransitionProps, state, instance)
                    );
                  }
                }
                return createVNode(tag, null, children);
              };
            }
          });
          const TransitionGroup = TransitionGroupImpl;
          function callPendingCbs(c) {
            const el = c.el;
            if (el[moveCbKey]) {
              el[moveCbKey]();
            }
            if (el[enterCbKey]) {
              el[enterCbKey]();
            }
          }
          function recordPosition(c) {
            newPositionMap.set(c, c.el.getBoundingClientRect());
          }
          function applyTranslation(c) {
            const oldPos = positionMap.get(c);
            const newPos = newPositionMap.get(c);
            const dx = oldPos.left - newPos.left;
            const dy = oldPos.top - newPos.top;
            if (dx || dy) {
              const s = c.el.style;
              s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
              s.transitionDuration = "0s";
              return c;
            }
          }
          function hasCSSTransform(el, root2, moveClass) {
            const clone2 = el.cloneNode();
            const _vtc = el[vtcKey];
            if (_vtc) {
              _vtc.forEach((cls) => {
                cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
              });
            }
            moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
            clone2.style.display = "none";
            const container = root2.nodeType === 1 ? root2 : root2.parentNode;
            container.appendChild(clone2);
            const { hasTransform } = getTransitionInfo(clone2);
            container.removeChild(clone2);
            return hasTransform;
          }
          const systemModifiers = ["ctrl", "shift", "alt", "meta"];
          const modifierGuards = {
            stop: (e) => e.stopPropagation(),
            prevent: (e) => e.preventDefault(),
            self: (e) => e.target !== e.currentTarget,
            ctrl: (e) => !e.ctrlKey,
            shift: (e) => !e.shiftKey,
            alt: (e) => !e.altKey,
            meta: (e) => !e.metaKey,
            left: (e) => "button" in e && e.button !== 0,
            middle: (e) => "button" in e && e.button !== 1,
            right: (e) => "button" in e && e.button !== 2,
            exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
          };
          const withModifiers = (fn2, modifiers) => {
            const cache = fn2._withMods || (fn2._withMods = {});
            const cacheKey = modifiers.join(".");
            return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
              for (let i = 0; i < modifiers.length; i++) {
                const guard = modifierGuards[modifiers[i]];
                if (guard && guard(event, modifiers)) return;
              }
              return fn2(event, ...args);
            });
          };
          const keyNames = {
            esc: "escape",
            space: " ",
            up: "arrow-up",
            left: "arrow-left",
            right: "arrow-right",
            down: "arrow-down",
            delete: "backspace"
          };
          const withKeys = (fn2, modifiers) => {
            const cache = fn2._withKeys || (fn2._withKeys = {});
            const cacheKey = modifiers.join(".");
            return cache[cacheKey] || (cache[cacheKey] = (event) => {
              if (!("key" in event)) {
                return;
              }
              const eventKey = hyphenate(event.key);
              if (modifiers.some(
                (k) => k === eventKey || keyNames[k] === eventKey
              )) {
                return fn2(event);
              }
            });
          };
          const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
          let renderer;
          function ensureRenderer() {
            return renderer || (renderer = createRenderer(rendererOptions));
          }
          const render = (...args) => {
            ensureRenderer().render(...args);
          };
          const createApp = (...args) => {
            const app = ensureRenderer().createApp(...args);
            const { mount } = app;
            app.mount = (containerOrSelector) => {
              const container = normalizeContainer(containerOrSelector);
              if (!container) return;
              const component = app._component;
              if (!isFunction$1(component) && !component.render && !component.template) {
                component.template = container.innerHTML;
              }
              if (container.nodeType === 1) {
                container.textContent = "";
              }
              const proxy = mount(container, false, resolveRootNamespace(container));
              if (container instanceof Element) {
                container.removeAttribute("v-cloak");
                container.setAttribute("data-v-app", "");
              }
              return proxy;
            };
            return app;
          };
          function resolveRootNamespace(container) {
            if (container instanceof SVGElement) {
              return "svg";
            }
            if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
              return "mathml";
            }
          }
          function normalizeContainer(container) {
            if (isString$1(container)) {
              const res = document.querySelector(container);
              return res;
            }
            return container;
          }
          const configProviderContextKey = Symbol();
          const defaultNamespace = "el";
          const statePrefix = "is-";
          const _bem = (namespace, block, blockSuffix, element, modifier) => {
            let cls = `${namespace}-${block}`;
            if (blockSuffix) {
              cls += `-${blockSuffix}`;
            }
            if (element) {
              cls += `__${element}`;
            }
            if (modifier) {
              cls += `--${modifier}`;
            }
            return cls;
          };
          const namespaceContextKey = Symbol("namespaceContextKey");
          const useGetDerivedNamespace = (namespaceOverrides) => {
            const derivedNamespace = namespaceOverrides || (getCurrentInstance() ? inject(namespaceContextKey, ref(defaultNamespace)) : ref(defaultNamespace));
            const namespace = computed(() => {
              return unref(derivedNamespace) || defaultNamespace;
            });
            return namespace;
          };
          const useNamespace = (block, namespaceOverrides) => {
            const namespace = useGetDerivedNamespace(namespaceOverrides);
            const b = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
            const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
            const m = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
            const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
            const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
            const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
            const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
            const is = (name, ...args) => {
              const state = args.length >= 1 ? args[0] : true;
              return name && state ? `${statePrefix}${name}` : "";
            };
            const cssVar = (object) => {
              const styles = {};
              for (const key in object) {
                if (object[key]) {
                  styles[`--${namespace.value}-${key}`] = object[key];
                }
              }
              return styles;
            };
            const cssVarBlock = (object) => {
              const styles = {};
              for (const key in object) {
                if (object[key]) {
                  styles[`--${namespace.value}-${block}-${key}`] = object[key];
                }
              }
              return styles;
            };
            const cssVarName = (name) => `--${namespace.value}-${name}`;
            const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
            return {
              namespace,
              b,
              e,
              m,
              be: be2,
              em,
              bm,
              bem,
              is,
              cssVar,
              cssVarName,
              cssVarBlock,
              cssVarBlockName
            };
          };
          var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
          var freeSelf = typeof self == "object" && self && self.Object === Object && self;
          var root = freeGlobal || freeSelf || Function("return this")();
          var Symbol$1 = root.Symbol;
          var objectProto$d = Object.prototype;
          var hasOwnProperty$a = objectProto$d.hasOwnProperty;
          var nativeObjectToString$1 = objectProto$d.toString;
          var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
          function getRawTag(value) {
            var isOwn = hasOwnProperty$a.call(value, symToStringTag$1), tag = value[symToStringTag$1];
            try {
              value[symToStringTag$1] = void 0;
              var unmasked = true;
            } catch (e) {
            }
            var result = nativeObjectToString$1.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag$1] = tag;
              } else {
                delete value[symToStringTag$1];
              }
            }
            return result;
          }
          var objectProto$c = Object.prototype;
          var nativeObjectToString = objectProto$c.toString;
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
          var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
          function baseGetTag(value) {
            if (value == null) {
              return value === void 0 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var symbolTag$2 = "[object Symbol]";
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$2;
          }
          function arrayMap(array, iteratee) {
            var index = -1, length = array == null ? 0 : array.length, result = Array(length);
            while (++index < length) {
              result[index] = iteratee(array[index], index, array);
            }
            return result;
          }
          var isArray = Array.isArray;
          var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result = value + "";
            return result == "0" && 1 / value == -Infinity ? "-0" : result;
          }
          var reWhitespace = /\s/;
          function trimmedEndIndex(string2) {
            var index = string2.length;
            while (index-- && reWhitespace.test(string2.charAt(index))) {
            }
            return index;
          }
          var reTrimStart = /^\s+/;
          function baseTrim(string2) {
            return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
          }
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          var NAN = 0 / 0;
          var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
          var reIsBinary = /^0b[01]+$/i;
          var reIsOctal = /^0o[0-7]+$/i;
          var freeParseInt = parseInt;
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function identity$1(value) {
            return value;
          }
          var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
          }
          var coreJsData = root["__core-js_shared__"];
          var maskSrcKey = function() {
            var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid2 ? "Symbol(src)_1." + uid2 : "";
          }();
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var funcProto$2 = Function.prototype;
          var funcToString$2 = funcProto$2.toString;
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString$2.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
          var reIsHostCtor = /^\[object .+?Constructor\]$/;
          var funcProto$1 = Function.prototype, objectProto$b = Object.prototype;
          var funcToString$1 = funcProto$1.toString;
          var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
          var reIsNative = RegExp(
            "^" + funcToString$1.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function getValue$1(object, key) {
            return object == null ? void 0 : object[key];
          }
          function getNative(object, key) {
            var value = getValue$1(object, key);
            return baseIsNative(value) ? value : void 0;
          }
          var WeakMap$1 = getNative(root, "WeakMap");
          var objectCreate = Object.create;
          var baseCreate = /* @__PURE__ */ function() {
            function object() {
            }
            return function(proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result = new object();
              object.prototype = void 0;
              return result;
            };
          }();
          function apply(func, thisArg, args) {
            switch (args.length) {
              case 0:
                return func.call(thisArg);
              case 1:
                return func.call(thisArg, args[0]);
              case 2:
                return func.call(thisArg, args[0], args[1]);
              case 3:
                return func.call(thisArg, args[0], args[1], args[2]);
            }
            return func.apply(thisArg, args);
          }
          function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }
          var HOT_COUNT = 800, HOT_SPAN = 16;
          var nativeNow = Date.now;
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(void 0, arguments);
            };
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          var defineProperty = function() {
            try {
              var func = getNative(Object, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var baseSetToString = !defineProperty ? identity$1 : function(func, string2) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string2),
              "writable": true
            });
          };
          var setToString = shortOut(baseSetToString);
          function arrayEach(array, iteratee) {
            var index = -1, length = array == null ? 0 : array.length;
            while (++index < length) {
              if (iteratee(array[index], index, array) === false) {
                break;
              }
            }
            return array;
          }
          var MAX_SAFE_INTEGER$1 = 9007199254740991;
          var reIsUint = /^(?:0|[1-9]\d*)$/;
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER$1 : length;
            return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var objectProto$a = Object.prototype;
          var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty$8.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = void 0;
              if (newValue === void 0) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          var nativeMax$1 = Math.max;
          function overRest(func, start, transform) {
            start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform(array);
              return apply(func, this, otherArgs);
            };
          }
          var MAX_SAFE_INTEGER = 9007199254740991;
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          var objectProto$9 = Object.prototype;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$9;
            return value === proto;
          }
          function baseTimes(n, iteratee) {
            var index = -1, result = Array(n);
            while (++index < n) {
              result[index] = iteratee(index);
            }
            return result;
          }
          var argsTag$2 = "[object Arguments]";
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag$2;
          }
          var objectProto$8 = Object.prototype;
          var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
          var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
          var isArguments = baseIsArguments(/* @__PURE__ */ function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
          };
          function stubFalse() {
            return false;
          }
          var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
          var freeModule$2 = freeExports$2 && typeof module$1 == "object" && module$1 && !module$1.nodeType && module$1;
          var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
          var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
          var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
          var isBuffer = nativeIsBuffer || stubFalse;
          var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
          var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
          var typedArrayTags = {};
          typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
          typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseUnary(func) {
            return function(value) {
              return func(value);
            };
          }
          var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
          var freeModule$1 = freeExports$1 && typeof module$1 == "object" && module$1 && !module$1.nodeType && module$1;
          var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
          var freeProcess = moduleExports$1 && freeGlobal.process;
          var nodeUtil = function() {
            try {
              var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
              if (types2) {
                return types2;
              }
              return freeProcess && freeProcess.binding && freeProcess.binding("util");
            } catch (e) {
            }
          }();
          var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          var objectProto$7 = Object.prototype;
          var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty$6.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length)))) {
                result.push(key);
              }
            }
            return result;
          }
          function overArg(func, transform) {
            return function(arg) {
              return func(transform(arg));
            };
          }
          var nativeKeys = overArg(Object.keys, Object);
          var objectProto$6 = Object.prototype;
          var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result = [];
            for (var key in Object(object)) {
              if (hasOwnProperty$5.call(object, key) && key != "constructor") {
                result.push(key);
              }
            }
            return result;
          }
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function nativeKeysIn(object) {
            var result = [];
            if (object != null) {
              for (var key in Object(object)) {
                result.push(key);
              }
            }
            return result;
          }
          var objectProto$5 = Object.prototype;
          var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty$4.call(object, key)))) {
                result.push(key);
              }
            }
            return result;
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
          }
          var nativeCreate = getNative(Object, "create");
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
          }
          var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
          var objectProto$4 = Object.prototype;
          var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED$1 ? void 0 : result;
            }
            return hasOwnProperty$3.call(data, key) ? data[key] : void 0;
          }
          var objectProto$3 = Object.prototype;
          var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== void 0 : hasOwnProperty$2.call(data, key);
          }
          var HASH_UNDEFINED = "__lodash_hash_undefined__";
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
            return this;
          }
          function Hash(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }
          var arrayProto = Array.prototype;
          var splice = arrayProto.splice;
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? void 0 : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          function ListCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          var Map$1 = getNative(root, "Map");
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map$1 || ListCache)(),
              "string": new Hash()
            };
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function mapCacheDelete(key) {
            var result = getMapData(this, key)["delete"](key);
            this.size -= result ? 1 : 0;
            return result;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
          }
          function MapCache(entries) {
            var index = -1, length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          var FUNC_ERROR_TEXT$1 = "Expected a function";
          function memoize(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError(FUNC_ERROR_TEXT$1);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result = func.apply(this, args);
              memoized.cache = cache.set(key, result) || cache;
              return result;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          var MAX_MEMOIZE_SIZE = 500;
          function memoizeCapped(func) {
            var result = memoize(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result.cache;
            return result;
          }
          var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
          var reEscapeChar = /\\(\\)?/g;
          var stringToPath = memoizeCapped(function(string2) {
            var result = [];
            if (string2.charCodeAt(0) === 46) {
              result.push("");
            }
            string2.replace(rePropName, function(match, number, quote, subString) {
              result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result;
          });
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result = value + "";
            return result == "0" && 1 / value == -Infinity ? "-0" : result;
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : void 0;
          }
          function get(object, path, defaultValue) {
            var result = object == null ? void 0 : baseGet(object, path);
            return result === void 0 ? defaultValue : result;
          }
          function arrayPush(array, values) {
            var index = -1, length = values.length, offset = array.length;
            while (++index < length) {
              array[offset + index] = values[index];
            }
            return array;
          }
          var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result || (result = []);
            while (++index < length) {
              var value = array[index];
              if (predicate(value)) {
                {
                  arrayPush(result, value);
                }
              } else {
                result[result.length] = value;
              }
            }
            return result;
          }
          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array) : [];
          }
          function flatRest(func) {
            return setToString(overRest(func, void 0, flatten), func + "");
          }
          var getPrototype = overArg(Object.getPrototypeOf, Object);
          var objectTag$2 = "[object Object]";
          var funcProto = Function.prototype, objectProto$2 = Object.prototype;
          var funcToString = funcProto.toString;
          var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
          var objectCtorString = funcToString.call(Object);
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty$1.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result = Array(length);
            while (++index < length) {
              result[index] = array[index + start];
            }
            return result;
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result = data["delete"](key);
            this.size = data.size;
            return result;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          var LARGE_ARRAY_SIZE = 200;
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
          var freeModule = freeExports && typeof module$1 == "object" && module$1 && !module$1.nodeType && module$1;
          var moduleExports = freeModule && freeModule.exports === freeExports;
          var Buffer2 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result);
            return result;
          }
          function arrayFilter(array, predicate) {
            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result[resIndex++] = value;
              }
            }
            return result;
          }
          function stubArray() {
            return [];
          }
          var objectProto$1 = Object.prototype;
          var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
          var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
          var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object(object);
            return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          var nativeGetSymbols = Object.getOwnPropertySymbols;
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result = [];
            while (object) {
              arrayPush(result, getSymbols(object));
              object = getPrototype(object);
            }
            return result;
          };
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var DataView = getNative(root, "DataView");
          var Promise$1 = getNative(root, "Promise");
          var Set$1 = getNative(root, "Set");
          var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
          var dataViewTag$2 = "[object DataView]";
          var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
          var getTag = baseGetTag;
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1()) != mapTag$3 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$3 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
            getTag = function(value) {
              var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag$2;
                  case mapCtorString:
                    return mapTag$3;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag$3;
                  case weakMapCtorString:
                    return weakMapTag$1;
                }
              }
              return result;
            };
          }
          var objectProto = Object.prototype;
          var hasOwnProperty = objectProto.hasOwnProperty;
          function initCloneArray(array) {
            var length = array.length, result = new array.constructor(length);
            if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
              result.index = array.index;
              result.input = array.input;
            }
            return result;
          }
          var Uint8Array2 = root.Uint8Array;
          function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
            return result;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          var reFlags = /\w*$/;
          function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result;
          }
          var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
          var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag$1:
                return cloneArrayBuffer(object);
              case boolTag$1:
              case dateTag$1:
                return new Ctor(+object);
              case dataViewTag$1:
                return cloneDataView(object, isDeep);
              case float32Tag$1:
              case float64Tag$1:
              case int8Tag$1:
              case int16Tag$1:
              case int32Tag$1:
              case uint8Tag$1:
              case uint8ClampedTag$1:
              case uint16Tag$1:
              case uint32Tag$1:
                return cloneTypedArray(object, isDeep);
              case mapTag$2:
                return new Ctor();
              case numberTag$1:
              case stringTag$1:
                return new Ctor(object);
              case regexpTag$1:
                return cloneRegExp(object);
              case setTag$2:
                return new Ctor();
              case symbolTag$1:
                return cloneSymbol(object);
            }
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          var mapTag$1 = "[object Map]";
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag$1;
          }
          var nodeIsMap = nodeUtil && nodeUtil.isMap;
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          var setTag$1 = "[object Set]";
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag$1;
          }
          var nodeIsSet = nodeUtil && nodeUtil.isSet;
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
          var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
          var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
          var cloneableTags = {};
          cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
          cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
          function baseClone(value, bitmask, customizer, key, object, stack2) {
            var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
            if (customizer) {
              result = object ? customizer(value, key, object, stack2) : customizer(value);
            }
            if (result !== void 0) {
              return result;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result = initCloneByTag(value, tag, isDeep);
              }
            }
            stack2 || (stack2 = new Stack());
            var stacked = stack2.get(value);
            if (stacked) {
              return stacked;
            }
            stack2.set(value, result);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? void 0 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
            });
            return result;
          }
          var CLONE_SYMBOLS_FLAG$1 = 4;
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG$1);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object(object);
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length = path.length, result = false;
            while (++index < length) {
              var key = toKey(path[index]);
              if (!(result = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result || ++index != length) {
              return result;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var now = function() {
            return root.Date.now();
          };
          var FUNC_ERROR_TEXT = "Expected a function";
          var nativeMax = Math.max, nativeMin = Math.min;
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
              leading = true;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = void 0;
              lastInvokeTime = time;
              result = func.apply(thisArg, args);
              return result;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout(timerExpired, wait);
              return leading ? invokeFunc(time) : result;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = void 0;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = void 0;
              return result;
            }
            function cancel() {
              if (timerId !== void 0) {
                clearTimeout(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = void 0;
            }
            function flush() {
              return timerId === void 0 ? result : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === void 0) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout(timerId);
                  timerId = setTimeout(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === void 0) {
                timerId = setTimeout(timerExpired, wait);
              }
              return result;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : void 0;
          }
          function fromPairs(pairs) {
            var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
            while (++index < length) {
              var pair = pairs[index];
              result[pair[0]] = pair[1];
            }
            return result;
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function isNil(value) {
            return value == null;
          }
          function isUndefined$1(value) {
            return value === void 0;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? void 0 : value;
          }
          var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
          var omit = flatRest(function(object, paths) {
            var result = {};
            if (object == null) {
              return result;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result);
            if (isDeep) {
              result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result, paths[length]);
            }
            return result;
          });
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = void 0;
                if (newValue === void 0) {
                  newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result = {};
            while (++index < length) {
              var path = paths[index], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result, castPath(path, object), value);
              }
            }
            return result;
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          const isUndefined = (val) => val === void 0;
          const isBoolean = (val) => typeof val === "boolean";
          const isNumber = (val) => typeof val === "number";
          const isElement = (e) => {
            if (typeof Element === "undefined")
              return false;
            return e instanceof Element;
          };
          const isStringNumber = (val) => {
            if (!isString$1(val)) {
              return false;
            }
            return !Number.isNaN(Number(val));
          };
          var __defProp$9 = Object.defineProperty;
          var __defProps$6 = Object.defineProperties;
          var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
          var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
          var __hasOwnProp$b = Object.prototype.hasOwnProperty;
          var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
          var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
          var __spreadValues$9 = (a, b) => {
            for (var prop in b || (b = {}))
              if (__hasOwnProp$b.call(b, prop))
                __defNormalProp$9(a, prop, b[prop]);
            if (__getOwnPropSymbols$b)
              for (var prop of __getOwnPropSymbols$b(b)) {
                if (__propIsEnum$b.call(b, prop))
                  __defNormalProp$9(a, prop, b[prop]);
              }
            return a;
          };
          var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
          function computedEager(fn2, options) {
            var _a2;
            const result = shallowRef();
            watchEffect(() => {
              result.value = fn2();
            }, __spreadProps$6(__spreadValues$9({}, options), {
              flush: (_a2 = void 0) != null ? _a2 : "sync"
            }));
            return readonly(result);
          }
          var _a;
          const isClient = typeof window !== "undefined";
          const isString = (val) => typeof val === "string";
          const noop = () => {
          };
          const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
          function resolveUnref(r) {
            return typeof r === "function" ? r() : unref(r);
          }
          function createFilterWrapper(filter, fn2) {
            function wrapper(...args) {
              return new Promise((resolve2, reject) => {
                Promise.resolve(filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve2).catch(reject);
              });
            }
            return wrapper;
          }
          function debounceFilter(ms, options = {}) {
            let timer;
            let maxTimer;
            let lastRejector = noop;
            const _clearTimeout = (timer2) => {
              clearTimeout(timer2);
              lastRejector();
              lastRejector = noop;
            };
            const filter = (invoke) => {
              const duration = resolveUnref(ms);
              const maxDuration = resolveUnref(options.maxWait);
              if (timer)
                _clearTimeout(timer);
              if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
                if (maxTimer) {
                  _clearTimeout(maxTimer);
                  maxTimer = null;
                }
                return Promise.resolve(invoke());
              }
              return new Promise((resolve2, reject) => {
                lastRejector = options.rejectOnCancel ? reject : resolve2;
                if (maxDuration && !maxTimer) {
                  maxTimer = setTimeout(() => {
                    if (timer)
                      _clearTimeout(timer);
                    maxTimer = null;
                    resolve2(invoke());
                  }, maxDuration);
                }
                timer = setTimeout(() => {
                  if (maxTimer)
                    _clearTimeout(maxTimer);
                  maxTimer = null;
                  resolve2(invoke());
                }, duration);
              });
            };
            return filter;
          }
          function identity(arg) {
            return arg;
          }
          function tryOnScopeDispose(fn2) {
            if (getCurrentScope()) {
              onScopeDispose(fn2);
              return true;
            }
            return false;
          }
          function useDebounceFn(fn2, ms = 200, options = {}) {
            return createFilterWrapper(debounceFilter(ms, options), fn2);
          }
          function refDebounced(value, ms = 200, options = {}) {
            const debounced = ref(value.value);
            const updater = useDebounceFn(() => {
              debounced.value = value.value;
            }, ms, options);
            watch(value, () => updater());
            return debounced;
          }
          function tryOnMounted(fn2, sync = true) {
            if (getCurrentInstance())
              onMounted(fn2);
            else if (sync)
              fn2();
            else
              nextTick(fn2);
          }
          function useTimeoutFn(cb, interval, options = {}) {
            const {
              immediate = true
            } = options;
            const isPending = ref(false);
            let timer = null;
            function clear() {
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
            }
            function stop() {
              isPending.value = false;
              clear();
            }
            function start(...args) {
              clear();
              isPending.value = true;
              timer = setTimeout(() => {
                isPending.value = false;
                timer = null;
                cb(...args);
              }, resolveUnref(interval));
            }
            if (immediate) {
              isPending.value = true;
              if (isClient)
                start();
            }
            tryOnScopeDispose(stop);
            return {
              isPending: readonly(isPending),
              start,
              stop
            };
          }
          function unrefElement(elRef) {
            var _a2;
            const plain = resolveUnref(elRef);
            return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
          }
          const defaultWindow = isClient ? window : void 0;
          const defaultDocument = isClient ? window.document : void 0;
          function useEventListener(...args) {
            let target;
            let events;
            let listeners;
            let options;
            if (isString(args[0]) || Array.isArray(args[0])) {
              [events, listeners, options] = args;
              target = defaultWindow;
            } else {
              [target, events, listeners, options] = args;
            }
            if (!target)
              return noop;
            if (!Array.isArray(events))
              events = [events];
            if (!Array.isArray(listeners))
              listeners = [listeners];
            const cleanups = [];
            const cleanup = () => {
              cleanups.forEach((fn2) => fn2());
              cleanups.length = 0;
            };
            const register = (el, event, listener, options2) => {
              el.addEventListener(event, listener, options2);
              return () => el.removeEventListener(event, listener, options2);
            };
            const stopWatch = watch(() => [unrefElement(target), resolveUnref(options)], ([el, options2]) => {
              cleanup();
              if (!el)
                return;
              cleanups.push(...events.flatMap((event) => {
                return listeners.map((listener) => register(el, event, listener, options2));
              }));
            }, { immediate: true, flush: "post" });
            const stop = () => {
              stopWatch();
              cleanup();
            };
            tryOnScopeDispose(stop);
            return stop;
          }
          let _iOSWorkaround = false;
          function onClickOutside(target, handler, options = {}) {
            const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
            if (!window2)
              return;
            if (isIOS && !_iOSWorkaround) {
              _iOSWorkaround = true;
              Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop));
            }
            let shouldListen = true;
            const shouldIgnore = (event) => {
              return ignore.some((target2) => {
                if (typeof target2 === "string") {
                  return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
                } else {
                  const el = unrefElement(target2);
                  return el && (event.target === el || event.composedPath().includes(el));
                }
              });
            };
            const listener = (event) => {
              const el = unrefElement(target);
              if (!el || el === event.target || event.composedPath().includes(el))
                return;
              if (event.detail === 0)
                shouldListen = !shouldIgnore(event);
              if (!shouldListen) {
                shouldListen = true;
                return;
              }
              handler(event);
            };
            const cleanup = [
              useEventListener(window2, "click", listener, { passive: true, capture }),
              useEventListener(window2, "pointerdown", (e) => {
                const el = unrefElement(target);
                if (el)
                  shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
              }, { passive: true }),
              detectIframe && useEventListener(window2, "blur", (event) => {
                var _a2;
                const el = unrefElement(target);
                if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
                  handler(event);
              })
            ].filter(Boolean);
            const stop = () => cleanup.forEach((fn2) => fn2());
            return stop;
          }
          function useSupported(callback, sync = false) {
            const isSupported = ref();
            const update = () => isSupported.value = Boolean(callback());
            update();
            tryOnMounted(update, sync);
            return isSupported;
          }
          const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
          const globalKey = "__vueuse_ssr_handlers__";
          _global[globalKey] = _global[globalKey] || {};
          function useDocumentVisibility({ document: document2 = defaultDocument } = {}) {
            if (!document2)
              return ref("visible");
            const visibility = ref(document2.visibilityState);
            useEventListener(document2, "visibilitychange", () => {
              visibility.value = document2.visibilityState;
            });
            return visibility;
          }
          var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
          var __hasOwnProp$g = Object.prototype.hasOwnProperty;
          var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
          var __objRest$2 = (source, exclude) => {
            var target = {};
            for (var prop in source)
              if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
                target[prop] = source[prop];
            if (source != null && __getOwnPropSymbols$g)
              for (var prop of __getOwnPropSymbols$g(source)) {
                if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
                  target[prop] = source[prop];
              }
            return target;
          };
          function useResizeObserver(target, callback, options = {}) {
            const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
            let observer;
            const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
            const cleanup = () => {
              if (observer) {
                observer.disconnect();
                observer = void 0;
              }
            };
            const stopWatch = watch(() => unrefElement(target), (el) => {
              cleanup();
              if (isSupported.value && window2 && el) {
                observer = new ResizeObserver(callback);
                observer.observe(el, observerOptions);
              }
            }, { immediate: true, flush: "post" });
            const stop = () => {
              cleanup();
              stopWatch();
            };
            tryOnScopeDispose(stop);
            return {
              isSupported,
              stop
            };
          }
          var SwipeDirection;
          (function(SwipeDirection2) {
            SwipeDirection2["UP"] = "UP";
            SwipeDirection2["RIGHT"] = "RIGHT";
            SwipeDirection2["DOWN"] = "DOWN";
            SwipeDirection2["LEFT"] = "LEFT";
            SwipeDirection2["NONE"] = "NONE";
          })(SwipeDirection || (SwipeDirection = {}));
          var __defProp = Object.defineProperty;
          var __getOwnPropSymbols = Object.getOwnPropertySymbols;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __propIsEnum = Object.prototype.propertyIsEnumerable;
          var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
          var __spreadValues = (a, b) => {
            for (var prop in b || (b = {}))
              if (__hasOwnProp.call(b, prop))
                __defNormalProp(a, prop, b[prop]);
            if (__getOwnPropSymbols)
              for (var prop of __getOwnPropSymbols(b)) {
                if (__propIsEnum.call(b, prop))
                  __defNormalProp(a, prop, b[prop]);
              }
            return a;
          };
          const _TransitionPresets = {
            easeInSine: [0.12, 0, 0.39, 0],
            easeOutSine: [0.61, 1, 0.88, 1],
            easeInOutSine: [0.37, 0, 0.63, 1],
            easeInQuad: [0.11, 0, 0.5, 0],
            easeOutQuad: [0.5, 1, 0.89, 1],
            easeInOutQuad: [0.45, 0, 0.55, 1],
            easeInCubic: [0.32, 0, 0.67, 0],
            easeOutCubic: [0.33, 1, 0.68, 1],
            easeInOutCubic: [0.65, 0, 0.35, 1],
            easeInQuart: [0.5, 0, 0.75, 0],
            easeOutQuart: [0.25, 1, 0.5, 1],
            easeInOutQuart: [0.76, 0, 0.24, 1],
            easeInQuint: [0.64, 0, 0.78, 0],
            easeOutQuint: [0.22, 1, 0.36, 1],
            easeInOutQuint: [0.83, 0, 0.17, 1],
            easeInExpo: [0.7, 0, 0.84, 0],
            easeOutExpo: [0.16, 1, 0.3, 1],
            easeInOutExpo: [0.87, 0, 0.13, 1],
            easeInCirc: [0.55, 0, 1, 0.45],
            easeOutCirc: [0, 0.55, 0.45, 1],
            easeInOutCirc: [0.85, 0, 0.15, 1],
            easeInBack: [0.36, 0, 0.66, -0.56],
            easeOutBack: [0.34, 1.56, 0.64, 1],
            easeInOutBack: [0.68, -0.6, 0.32, 1.6]
          };
          __spreadValues({
            linear: identity
          }, _TransitionPresets);
          function useWindowFocus({ window: window2 = defaultWindow } = {}) {
            if (!window2)
              return ref(false);
            const focused = ref(window2.document.hasFocus());
            useEventListener(window2, "blur", () => {
              focused.value = false;
            });
            useEventListener(window2, "focus", () => {
              focused.value = true;
            });
            return focused;
          }
          class ElementPlusError extends Error {
            constructor(m) {
              super(m);
              this.name = "ElementPlusError";
            }
          }
          function throwError(scope, m) {
            throw new ElementPlusError(`[${scope}] ${m}`);
          }
          function debugWarn(scope, message2) {
          }
          const initial = {
            current: 0
          };
          const zIndex = ref(0);
          const defaultInitialZIndex = 2e3;
          const ZINDEX_INJECTION_KEY = Symbol("elZIndexContextKey");
          const zIndexContextKey = Symbol("zIndexContextKey");
          const useZIndex = (zIndexOverrides) => {
            const increasingInjection = getCurrentInstance() ? inject(ZINDEX_INJECTION_KEY, initial) : initial;
            const zIndexInjection = zIndexOverrides || (getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0);
            const initialZIndex = computed(() => {
              const zIndexFromInjection = unref(zIndexInjection);
              return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
            });
            const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
            const nextZIndex = () => {
              increasingInjection.current++;
              zIndex.value = increasingInjection.current;
              return currentZIndex.value;
            };
            if (!isClient && !inject(ZINDEX_INJECTION_KEY)) ;
            return {
              initialZIndex,
              currentZIndex,
              nextZIndex
            };
          };
          var English = {
            name: "en",
            el: {
              breadcrumb: {
                label: "Breadcrumb"
              },
              colorpicker: {
                confirm: "OK",
                clear: "Clear",
                defaultLabel: "color picker",
                description: "current color is {color}. press enter to select a new color.",
                alphaLabel: "pick alpha value"
              },
              datepicker: {
                now: "Now",
                today: "Today",
                cancel: "Cancel",
                clear: "Clear",
                confirm: "OK",
                dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
                monthTablePrompt: "Use the arrow keys and enter to select the month",
                yearTablePrompt: "Use the arrow keys and enter to select the year",
                selectedDate: "Selected date",
                selectDate: "Select date",
                selectTime: "Select time",
                startDate: "Start Date",
                startTime: "Start Time",
                endDate: "End Date",
                endTime: "End Time",
                prevYear: "Previous Year",
                nextYear: "Next Year",
                prevMonth: "Previous Month",
                nextMonth: "Next Month",
                year: "",
                month1: "January",
                month2: "February",
                month3: "March",
                month4: "April",
                month5: "May",
                month6: "June",
                month7: "July",
                month8: "August",
                month9: "September",
                month10: "October",
                month11: "November",
                month12: "December",
                week: "week",
                weeks: {
                  sun: "Sun",
                  mon: "Mon",
                  tue: "Tue",
                  wed: "Wed",
                  thu: "Thu",
                  fri: "Fri",
                  sat: "Sat"
                },
                weeksFull: {
                  sun: "Sunday",
                  mon: "Monday",
                  tue: "Tuesday",
                  wed: "Wednesday",
                  thu: "Thursday",
                  fri: "Friday",
                  sat: "Saturday"
                },
                months: {
                  jan: "Jan",
                  feb: "Feb",
                  mar: "Mar",
                  apr: "Apr",
                  may: "May",
                  jun: "Jun",
                  jul: "Jul",
                  aug: "Aug",
                  sep: "Sep",
                  oct: "Oct",
                  nov: "Nov",
                  dec: "Dec"
                }
              },
              inputNumber: {
                decrease: "decrease number",
                increase: "increase number"
              },
              select: {
                loading: "Loading",
                noMatch: "No matching data",
                noData: "No data",
                placeholder: "Select"
              },
              mention: {
                loading: "Loading"
              },
              dropdown: {
                toggleDropdown: "Toggle Dropdown"
              },
              cascader: {
                noMatch: "No matching data",
                loading: "Loading",
                placeholder: "Select",
                noData: "No data"
              },
              pagination: {
                goto: "Go to",
                pagesize: "/page",
                total: "Total {total}",
                pageClassifier: "",
                page: "Page",
                prev: "Go to previous page",
                next: "Go to next page",
                currentPage: "page {pager}",
                prevPages: "Previous {pager} pages",
                nextPages: "Next {pager} pages",
                deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
              },
              dialog: {
                close: "Close this dialog"
              },
              drawer: {
                close: "Close this dialog"
              },
              messagebox: {
                title: "Message",
                confirm: "OK",
                cancel: "Cancel",
                error: "Illegal input",
                close: "Close this dialog"
              },
              upload: {
                deleteTip: "press delete to remove",
                delete: "Delete",
                preview: "Preview",
                continue: "Continue"
              },
              slider: {
                defaultLabel: "slider between {min} and {max}",
                defaultRangeStartLabel: "pick start value",
                defaultRangeEndLabel: "pick end value"
              },
              table: {
                emptyText: "No Data",
                confirmFilter: "Confirm",
                resetFilter: "Reset",
                clearFilter: "All",
                sumText: "Sum"
              },
              tour: {
                next: "Next",
                previous: "Previous",
                finish: "Finish"
              },
              tree: {
                emptyText: "No Data"
              },
              transfer: {
                noMatch: "No matching data",
                noData: "No data",
                titles: ["List 1", "List 2"],
                filterPlaceholder: "Enter keyword",
                noCheckedFormat: "{total} items",
                hasCheckedFormat: "{checked}/{total} checked"
              },
              image: {
                error: "FAILED"
              },
              pageHeader: {
                title: "Back"
              },
              popconfirm: {
                confirmButtonText: "Yes",
                cancelButtonText: "No"
              },
              carousel: {
                leftArrow: "Carousel arrow left",
                rightArrow: "Carousel arrow right",
                indicator: "Carousel switch to index {index}"
              }
            }
          };
          const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
          const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_, key) => {
            var _a2;
            return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
          });
          const buildLocaleContext = (locale) => {
            const lang = computed(() => unref(locale).name);
            const localeRef = isRef(locale) ? locale : ref(locale);
            return {
              lang,
              locale: localeRef,
              t: buildTranslator(locale)
            };
          };
          const localeContextKey = Symbol("localeContextKey");
          const useLocale = (localeOverrides) => {
            const locale = localeOverrides || inject(localeContextKey, ref());
            return buildLocaleContext(computed(() => locale.value || English));
          };
          const epPropKey = "__epPropKey";
          const definePropType = (val) => val;
          const isEpProp = (val) => isObject$1(val) && !!val[epPropKey];
          const buildProp = (prop, key) => {
            if (!isObject$1(prop) || isEpProp(prop))
              return prop;
            const { values, required, default: defaultValue, type, validator } = prop;
            const _validator = values || validator ? (val) => {
              let valid = false;
              let allowedValues = [];
              if (values) {
                allowedValues = Array.from(values);
                if (hasOwn(prop, "default")) {
                  allowedValues.push(defaultValue);
                }
                valid || (valid = allowedValues.includes(val));
              }
              if (validator)
                valid || (valid = validator(val));
              if (!valid && allowedValues.length > 0) {
                const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
                warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
              }
              return valid;
            } : void 0;
            const epProp = {
              type,
              required: !!required,
              validator: _validator,
              [epPropKey]: true
            };
            if (hasOwn(prop, "default"))
              epProp.default = defaultValue;
            return epProp;
          };
          const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
            key,
            buildProp(option, key)
          ]));
          const componentSizes = ["", "default", "small", "large"];
          const useSizeProp = buildProp({
            type: String,
            values: componentSizes,
            required: false
          });
          const SIZE_INJECTION_KEY = Symbol("size");
          const useGlobalSize = () => {
            const injectedSize = inject(SIZE_INJECTION_KEY, {});
            return computed(() => {
              return unref(injectedSize.size) || "";
            });
          };
          const emptyValuesContextKey = Symbol("emptyValuesContextKey");
          const DEFAULT_EMPTY_VALUES = ["", void 0, null];
          const useEmptyValuesProps = buildProps({
            emptyValues: Array,
            valueOnClear: {
              type: [String, Number, Boolean, Function],
              default: void 0,
              validator: (val) => isFunction$1(val) ? !val() : !val
            }
          });
          const useEmptyValues = (props, defaultValue) => {
            const config2 = getCurrentInstance() ? inject(emptyValuesContextKey, ref({})) : ref({});
            const emptyValues = computed(() => props.emptyValues || config2.value.emptyValues || DEFAULT_EMPTY_VALUES);
            const valueOnClear = computed(() => {
              if (isFunction$1(props.valueOnClear)) {
                return props.valueOnClear();
              } else if (props.valueOnClear !== void 0) {
                return props.valueOnClear;
              } else if (isFunction$1(config2.value.valueOnClear)) {
                return config2.value.valueOnClear();
              } else if (config2.value.valueOnClear !== void 0) {
                return config2.value.valueOnClear;
              }
              return defaultValue;
            });
            const isEmptyValue2 = (value) => {
              return emptyValues.value.includes(value);
            };
            if (!emptyValues.value.includes(valueOnClear.value)) ;
            return {
              emptyValues,
              valueOnClear,
              isEmptyValue: isEmptyValue2
            };
          };
          const keysOf = (arr) => Object.keys(arr);
          const getProp = (obj, path, defaultValue) => {
            return {
              get value() {
                return get(obj, path, defaultValue);
              },
              set value(val) {
                set(obj, path, val);
              }
            };
          };
          const globalConfig = ref();
          function useGlobalConfig(key, defaultValue = void 0) {
            const config2 = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
            if (key) {
              return computed(() => {
                var _a2, _b;
                return (_b = (_a2 = config2.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
              });
            } else {
              return config2;
            }
          }
          function useGlobalComponentSettings(block, sizeFallback) {
            const config2 = useGlobalConfig();
            const ns = useNamespace(block, computed(() => {
              var _a2;
              return ((_a2 = config2.value) == null ? void 0 : _a2.namespace) || defaultNamespace;
            }));
            const locale = useLocale(computed(() => {
              var _a2;
              return (_a2 = config2.value) == null ? void 0 : _a2.locale;
            }));
            const zIndex2 = useZIndex(computed(() => {
              var _a2;
              return ((_a2 = config2.value) == null ? void 0 : _a2.zIndex) || defaultInitialZIndex;
            }));
            const size = computed(() => {
              var _a2;
              return unref(sizeFallback) || ((_a2 = config2.value) == null ? void 0 : _a2.size) || "";
            });
            provideGlobalConfig(computed(() => unref(config2) || {}));
            return {
              ns,
              locale,
              zIndex: zIndex2,
              size
            };
          }
          const provideGlobalConfig = (config2, app, global2 = false) => {
            var _a2;
            const inSetup = !!getCurrentInstance();
            const oldConfig = inSetup ? useGlobalConfig() : void 0;
            const provideFn = (_a2 = void 0) != null ? _a2 : inSetup ? provide : void 0;
            if (!provideFn) {
              return;
            }
            const context = computed(() => {
              const cfg = unref(config2);
              if (!(oldConfig == null ? void 0 : oldConfig.value))
                return cfg;
              return mergeConfig(oldConfig.value, cfg);
            });
            provideFn(configProviderContextKey, context);
            provideFn(localeContextKey, computed(() => context.value.locale));
            provideFn(namespaceContextKey, computed(() => context.value.namespace));
            provideFn(zIndexContextKey, computed(() => context.value.zIndex));
            provideFn(SIZE_INJECTION_KEY, {
              size: computed(() => context.value.size || "")
            });
            provideFn(emptyValuesContextKey, computed(() => ({
              emptyValues: context.value.emptyValues,
              valueOnClear: context.value.valueOnClear
            })));
            if (global2 || !globalConfig.value) {
              globalConfig.value = context.value;
            }
            return context;
          };
          const mergeConfig = (a, b) => {
            const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a), ...keysOf(b)])];
            const obj = {};
            for (const key of keys2) {
              obj[key] = b[key] !== void 0 ? b[key] : a[key];
            }
            return obj;
          };
          const UPDATE_MODEL_EVENT = "update:modelValue";
          const CHANGE_EVENT = "change";
          const INPUT_EVENT = "input";
          var _export_sfc = (sfc, props) => {
            const target = sfc.__vccOpts || sfc;
            for (const [key, val] of props) {
              target[key] = val;
            }
            return target;
          };
          const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
          const hasClass = (el, cls) => {
            if (!el || !cls)
              return false;
            if (cls.includes(" "))
              throw new Error("className should not contain space.");
            return el.classList.contains(cls);
          };
          const addClass = (el, cls) => {
            if (!el || !cls.trim())
              return;
            el.classList.add(...classNameToArray(cls));
          };
          const removeClass = (el, cls) => {
            if (!el || !cls.trim())
              return;
            el.classList.remove(...classNameToArray(cls));
          };
          const getStyle = (element, styleName) => {
            var _a2;
            if (!isClient || !element || !styleName)
              return "";
            let key = camelize(styleName);
            if (key === "float")
              key = "cssFloat";
            try {
              const style = element.style[key];
              if (style)
                return style;
              const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
              return computed2 ? computed2[key] : "";
            } catch (e) {
              return element.style[key];
            }
          };
          function addUnit(value, defaultUnit = "px") {
            if (!value)
              return "";
            if (isNumber(value) || isStringNumber(value)) {
              return `${value}${defaultUnit}`;
            } else if (isString$1(value)) {
              return value;
            }
          }
          let scrollBarWidth;
          const getScrollBarWidth = (namespace) => {
            var _a2;
            if (!isClient)
              return 0;
            if (scrollBarWidth !== void 0)
              return scrollBarWidth;
            const outer = document.createElement("div");
            outer.className = `${namespace}-scrollbar__wrap`;
            outer.style.visibility = "hidden";
            outer.style.width = "100px";
            outer.style.position = "absolute";
            outer.style.top = "-9999px";
            document.body.appendChild(outer);
            const widthNoScroll = outer.offsetWidth;
            outer.style.overflow = "scroll";
            const inner = document.createElement("div");
            inner.style.width = "100%";
            outer.appendChild(inner);
            const widthWithScroll = inner.offsetWidth;
            (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
            scrollBarWidth = widthNoScroll - widthWithScroll;
            return scrollBarWidth;
          };
          const withInstall = (main, extra) => {
            main.install = (app) => {
              for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
                app.component(comp.name, comp);
              }
            };
            if (extra) {
              for (const [key, comp] of Object.entries(extra)) {
                main[key] = comp;
              }
            }
            return main;
          };
          const withInstallFunction = (fn2, name) => {
            fn2.install = (app) => {
              fn2._context = app._context;
              app.config.globalProperties[name] = fn2;
            };
            return fn2;
          };
          const withNoopInstall = (component) => {
            component.install = NOOP;
            return component;
          };
          const iconProps = buildProps({
            size: {
              type: definePropType([Number, String])
            },
            color: {
              type: String
            }
          });
          const __default__$p = /* @__PURE__ */ defineComponent({
            name: "ElIcon",
            inheritAttrs: false
          });
          const _sfc_main$A = /* @__PURE__ */ defineComponent({
            ...__default__$p,
            props: iconProps,
            setup(__props) {
              const props = __props;
              const ns = useNamespace("icon");
              const style = computed(() => {
                const { size, color } = props;
                if (!size && !color)
                  return {};
                return {
                  fontSize: isUndefined(size) ? void 0 : addUnit(size),
                  "--color": color
                };
              });
              return (_ctx, _cache) => {
                return openBlock(), createElementBlock("i", mergeProps({
                  class: unref(ns).b(),
                  style: unref(style)
                }, _ctx.$attrs), [
                  renderSlot(_ctx.$slots, "default")
                ], 16);
              };
            }
          });
          var Icon = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["__file", "icon.vue"]]);
          const ElIcon = withInstall(Icon);
          function useTimeout() {
            let timeoutHandle;
            const registerTimeout = (fn2, delay) => {
              cancelTimeout();
              timeoutHandle = window.setTimeout(fn2, delay);
            };
            const cancelTimeout = () => window.clearTimeout(timeoutHandle);
            tryOnScopeDispose(() => cancelTimeout());
            return {
              registerTimeout,
              cancelTimeout
            };
          }
          const useDelayedToggleProps = buildProps({
            showAfter: {
              type: Number,
              default: 0
            },
            hideAfter: {
              type: Number,
              default: 200
            },
            autoClose: {
              type: Number,
              default: 0
            }
          });
          const useDelayedToggle = ({
            showAfter,
            hideAfter,
            autoClose,
            open,
            close
          }) => {
            const { registerTimeout } = useTimeout();
            const {
              registerTimeout: registerTimeoutForAutoClose,
              cancelTimeout: cancelTimeoutForAutoClose
            } = useTimeout();
            const onOpen = (event) => {
              registerTimeout(() => {
                open(event);
                const _autoClose = unref(autoClose);
                if (isNumber(_autoClose) && _autoClose > 0) {
                  registerTimeoutForAutoClose(() => {
                    close(event);
                  }, _autoClose);
                }
              }, unref(showAfter));
            };
            const onClose = (event) => {
              cancelTimeoutForAutoClose();
              registerTimeout(() => {
                close(event);
              }, unref(hideAfter));
            };
            return {
              onOpen,
              onClose
            };
          };
          /*! Element Plus Icons Vue v2.3.1 */
          var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "ArrowDown",
            __name: "arrow-down",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
                })
              ]));
            }
          });
          var arrow_down_default = arrow_down_vue_vue_type_script_setup_true_lang_default;
          var arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "ArrowLeft",
            __name: "arrow-left",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
                })
              ]));
            }
          });
          var arrow_left_default = arrow_left_vue_vue_type_script_setup_true_lang_default;
          var arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "ArrowRight",
            __name: "arrow-right",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
                })
              ]));
            }
          });
          var arrow_right_default = arrow_right_vue_vue_type_script_setup_true_lang_default;
          var arrow_up_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "ArrowUp",
            __name: "arrow-up",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
                })
              ]));
            }
          });
          var arrow_up_default = arrow_up_vue_vue_type_script_setup_true_lang_default;
          var circle_check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "CircleCheck",
            __name: "circle-check",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
                }),
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
                })
              ]));
            }
          });
          var circle_check_default = circle_check_vue_vue_type_script_setup_true_lang_default;
          var circle_close_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "CircleCloseFilled",
            __name: "circle-close-filled",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
                })
              ]));
            }
          });
          var circle_close_filled_default = circle_close_filled_vue_vue_type_script_setup_true_lang_default;
          var circle_close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "CircleClose",
            __name: "circle-close",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
                }),
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
                })
              ]));
            }
          });
          var circle_close_default = circle_close_vue_vue_type_script_setup_true_lang_default;
          var close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "Close",
            __name: "close",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
                })
              ]));
            }
          });
          var close_default = close_vue_vue_type_script_setup_true_lang_default;
          var hide_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "Hide",
            __name: "hide",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
                }),
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
                })
              ]));
            }
          });
          var hide_default = hide_vue_vue_type_script_setup_true_lang_default;
          var info_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "InfoFilled",
            __name: "info-filled",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
                })
              ]));
            }
          });
          var info_filled_default = info_filled_vue_vue_type_script_setup_true_lang_default;
          var loading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "Loading",
            __name: "loading",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
                })
              ]));
            }
          });
          var loading_default = loading_vue_vue_type_script_setup_true_lang_default;
          var minus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "Minus",
            __name: "minus",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
                })
              ]));
            }
          });
          var minus_default = minus_vue_vue_type_script_setup_true_lang_default;
          var plus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "Plus",
            __name: "plus",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
                })
              ]));
            }
          });
          var plus_default = plus_vue_vue_type_script_setup_true_lang_default;
          var success_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "SuccessFilled",
            __name: "success-filled",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
                })
              ]));
            }
          });
          var success_filled_default = success_filled_vue_vue_type_script_setup_true_lang_default;
          var view_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "View",
            __name: "view",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
                })
              ]));
            }
          });
          var view_default = view_vue_vue_type_script_setup_true_lang_default;
          var warning_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
            name: "WarningFilled",
            __name: "warning-filled",
            setup(__props) {
              return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 1024 1024"
              }, [
                createBaseVNode("path", {
                  fill: "currentColor",
                  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
                })
              ]));
            }
          });
          var warning_filled_default = warning_filled_vue_vue_type_script_setup_true_lang_default;
          const iconPropType = definePropType([
            String,
            Object,
            Function
          ]);
          const CloseComponents = {
            Close: close_default
          };
          const TypeComponents = {
            Close: close_default
          };
          const TypeComponentsMap = {
            primary: info_filled_default,
            success: success_filled_default,
            warning: warning_filled_default,
            error: circle_close_filled_default,
            info: info_filled_default
          };
          const ValidateComponentsMap = {
            validating: loading_default,
            success: circle_check_default,
            error: circle_close_default
          };
          const alertEffects = ["light", "dark"];
          const alertProps = buildProps({
            title: {
              type: String,
              default: ""
            },
            description: {
              type: String,
              default: ""
            },
            type: {
              type: String,
              values: keysOf(TypeComponentsMap),
              default: "info"
            },
            closable: {
              type: Boolean,
              default: true
            },
            closeText: {
              type: String,
              default: ""
            },
            showIcon: Boolean,
            center: Boolean,
            effect: {
              type: String,
              values: alertEffects,
              default: "light"
            },
            ...useDelayedToggleProps
          });
          const alertEmits = {
            open: () => true,
            close: (evt) => isUndefined(evt) || evt instanceof Event
          };
          const __default__$o = /* @__PURE__ */ defineComponent({
            name: "ElAlert"
          });
          const _sfc_main$z = /* @__PURE__ */ defineComponent({
            ...__default__$o,
            props: alertProps,
            emits: alertEmits,
            setup(__props, { emit: emit2 }) {
              const props = __props;
              const { Close } = TypeComponents;
              const slots = useSlots();
              const ns = useNamespace("alert");
              const visible = ref(false);
              const iconComponent = computed(() => TypeComponentsMap[props.type]);
              const hasDesc = computed(() => !!(props.description || slots.default));
              const open = () => {
                visible.value = true;
                emit2("open");
              };
              const close = (event) => {
                visible.value = false;
                emit2("close", event);
              };
              const { onOpen, onClose } = useDelayedToggle({
                showAfter: toRef(props, "showAfter"),
                hideAfter: toRef(props, "hideAfter"),
                autoClose: toRef(props, "autoClose"),
                open,
                close
              });
              if (isClient) {
                onOpen();
              }
              return (_ctx, _cache) => {
                return openBlock(), createBlock(Transition, {
                  name: unref(ns).b("fade"),
                  persisted: ""
                }, {
                  default: withCtx(() => [
                    withDirectives(createBaseVNode("div", {
                      class: normalizeClass([unref(ns).b(), unref(ns).m(_ctx.type), unref(ns).is("center", _ctx.center), unref(ns).is(_ctx.effect)]),
                      role: "alert"
                    }, [
                      _ctx.showIcon && (_ctx.$slots.icon || unref(iconComponent)) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass([unref(ns).e("icon"), { [unref(ns).is("big")]: unref(hasDesc) }])
                      }, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "icon", {}, () => [
                            (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                          ])
                        ]),
                        _: 3
                      }, 8, ["class"])) : createCommentVNode("v-if", true),
                      createBaseVNode("div", {
                        class: normalizeClass(unref(ns).e("content"))
                      }, [
                        _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("span", {
                          key: 0,
                          class: normalizeClass([unref(ns).e("title"), { "with-description": unref(hasDesc) }])
                        }, [
                          renderSlot(_ctx.$slots, "title", {}, () => [
                            createTextVNode(toDisplayString(_ctx.title), 1)
                          ])
                        ], 2)) : createCommentVNode("v-if", true),
                        unref(hasDesc) ? (openBlock(), createElementBlock("p", {
                          key: 1,
                          class: normalizeClass(unref(ns).e("description"))
                        }, [
                          renderSlot(_ctx.$slots, "default", {}, () => [
                            createTextVNode(toDisplayString(_ctx.description), 1)
                          ])
                        ], 2)) : createCommentVNode("v-if", true),
                        _ctx.closable ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                          _ctx.closeText ? (openBlock(), createElementBlock("div", {
                            key: 0,
                            class: normalizeClass([unref(ns).e("close-btn"), unref(ns).is("customed")]),
                            onClick: close
                          }, toDisplayString(_ctx.closeText), 3)) : (openBlock(), createBlock(unref(ElIcon), {
                            key: 1,
                            class: normalizeClass(unref(ns).e("close-btn")),
                            onClick: unref(onClose)
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(Close))
                            ]),
                            _: 1
                          }, 8, ["class", "onClick"]))
                        ], 64)) : createCommentVNode("v-if", true)
                      ], 2)
                    ], 2), [
                      [vShow, visible.value]
                    ])
                  ]),
                  _: 3
                }, 8, ["name"]);
              };
            }
          });
          var Alert = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__file", "alert.vue"]]);
          const ElAlert = withInstall(Alert);
          const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
          let hiddenTextarea = void 0;
          const HIDDEN_STYLE = {
            height: "0",
            visibility: "hidden",
            overflow: isFirefox() ? "" : "hidden",
            position: "absolute",
            "z-index": "-1000",
            top: "0",
            right: "0"
          };
          const CONTEXT_STYLE = [
            "letter-spacing",
            "line-height",
            "padding-top",
            "padding-bottom",
            "font-family",
            "font-weight",
            "font-size",
            "text-rendering",
            "text-transform",
            "width",
            "text-indent",
            "padding-left",
            "padding-right",
            "border-width",
            "box-sizing"
          ];
          function calculateNodeStyling(targetElement) {
            const style = window.getComputedStyle(targetElement);
            const boxSizing = style.getPropertyValue("box-sizing");
            const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
            const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
            const contextStyle = CONTEXT_STYLE.map((name) => [
              name,
              style.getPropertyValue(name)
            ]);
            return { contextStyle, paddingSize, borderSize, boxSizing };
          }
          function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
            var _a2;
            if (!hiddenTextarea) {
              hiddenTextarea = document.createElement("textarea");
              document.body.appendChild(hiddenTextarea);
            }
            const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
            contextStyle.forEach(([key, value]) => hiddenTextarea == null ? void 0 : hiddenTextarea.style.setProperty(key, value));
            Object.entries(HIDDEN_STYLE).forEach(([key, value]) => hiddenTextarea == null ? void 0 : hiddenTextarea.style.setProperty(key, value, "important"));
            hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
            let height = hiddenTextarea.scrollHeight;
            const result = {};
            if (boxSizing === "border-box") {
              height = height + borderSize;
            } else if (boxSizing === "content-box") {
              height = height - paddingSize;
            }
            hiddenTextarea.value = "";
            const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
            if (isNumber(minRows)) {
              let minHeight = singleRowHeight * minRows;
              if (boxSizing === "border-box") {
                minHeight = minHeight + paddingSize + borderSize;
              }
              height = Math.max(minHeight, height);
              result.minHeight = `${minHeight}px`;
            }
            if (isNumber(maxRows)) {
              let maxHeight = singleRowHeight * maxRows;
              if (boxSizing === "border-box") {
                maxHeight = maxHeight + paddingSize + borderSize;
              }
              height = Math.min(maxHeight, height);
            }
            result.height = `${height}px`;
            (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
            hiddenTextarea = void 0;
            return result;
          }
          const mutable = (val) => val;
          const ariaProps = buildProps({
            ariaLabel: String,
            ariaOrientation: {
              type: String,
              values: ["horizontal", "vertical", "undefined"]
            },
            ariaControls: String
          });
          const useAriaProps = (arias) => {
            return pick(ariaProps, arias);
          };
          const inputProps = buildProps({
            id: {
              type: String,
              default: void 0
            },
            size: useSizeProp,
            disabled: Boolean,
            modelValue: {
              type: definePropType([
                String,
                Number,
                Object
              ]),
              default: ""
            },
            maxlength: {
              type: [String, Number]
            },
            minlength: {
              type: [String, Number]
            },
            type: {
              type: String,
              default: "text"
            },
            resize: {
              type: String,
              values: ["none", "both", "horizontal", "vertical"]
            },
            autosize: {
              type: definePropType([Boolean, Object]),
              default: false
            },
            autocomplete: {
              type: String,
              default: "off"
            },
            formatter: {
              type: Function
            },
            parser: {
              type: Function
            },
            placeholder: {
              type: String
            },
            form: {
              type: String
            },
            readonly: Boolean,
            clearable: Boolean,
            showPassword: Boolean,
            showWordLimit: Boolean,
            suffixIcon: {
              type: iconPropType
            },
            prefixIcon: {
              type: iconPropType
            },
            containerRole: {
              type: String,
              default: void 0
            },
            tabindex: {
              type: [String, Number],
              default: 0
            },
            validateEvent: {
              type: Boolean,
              default: true
            },
            inputStyle: {
              type: definePropType([Object, Array, String]),
              default: () => mutable({})
            },
            autofocus: Boolean,
            rows: {
              type: Number,
              default: 2
            },
            ...useAriaProps(["ariaLabel"]),
            inputmode: {
              type: definePropType(String),
              default: void 0
            },
            name: String
          });
          const inputEmits = {
            [UPDATE_MODEL_EVENT]: (value) => isString$1(value),
            input: (value) => isString$1(value),
            change: (value) => isString$1(value),
            focus: (evt) => evt instanceof FocusEvent,
            blur: (evt) => evt instanceof FocusEvent,
            clear: () => true,
            mouseleave: (evt) => evt instanceof MouseEvent,
            mouseenter: (evt) => evt instanceof MouseEvent,
            keydown: (evt) => evt instanceof Event,
            compositionstart: (evt) => evt instanceof CompositionEvent,
            compositionupdate: (evt) => evt instanceof CompositionEvent,
            compositionend: (evt) => evt instanceof CompositionEvent
          };
          const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
          const LISTENER_PREFIX = /^on[A-Z]/;
          const useAttrs = (params = {}) => {
            const { excludeListeners = false, excludeKeys } = params;
            const allExcludeKeys = computed(() => {
              return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
            });
            const instance = getCurrentInstance();
            if (!instance) {
              return computed(() => ({}));
            }
            return computed(() => {
              var _a2;
              return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
            });
          };
          const defaultIdInjection = {
            prefix: Math.floor(Math.random() * 1e4),
            current: 0
          };
          const ID_INJECTION_KEY = Symbol("elIdInjection");
          const useIdInjection = () => {
            return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
          };
          const useId = (deterministicId) => {
            const idInjection = useIdInjection();
            const namespace = useGetDerivedNamespace();
            const idRef = computedEager(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
            return idRef;
          };
          const formContextKey = Symbol("formContextKey");
          const formItemContextKey = Symbol("formItemContextKey");
          const useFormItem = () => {
            const form = inject(formContextKey, void 0);
            const formItem = inject(formItemContextKey, void 0);
            return {
              form,
              formItem
            };
          };
          const useFormItemInputId = (props, {
            formItemContext,
            disableIdGeneration,
            disableIdManagement
          }) => {
            if (!disableIdGeneration) {
              disableIdGeneration = ref(false);
            }
            if (!disableIdManagement) {
              disableIdManagement = ref(false);
            }
            const inputId = ref();
            let idUnwatch = void 0;
            const isLabeledByFormItem = computed(() => {
              var _a2;
              return !!(!(props.label || props.ariaLabel) && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
            });
            onMounted(() => {
              idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
                const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
                if (newId !== inputId.value) {
                  if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
                    inputId.value && formItemContext.removeInputId(inputId.value);
                    if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                      formItemContext.addInputId(newId);
                    }
                  }
                  inputId.value = newId;
                }
              }, { immediate: true });
            });
            onUnmounted(() => {
              idUnwatch && idUnwatch();
              if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
                inputId.value && formItemContext.removeInputId(inputId.value);
              }
            });
            return {
              isLabeledByFormItem,
              inputId
            };
          };
          const useProp = (name) => {
            const vm = getCurrentInstance();
            return computed(() => {
              var _a2, _b;
              return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
            });
          };
          const useFormSize = (fallback, ignore = {}) => {
            const emptyRef = ref(void 0);
            const size = ignore.prop ? emptyRef : useProp("size");
            const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
            const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
            const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
            return computed(() => size.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
          };
          const useFormDisabled = (fallback) => {
            const disabled = useProp("disabled");
            const form = inject(formContextKey, void 0);
            return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
          };
          const isFocusable = (element) => {
            if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
              return true;
            }
            if (element.tabIndex < 0 || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true") {
              return false;
            }
            switch (element.nodeName) {
              case "A": {
                return !!element.href && element.rel !== "ignore";
              }
              case "INPUT": {
                return !(element.type === "hidden" || element.type === "file");
              }
              case "BUTTON":
              case "SELECT":
              case "TEXTAREA": {
                return true;
              }
              default: {
                return false;
              }
            }
          };
          function useFocusController(target, {
            disabled,
            beforeFocus,
            afterFocus,
            beforeBlur,
            afterBlur
          } = {}) {
            const instance = getCurrentInstance();
            const { emit: emit2 } = instance;
            const wrapperRef = shallowRef();
            const isFocused = ref(false);
            const handleFocus = (event) => {
              const cancelFocus = isFunction$1(beforeFocus) ? beforeFocus(event) : false;
              if (unref(disabled) || isFocused.value || cancelFocus)
                return;
              isFocused.value = true;
              emit2("focus", event);
              afterFocus == null ? void 0 : afterFocus();
            };
            const handleBlur = (event) => {
              var _a2;
              const cancelBlur = isFunction$1(beforeBlur) ? beforeBlur(event) : false;
              if (unref(disabled) || event.relatedTarget && ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(event.relatedTarget)) || cancelBlur)
                return;
              isFocused.value = false;
              emit2("blur", event);
              afterBlur == null ? void 0 : afterBlur();
            };
            const handleClick = (event) => {
              var _a2, _b;
              if (unref(disabled) || isFocusable(event.target) || ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(document.activeElement)) && wrapperRef.value !== document.activeElement)
                return;
              (_b = target.value) == null ? void 0 : _b.focus();
            };
            watch([wrapperRef, () => unref(disabled)], ([el, disabled2]) => {
              if (!el)
                return;
              if (disabled2) {
                el.removeAttribute("tabindex");
              } else {
                el.setAttribute("tabindex", "-1");
              }
            });
            useEventListener(wrapperRef, "focus", handleFocus, true);
            useEventListener(wrapperRef, "blur", handleBlur, true);
            useEventListener(wrapperRef, "click", handleClick, true);
            return {
              isFocused,
              wrapperRef,
              handleFocus,
              handleBlur
            };
          }
          const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
          function useComposition({
            afterComposition,
            emit: emit2
          }) {
            const isComposing = ref(false);
            const handleCompositionStart = (event) => {
              emit2 == null ? void 0 : emit2("compositionstart", event);
              isComposing.value = true;
            };
            const handleCompositionUpdate = (event) => {
              var _a2;
              emit2 == null ? void 0 : emit2("compositionupdate", event);
              const text = (_a2 = event.target) == null ? void 0 : _a2.value;
              const lastCharacter = text[text.length - 1] || "";
              isComposing.value = !isKorean(lastCharacter);
            };
            const handleCompositionEnd = (event) => {
              emit2 == null ? void 0 : emit2("compositionend", event);
              if (isComposing.value) {
                isComposing.value = false;
                nextTick(() => afterComposition(event));
              }
            };
            const handleComposition = (event) => {
              event.type === "compositionend" ? handleCompositionEnd(event) : handleCompositionUpdate(event);
            };
            return {
              isComposing,
              handleComposition,
              handleCompositionStart,
              handleCompositionUpdate,
              handleCompositionEnd
            };
          }
          function useCursor(input) {
            let selectionInfo;
            function recordCursor() {
              if (input.value == void 0)
                return;
              const { selectionStart, selectionEnd, value } = input.value;
              if (selectionStart == null || selectionEnd == null)
                return;
              const beforeTxt = value.slice(0, Math.max(0, selectionStart));
              const afterTxt = value.slice(Math.max(0, selectionEnd));
              selectionInfo = {
                selectionStart,
                selectionEnd,
                value,
                beforeTxt,
                afterTxt
              };
            }
            function setCursor() {
              if (input.value == void 0 || selectionInfo == void 0)
                return;
              const { value } = input.value;
              const { beforeTxt, afterTxt, selectionStart } = selectionInfo;
              if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
                return;
              let startPos = value.length;
              if (value.endsWith(afterTxt)) {
                startPos = value.length - afterTxt.length;
              } else if (value.startsWith(beforeTxt)) {
                startPos = beforeTxt.length;
              } else {
                const beforeLastChar = beforeTxt[selectionStart - 1];
                const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
                if (newIndex !== -1) {
                  startPos = newIndex + 1;
                }
              }
              input.value.setSelectionRange(startPos, startPos);
            }
            return [recordCursor, setCursor];
          }
          const COMPONENT_NAME$7 = "ElInput";
          const __default__$n = /* @__PURE__ */ defineComponent({
            name: COMPONENT_NAME$7,
            inheritAttrs: false
          });
          const _sfc_main$y = /* @__PURE__ */ defineComponent({
            ...__default__$n,
            props: inputProps,
            emits: inputEmits,
            setup(__props, { expose, emit: emit2 }) {
              const props = __props;
              const rawAttrs = useAttrs$1();
              const attrs = useAttrs();
              const slots = useSlots();
              const containerKls = computed(() => [
                props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
                nsInput.m(inputSize.value),
                nsInput.is("disabled", inputDisabled.value),
                nsInput.is("exceed", inputExceed.value),
                {
                  [nsInput.b("group")]: slots.prepend || slots.append,
                  [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
                  [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
                  [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value,
                  [nsInput.b("hidden")]: props.type === "hidden"
                },
                rawAttrs.class
              ]);
              const wrapperKls = computed(() => [
                nsInput.e("wrapper"),
                nsInput.is("focus", isFocused.value)
              ]);
              const { form: elForm, formItem: elFormItem } = useFormItem();
              const { inputId } = useFormItemInputId(props, {
                formItemContext: elFormItem
              });
              const inputSize = useFormSize();
              const inputDisabled = useFormDisabled();
              const nsInput = useNamespace("input");
              const nsTextarea = useNamespace("textarea");
              const input = shallowRef();
              const textarea = shallowRef();
              const hovering = ref(false);
              const passwordVisible = ref(false);
              const countStyle = ref();
              const textareaCalcStyle = shallowRef(props.inputStyle);
              const _ref = computed(() => input.value || textarea.value);
              const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
                disabled: inputDisabled,
                afterBlur() {
                  var _a2;
                  if (props.validateEvent) {
                    (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "blur").catch((err) => debugWarn());
                  }
                }
              });
              const needStatusIcon = computed(() => {
                var _a2;
                return (_a2 = elForm == null ? void 0 : elForm.statusIcon) != null ? _a2 : false;
              });
              const validateState = computed(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
              const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
              const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
              const containerStyle = computed(() => [
                rawAttrs.style
              ]);
              const textareaStyle = computed(() => [
                props.inputStyle,
                textareaCalcStyle.value,
                { resize: props.resize }
              ]);
              const nativeInputValue = computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
              const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
              const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !!nativeInputValue.value);
              const isWordLimitVisible = computed(() => props.showWordLimit && !!props.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
              const textLength = computed(() => nativeInputValue.value.length);
              const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(props.maxlength));
              const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
              const [recordCursor, setCursor] = useCursor(input);
              useResizeObserver(textarea, (entries) => {
                onceInitSizeTextarea();
                if (!isWordLimitVisible.value || props.resize !== "both")
                  return;
                const entry = entries[0];
                const { width } = entry.contentRect;
                countStyle.value = {
                  right: `calc(100% - ${width + 15 + 6}px)`
                };
              });
              const resizeTextarea = () => {
                const { type, autosize } = props;
                if (!isClient || type !== "textarea" || !textarea.value)
                  return;
                if (autosize) {
                  const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
                  const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
                  const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
                  textareaCalcStyle.value = {
                    overflowY: "hidden",
                    ...textareaStyle2
                  };
                  nextTick(() => {
                    textarea.value.offsetHeight;
                    textareaCalcStyle.value = textareaStyle2;
                  });
                } else {
                  textareaCalcStyle.value = {
                    minHeight: calcTextareaHeight(textarea.value).minHeight
                  };
                }
              };
              const createOnceInitResize = (resizeTextarea2) => {
                let isInit = false;
                return () => {
                  var _a2;
                  if (isInit || !props.autosize)
                    return;
                  const isElHidden = ((_a2 = textarea.value) == null ? void 0 : _a2.offsetParent) === null;
                  if (!isElHidden) {
                    resizeTextarea2();
                    isInit = true;
                  }
                };
              };
              const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
              const setNativeInputValue = () => {
                const input2 = _ref.value;
                const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
                if (!input2 || input2.value === formatterValue)
                  return;
                input2.value = formatterValue;
              };
              const handleInput = async (event) => {
                recordCursor();
                let { value } = event.target;
                if (props.formatter && props.parser) {
                  value = props.parser(value);
                }
                if (isComposing.value)
                  return;
                if (value === nativeInputValue.value) {
                  setNativeInputValue();
                  return;
                }
                emit2(UPDATE_MODEL_EVENT, value);
                emit2(INPUT_EVENT, value);
                await nextTick();
                setNativeInputValue();
                setCursor();
              };
              const handleChange = (event) => {
                let { value } = event.target;
                if (props.formatter && props.parser) {
                  value = props.parser(value);
                }
                emit2(CHANGE_EVENT, value);
              };
              const {
                isComposing,
                handleCompositionStart,
                handleCompositionUpdate,
                handleCompositionEnd
              } = useComposition({ emit: emit2, afterComposition: handleInput });
              const handlePasswordVisible = () => {
                recordCursor();
                passwordVisible.value = !passwordVisible.value;
                setTimeout(setCursor);
              };
              const focus = () => {
                var _a2;
                return (_a2 = _ref.value) == null ? void 0 : _a2.focus();
              };
              const blur = () => {
                var _a2;
                return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
              };
              const handleMouseLeave = (evt) => {
                hovering.value = false;
                emit2("mouseleave", evt);
              };
              const handleMouseEnter = (evt) => {
                hovering.value = true;
                emit2("mouseenter", evt);
              };
              const handleKeydown = (evt) => {
                emit2("keydown", evt);
              };
              const select = () => {
                var _a2;
                (_a2 = _ref.value) == null ? void 0 : _a2.select();
              };
              const clear = () => {
                emit2(UPDATE_MODEL_EVENT, "");
                emit2(CHANGE_EVENT, "");
                emit2("clear");
                emit2(INPUT_EVENT, "");
              };
              watch(() => props.modelValue, () => {
                var _a2;
                nextTick(() => resizeTextarea());
                if (props.validateEvent) {
                  (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
                }
              });
              watch(nativeInputValue, () => setNativeInputValue());
              watch(() => props.type, async () => {
                await nextTick();
                setNativeInputValue();
                resizeTextarea();
              });
              onMounted(() => {
                if (!props.formatter && props.parser) ;
                setNativeInputValue();
                nextTick(resizeTextarea);
              });
              expose({
                input,
                textarea,
                ref: _ref,
                textareaStyle,
                autosize: toRef(props, "autosize"),
                isComposing,
                focus,
                blur,
                select,
                clear,
                resizeTextarea
              });
              return (_ctx, _cache) => {
                return openBlock(), createElementBlock("div", {
                  class: normalizeClass([
                    unref(containerKls),
                    {
                      [unref(nsInput).bm("group", "append")]: _ctx.$slots.append,
                      [unref(nsInput).bm("group", "prepend")]: _ctx.$slots.prepend
                    }
                  ]),
                  style: normalizeStyle(unref(containerStyle)),
                  onMouseenter: handleMouseEnter,
                  onMouseleave: handleMouseLeave
                }, [
                  createCommentVNode(" input "),
                  _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createCommentVNode(" prepend slot "),
                    _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass(unref(nsInput).be("group", "prepend"))
                    }, [
                      renderSlot(_ctx.$slots, "prepend")
                    ], 2)) : createCommentVNode("v-if", true),
                    createBaseVNode("div", {
                      ref_key: "wrapperRef",
                      ref: wrapperRef,
                      class: normalizeClass(unref(wrapperKls))
                    }, [
                      createCommentVNode(" prefix slot "),
                      _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("prefix"))
                      }, [
                        createBaseVNode("span", {
                          class: normalizeClass(unref(nsInput).e("prefix-inner"))
                        }, [
                          renderSlot(_ctx.$slots, "prefix"),
                          _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                            key: 0,
                            class: normalizeClass(unref(nsInput).e("icon"))
                          }, {
                            default: withCtx(() => [
                              (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                            ]),
                            _: 1
                          }, 8, ["class"])) : createCommentVNode("v-if", true)
                        ], 2)
                      ], 2)) : createCommentVNode("v-if", true),
                      createBaseVNode("input", mergeProps({
                        id: unref(inputId),
                        ref_key: "input",
                        ref: input,
                        class: unref(nsInput).e("inner")
                      }, unref(attrs), {
                        name: _ctx.name,
                        minlength: _ctx.minlength,
                        maxlength: _ctx.maxlength,
                        type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                        disabled: unref(inputDisabled),
                        readonly: _ctx.readonly,
                        autocomplete: _ctx.autocomplete,
                        tabindex: _ctx.tabindex,
                        "aria-label": _ctx.ariaLabel,
                        placeholder: _ctx.placeholder,
                        style: _ctx.inputStyle,
                        form: _ctx.form,
                        autofocus: _ctx.autofocus,
                        role: _ctx.containerRole,
                        inputmode: _ctx.inputmode,
                        onCompositionstart: unref(handleCompositionStart),
                        onCompositionupdate: unref(handleCompositionUpdate),
                        onCompositionend: unref(handleCompositionEnd),
                        onInput: handleInput,
                        onChange: handleChange,
                        onKeydown: handleKeydown
                      }), null, 16, ["id", "name", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus", "role", "inputmode", "onCompositionstart", "onCompositionupdate", "onCompositionend"]),
                      createCommentVNode(" suffix slot "),
                      unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                        key: 1,
                        class: normalizeClass(unref(nsInput).e("suffix"))
                      }, [
                        createBaseVNode("span", {
                          class: normalizeClass(unref(nsInput).e("suffix-inner"))
                        }, [
                          !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                            renderSlot(_ctx.$slots, "suffix"),
                            _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                              key: 0,
                              class: normalizeClass(unref(nsInput).e("icon"))
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : createCommentVNode("v-if", true)
                          ], 64)) : createCommentVNode("v-if", true),
                          unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                            key: 1,
                            class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                            onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                            onClick: clear
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(circle_close_default))
                            ]),
                            _: 1
                          }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                          unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                            key: 2,
                            class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                            onClick: handlePasswordVisible
                          }, {
                            default: withCtx(() => [
                              (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                            ]),
                            _: 1
                          }, 8, ["class"])) : createCommentVNode("v-if", true),
                          unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                            key: 3,
                            class: normalizeClass(unref(nsInput).e("count"))
                          }, [
                            createBaseVNode("span", {
                              class: normalizeClass(unref(nsInput).e("count-inner"))
                            }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 3)
                          ], 2)) : createCommentVNode("v-if", true),
                          unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                            key: 4,
                            class: normalizeClass([
                              unref(nsInput).e("icon"),
                              unref(nsInput).e("validateIcon"),
                              unref(nsInput).is("loading", unref(validateState) === "validating")
                            ])
                          }, {
                            default: withCtx(() => [
                              (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                            ]),
                            _: 1
                          }, 8, ["class"])) : createCommentVNode("v-if", true)
                        ], 2)
                      ], 2)) : createCommentVNode("v-if", true)
                    ], 2),
                    createCommentVNode(" append slot "),
                    _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      class: normalizeClass(unref(nsInput).be("group", "append"))
                    }, [
                      renderSlot(_ctx.$slots, "append")
                    ], 2)) : createCommentVNode("v-if", true)
                  ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createCommentVNode(" textarea "),
                    createBaseVNode("textarea", mergeProps({
                      id: unref(inputId),
                      ref_key: "textarea",
                      ref: textarea,
                      class: [unref(nsTextarea).e("inner"), unref(nsInput).is("focus", unref(isFocused))]
                    }, unref(attrs), {
                      minlength: _ctx.minlength,
                      maxlength: _ctx.maxlength,
                      tabindex: _ctx.tabindex,
                      disabled: unref(inputDisabled),
                      readonly: _ctx.readonly,
                      autocomplete: _ctx.autocomplete,
                      style: unref(textareaStyle),
                      "aria-label": _ctx.ariaLabel,
                      placeholder: _ctx.placeholder,
                      form: _ctx.form,
                      autofocus: _ctx.autofocus,
                      rows: _ctx.rows,
                      role: _ctx.containerRole,
                      onCompositionstart: unref(handleCompositionStart),
                      onCompositionupdate: unref(handleCompositionUpdate),
                      onCompositionend: unref(handleCompositionEnd),
                      onInput: handleInput,
                      onFocus: unref(handleFocus),
                      onBlur: unref(handleBlur),
                      onChange: handleChange,
                      onKeydown: handleKeydown
                    }), null, 16, ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus", "rows", "role", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onFocus", "onBlur"]),
                    unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      style: normalizeStyle(countStyle.value),
                      class: normalizeClass(unref(nsInput).e("count"))
                    }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 7)) : createCommentVNode("v-if", true)
                  ], 64))
                ], 38);
              };
            }
          });
          var Input = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__file", "input.vue"]]);
          const ElInput = withInstall(Input);
          const POPPER_INJECTION_KEY = Symbol("popper");
          const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
          const roleTypes = [
            "dialog",
            "grid",
            "group",
            "listbox",
            "menu",
            "navigation",
            "tooltip",
            "tree"
          ];
          const popperProps = buildProps({
            role: {
              type: String,
              values: roleTypes,
              default: "tooltip"
            }
          });
          const __default__$m = /* @__PURE__ */ defineComponent({
            name: "ElPopper",
            inheritAttrs: false
          });
          const _sfc_main$x = /* @__PURE__ */ defineComponent({
            ...__default__$m,
            props: popperProps,
            setup(__props, { expose }) {
              const props = __props;
              const triggerRef2 = ref();
              const popperInstanceRef = ref();
              const contentRef = ref();
              const referenceRef = ref();
              const role = computed(() => props.role);
              const popperProvides = {
                triggerRef: triggerRef2,
                popperInstanceRef,
                contentRef,
                referenceRef,
                role
              };
              expose(popperProvides);
              provide(POPPER_INJECTION_KEY, popperProvides);
              return (_ctx, _cache) => {
                return renderSlot(_ctx.$slots, "default");
              };
            }
          });
          var Popper = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__file", "popper.vue"]]);
          const __default__$l = /* @__PURE__ */ defineComponent({
            name: "ElPopperArrow",
            inheritAttrs: false
          });
          const _sfc_main$w = /* @__PURE__ */ defineComponent({
            ...__default__$l,
            setup(__props, { expose }) {
              const ns = useNamespace("popper");
              const { arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
              onBeforeUnmount(() => {
                arrowRef.value = void 0;
              });
              expose({
                arrowRef
              });
              return (_ctx, _cache) => {
                return openBlock(), createElementBlock("span", {
                  ref_key: "arrowRef",
                  ref: arrowRef,
                  class: normalizeClass(unref(ns).e("arrow")),
                  style: normalizeStyle(unref(arrowStyle)),
                  "data-popper-arrow": ""
                }, null, 6);
              };
            }
          });
          var ElPopperArrow = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__file", "arrow.vue"]]);
          const popperTriggerProps = buildProps({
            virtualRef: {
              type: definePropType(Object)
            },
            virtualTriggering: Boolean,
            onMouseenter: {
              type: definePropType(Function)
            },
            onMouseleave: {
              type: definePropType(Function)
            },
            onClick: {
              type: definePropType(Function)
            },
            onKeydown: {
              type: definePropType(Function)
            },
            onFocus: {
              type: definePropType(Function)
            },
            onBlur: {
              type: definePropType(Function)
            },
            onContextmenu: {
              type: definePropType(Function)
            },
            id: String,
            open: Boolean
          });
          const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
          const useForwardRef = (forwardRef) => {
            const setForwardRef = (el) => {
              forwardRef.value = el;
            };
            provide(FORWARD_REF_INJECTION_KEY, {
              setForwardRef
            });
          };
          const useForwardRefDirective = (setForwardRef) => {
            return {
              mounted(el) {
                setForwardRef(el);
              },
              updated(el) {
                setForwardRef(el);
              },
              unmounted() {
                setForwardRef(null);
              }
            };
          };
          const NAME = "ElOnlyChild";
          const OnlyChild = /* @__PURE__ */ defineComponent({
            name: NAME,
            setup(_, {
              slots,
              attrs
            }) {
              var _a2;
              const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
              const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
              return () => {
                var _a22;
                const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
                if (!defaultSlot)
                  return null;
                if (defaultSlot.length > 1) {
                  return null;
                }
                const firstLegitNode = findFirstLegitChild(defaultSlot);
                if (!firstLegitNode) {
                  return null;
                }
                return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
              };
            }
          });
          function findFirstLegitChild(node) {
            if (!node)
              return null;
            const children = node;
            for (const child of children) {
              if (isObject$1(child)) {
                switch (child.type) {
                  case Comment:
                    continue;
                  case Text:
                  case "svg":
                    return wrapTextContent(child);
                  case Fragment:
                    return findFirstLegitChild(child.children);
                  default:
                    return child;
                }
              }
              return wrapTextContent(child);
            }
            return null;
          }
          function wrapTextContent(s) {
            const ns = useNamespace("only-child");
            return createVNode("span", {
              "class": ns.e("content")
            }, [s]);
          }
          const __default__$k = /* @__PURE__ */ defineComponent({
            name: "ElPopperTrigger",
            inheritAttrs: false
          });
          const _sfc_main$v = /* @__PURE__ */ defineComponent({
            ...__default__$k,
            props: popperTriggerProps,
            setup(__props, { expose }) {
              const props = __props;
              const { role, triggerRef: triggerRef2 } = inject(POPPER_INJECTION_KEY, void 0);
              useForwardRef(triggerRef2);
              const ariaControls = computed(() => {
                return ariaHaspopup.value ? props.id : void 0;
              });
              const ariaDescribedby = computed(() => {
                if (role && role.value === "tooltip") {
                  return props.open && props.id ? props.id : void 0;
                }
                return void 0;
              });
              const ariaHaspopup = computed(() => {
                if (role && role.value !== "tooltip") {
                  return role.value;
                }
                return void 0;
              });
              const ariaExpanded = computed(() => {
                return ariaHaspopup.value ? `${props.open}` : void 0;
              });
              let virtualTriggerAriaStopWatch = void 0;
              const TRIGGER_ELE_EVENTS = [
                "onMouseenter",
                "onMouseleave",
                "onClick",
                "onKeydown",
                "onFocus",
                "onBlur",
                "onContextmenu"
              ];
              onMounted(() => {
                watch(() => props.virtualRef, (virtualEl) => {
                  if (virtualEl) {
                    triggerRef2.value = unrefElement(virtualEl);
                  }
                }, {
                  immediate: true
                });
                watch(triggerRef2, (el, prevEl) => {
                  virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
                  virtualTriggerAriaStopWatch = void 0;
                  if (isElement(el)) {
                    TRIGGER_ELE_EVENTS.forEach((eventName) => {
                      var _a2;
                      const handler = props[eventName];
                      if (handler) {
                        el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                        (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                      }
                    });
                    if (isFocusable(el)) {
                      virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                        [
                          "aria-controls",
                          "aria-describedby",
                          "aria-haspopup",
                          "aria-expanded"
                        ].forEach((key, idx) => {
                          isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                        });
                      }, { immediate: true });
                    }
                  }
                  if (isElement(prevEl) && isFocusable(prevEl)) {
                    [
                      "aria-controls",
                      "aria-describedby",
                      "aria-haspopup",
                      "aria-expanded"
                    ].forEach((key) => prevEl.removeAttribute(key));
                  }
                }, {
                  immediate: true
                });
              });
              onBeforeUnmount(() => {
                virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
                virtualTriggerAriaStopWatch = void 0;
                if (triggerRef2.value && isElement(triggerRef2.value)) {
                  const el = triggerRef2.value;
                  TRIGGER_ELE_EVENTS.forEach((eventName) => {
                    const handler = props[eventName];
                    if (handler) {
                      el.removeEventListener(eventName.slice(2).toLowerCase(), handler);
                    }
                  });
                  triggerRef2.value = void 0;
                }
              });
              expose({
                triggerRef: triggerRef2
              });
              return (_ctx, _cache) => {
                return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
                  "aria-controls": unref(ariaControls),
                  "aria-describedby": unref(ariaDescribedby),
                  "aria-expanded": unref(ariaExpanded),
                  "aria-haspopup": unref(ariaHaspopup)
                }), {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
              };
            }
          });
          var ElPopperTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__file", "trigger.vue"]]);
          const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
          const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
          const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
          const FOCUS_AFTER_TRAPPED_OPTS = {
            cancelable: true,
            bubbles: false
          };
          const FOCUSOUT_PREVENTED_OPTS = {
            cancelable: true,
            bubbles: false
          };
          const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
          const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
          const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
          const focusReason = ref();
          const lastUserFocusTimestamp = ref(0);
          const lastAutomatedFocusTimestamp = ref(0);
          let focusReasonUserCount = 0;
          const obtainAllFocusableElements = (element) => {
            const nodes = [];
            const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
              acceptNode: (node) => {
                const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
                if (node.disabled || node.hidden || isHiddenInput)
                  return NodeFilter.FILTER_SKIP;
                return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
              }
            });
            while (walker.nextNode())
              nodes.push(walker.currentNode);
            return nodes;
          };
          const getVisibleElement = (elements, container) => {
            for (const element of elements) {
              if (!isHidden(element, container))
                return element;
            }
          };
          const isHidden = (element, container) => {
            if (getComputedStyle(element).visibility === "hidden")
              return true;
            while (element) {
              if (container && element === container)
                return false;
              if (getComputedStyle(element).display === "none")
                return true;
              element = element.parentElement;
            }
            return false;
          };
          const getEdges = (container) => {
            const focusable = obtainAllFocusableElements(container);
            const first = getVisibleElement(focusable, container);
            const last2 = getVisibleElement(focusable.reverse(), container);
            return [first, last2];
          };
          const isSelectable = (element) => {
            return element instanceof HTMLInputElement && "select" in element;
          };
          const tryFocus = (element, shouldSelect) => {
            if (element && element.focus) {
              const prevFocusedElement = document.activeElement;
              let cleanup = false;
              if (isElement(element) && !isFocusable(element) && !element.getAttribute("tabindex")) {
                element.setAttribute("tabindex", "-1");
                cleanup = true;
              }
              element.focus({ preventScroll: true });
              lastAutomatedFocusTimestamp.value = window.performance.now();
              if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
                element.select();
              }
              if (isElement(element) && cleanup) {
                element.removeAttribute("tabindex");
              }
            }
          };
          function removeFromStack(list, item) {
            const copy = [...list];
            const idx = list.indexOf(item);
            if (idx !== -1) {
              copy.splice(idx, 1);
            }
            return copy;
          }
          const createFocusableStack = () => {
            let stack2 = [];
            const push = (layer) => {
              const currentLayer = stack2[0];
              if (currentLayer && layer !== currentLayer) {
                currentLayer.pause();
              }
              stack2 = removeFromStack(stack2, layer);
              stack2.unshift(layer);
            };
            const remove2 = (layer) => {
              var _a2, _b;
              stack2 = removeFromStack(stack2, layer);
              (_b = (_a2 = stack2[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
            };
            return {
              push,
              remove: remove2
            };
          };
          const focusFirstDescendant = (elements, shouldSelect = false) => {
            const prevFocusedElement = document.activeElement;
            for (const element of elements) {
              tryFocus(element, shouldSelect);
              if (document.activeElement !== prevFocusedElement)
                return;
            }
          };
          const focusableStack = createFocusableStack();
          const isFocusCausedByUserEvent = () => {
            return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
          };
          const notifyFocusReasonPointer = () => {
            focusReason.value = "pointer";
            lastUserFocusTimestamp.value = window.performance.now();
          };
          const notifyFocusReasonKeydown = () => {
            focusReason.value = "keyboard";
            lastUserFocusTimestamp.value = window.performance.now();
          };
          const useFocusReason = () => {
            onMounted(() => {
              if (focusReasonUserCount === 0) {
                document.addEventListener("mousedown", notifyFocusReasonPointer);
                document.addEventListener("touchstart", notifyFocusReasonPointer);
                document.addEventListener("keydown", notifyFocusReasonKeydown);
              }
              focusReasonUserCount++;
            });
            onBeforeUnmount(() => {
              focusReasonUserCount--;
              if (focusReasonUserCount <= 0) {
                document.removeEventListener("mousedown", notifyFocusReasonPointer);
                document.removeEventListener("touchstart", notifyFocusReasonPointer);
                document.removeEventListener("keydown", notifyFocusReasonKeydown);
              }
            });
            return {
              focusReason,
              lastUserFocusTimestamp,
              lastAutomatedFocusTimestamp
            };
          };
          const createFocusOutPreventedEvent = (detail) => {
            return new CustomEvent(FOCUSOUT_PREVENTED, {
              ...FOCUSOUT_PREVENTED_OPTS,
              detail
            });
          };
          const EVENT_CODE = {
            tab: "Tab",
            enter: "Enter",
            space: "Space",
            left: "ArrowLeft",
            up: "ArrowUp",
            right: "ArrowRight",
            down: "ArrowDown",
            esc: "Escape",
            delete: "Delete",
            backspace: "Backspace",
            numpadEnter: "NumpadEnter"
          };
          let registeredEscapeHandlers = [];
          const cachedHandler = (event) => {
            if (event.code === EVENT_CODE.esc) {
              registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
            }
          };
          const useEscapeKeydown = (handler) => {
            onMounted(() => {
              if (registeredEscapeHandlers.length === 0) {
                document.addEventListener("keydown", cachedHandler);
              }
              if (isClient)
                registeredEscapeHandlers.push(handler);
            });
            onBeforeUnmount(() => {
              registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
              if (registeredEscapeHandlers.length === 0) {
                if (isClient)
                  document.removeEventListener("keydown", cachedHandler);
              }
            });
          };
          const _sfc_main$u = /* @__PURE__ */ defineComponent({
            name: "ElFocusTrap",
            inheritAttrs: false,
            props: {
              loop: Boolean,
              trapped: Boolean,
              focusTrapEl: Object,
              focusStartEl: {
                type: [Object, String],
                default: "first"
              }
            },
            emits: [
              ON_TRAP_FOCUS_EVT,
              ON_RELEASE_FOCUS_EVT,
              "focusin",
              "focusout",
              "focusout-prevented",
              "release-requested"
            ],
            setup(props, { emit: emit2 }) {
              const forwardRef = ref();
              let lastFocusBeforeTrapped;
              let lastFocusAfterTrapped;
              const { focusReason: focusReason2 } = useFocusReason();
              useEscapeKeydown((event) => {
                if (props.trapped && !focusLayer.paused) {
                  emit2("release-requested", event);
                }
              });
              const focusLayer = {
                paused: false,
                pause() {
                  this.paused = true;
                },
                resume() {
                  this.paused = false;
                }
              };
              const onKeydown = (e) => {
                if (!props.loop && !props.trapped)
                  return;
                if (focusLayer.paused)
                  return;
                const { code, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
                const { loop } = props;
                const isTabbing = code === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
                const currentFocusingEl = document.activeElement;
                if (isTabbing && currentFocusingEl) {
                  const container = currentTarget;
                  const [first, last2] = getEdges(container);
                  const isTabbable = first && last2;
                  if (!isTabbable) {
                    if (currentFocusingEl === container) {
                      const focusoutPreventedEvent = createFocusOutPreventedEvent({
                        focusReason: focusReason2.value
                      });
                      emit2("focusout-prevented", focusoutPreventedEvent);
                      if (!focusoutPreventedEvent.defaultPrevented) {
                        e.preventDefault();
                      }
                    }
                  } else {
                    if (!shiftKey && currentFocusingEl === last2) {
                      const focusoutPreventedEvent = createFocusOutPreventedEvent({
                        focusReason: focusReason2.value
                      });
                      emit2("focusout-prevented", focusoutPreventedEvent);
                      if (!focusoutPreventedEvent.defaultPrevented) {
                        e.preventDefault();
                        if (loop)
                          tryFocus(first, true);
                      }
                    } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                      const focusoutPreventedEvent = createFocusOutPreventedEvent({
                        focusReason: focusReason2.value
                      });
                      emit2("focusout-prevented", focusoutPreventedEvent);
                      if (!focusoutPreventedEvent.defaultPrevented) {
                        e.preventDefault();
                        if (loop)
                          tryFocus(last2, true);
                      }
                    }
                  }
                }
              };
              provide(FOCUS_TRAP_INJECTION_KEY, {
                focusTrapRef: forwardRef,
                onKeydown
              });
              watch(() => props.focusTrapEl, (focusTrapEl) => {
                if (focusTrapEl) {
                  forwardRef.value = focusTrapEl;
                }
              }, { immediate: true });
              watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
                if (forwardRef2) {
                  forwardRef2.addEventListener("keydown", onKeydown);
                  forwardRef2.addEventListener("focusin", onFocusIn);
                  forwardRef2.addEventListener("focusout", onFocusOut);
                }
                if (oldForwardRef) {
                  oldForwardRef.removeEventListener("keydown", onKeydown);
                  oldForwardRef.removeEventListener("focusin", onFocusIn);
                  oldForwardRef.removeEventListener("focusout", onFocusOut);
                }
              });
              const trapOnFocus = (e) => {
                emit2(ON_TRAP_FOCUS_EVT, e);
              };
              const releaseOnFocus = (e) => emit2(ON_RELEASE_FOCUS_EVT, e);
              const onFocusIn = (e) => {
                const trapContainer = unref(forwardRef);
                if (!trapContainer)
                  return;
                const target = e.target;
                const relatedTarget = e.relatedTarget;
                const isFocusedInTrap = target && trapContainer.contains(target);
                if (!props.trapped) {
                  const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
                  if (!isPrevFocusedInTrap) {
                    lastFocusBeforeTrapped = relatedTarget;
                  }
                }
                if (isFocusedInTrap)
                  emit2("focusin", e);
                if (focusLayer.paused)
                  return;
                if (props.trapped) {
                  if (isFocusedInTrap) {
                    lastFocusAfterTrapped = target;
                  } else {
                    tryFocus(lastFocusAfterTrapped, true);
                  }
                }
              };
              const onFocusOut = (e) => {
                const trapContainer = unref(forwardRef);
                if (focusLayer.paused || !trapContainer)
                  return;
                if (props.trapped) {
                  const relatedTarget = e.relatedTarget;
                  if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
                    setTimeout(() => {
                      if (!focusLayer.paused && props.trapped) {
                        const focusoutPreventedEvent = createFocusOutPreventedEvent({
                          focusReason: focusReason2.value
                        });
                        emit2("focusout-prevented", focusoutPreventedEvent);
                        if (!focusoutPreventedEvent.defaultPrevented) {
                          tryFocus(lastFocusAfterTrapped, true);
                        }
                      }
                    }, 0);
                  }
                } else {
                  const target = e.target;
                  const isFocusedInTrap = target && trapContainer.contains(target);
                  if (!isFocusedInTrap)
                    emit2("focusout", e);
                }
              };
              async function startTrap() {
                await nextTick();
                const trapContainer = unref(forwardRef);
                if (trapContainer) {
                  focusableStack.push(focusLayer);
                  const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
                  lastFocusBeforeTrapped = prevFocusedElement;
                  const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
                  if (!isPrevFocusContained) {
                    const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
                    trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                    trapContainer.dispatchEvent(focusEvent);
                    if (!focusEvent.defaultPrevented) {
                      nextTick(() => {
                        let focusStartEl = props.focusStartEl;
                        if (!isString$1(focusStartEl)) {
                          tryFocus(focusStartEl);
                          if (document.activeElement !== focusStartEl) {
                            focusStartEl = "first";
                          }
                        }
                        if (focusStartEl === "first") {
                          focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                        }
                        if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                          tryFocus(trapContainer);
                        }
                      });
                    }
                  }
                }
              }
              function stopTrap() {
                const trapContainer = unref(forwardRef);
                if (trapContainer) {
                  trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                  const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
                    ...FOCUS_AFTER_TRAPPED_OPTS,
                    detail: {
                      focusReason: focusReason2.value
                    }
                  });
                  trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
                  trapContainer.dispatchEvent(releasedEvent);
                  if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
                    tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
                  }
                  trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
                  focusableStack.remove(focusLayer);
                }
              }
              onMounted(() => {
                if (props.trapped) {
                  startTrap();
                }
                watch(() => props.trapped, (trapped) => {
                  if (trapped) {
                    startTrap();
                  } else {
                    stopTrap();
                  }
                });
              });
              onBeforeUnmount(() => {
                if (props.trapped) {
                  stopTrap();
                }
                if (forwardRef.value) {
                  forwardRef.value.removeEventListener("keydown", onKeydown);
                  forwardRef.value.removeEventListener("focusin", onFocusIn);
                  forwardRef.value.removeEventListener("focusout", onFocusOut);
                  forwardRef.value = void 0;
                }
              });
              return {
                onKeydown
              };
            }
          });
          function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
            return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
          }
          var ElFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$3], ["__file", "focus-trap.vue"]]);
          var E = "top", R = "bottom", W = "right", P = "left", me = "auto", G = [E, R, W, P], U = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e) {
            return t.concat([e + "-" + U, e + "-" + J]);
          }, []), Ee = [].concat(G, [me]).reduce(function(t, e) {
            return t.concat([e, e + "-" + U, e + "-" + J]);
          }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
          function C(t) {
            return t ? (t.nodeName || "").toLowerCase() : null;
          }
          function H(t) {
            if (t == null) return window;
            if (t.toString() !== "[object Window]") {
              var e = t.ownerDocument;
              return e && e.defaultView || window;
            }
            return t;
          }
          function Q(t) {
            var e = H(t).Element;
            return t instanceof e || t instanceof Element;
          }
          function B(t) {
            var e = H(t).HTMLElement;
            return t instanceof e || t instanceof HTMLElement;
          }
          function Pe(t) {
            if (typeof ShadowRoot == "undefined") return false;
            var e = H(t).ShadowRoot;
            return t instanceof e || t instanceof ShadowRoot;
          }
          function Mt(t) {
            var e = t.state;
            Object.keys(e.elements).forEach(function(n) {
              var r = e.styles[n] || {}, o = e.attributes[n] || {}, i = e.elements[n];
              !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function(a) {
                var s = o[a];
                s === false ? i.removeAttribute(a) : i.setAttribute(a, s === true ? "" : s);
              }));
            });
          }
          function Rt(t) {
            var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
            return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
              Object.keys(e.elements).forEach(function(r) {
                var o = e.elements[r], i = e.attributes[r] || {}, a = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s = a.reduce(function(f, c) {
                  return f[c] = "", f;
                }, {});
                !B(o) || !C(o) || (Object.assign(o.style, s), Object.keys(i).forEach(function(f) {
                  o.removeAttribute(f);
                }));
              });
            };
          }
          var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
          function q(t) {
            return t.split("-")[0];
          }
          var X = Math.max, ve = Math.min, Z = Math.round;
          function ee(t, e) {
            e === void 0 && (e = false);
            var n = t.getBoundingClientRect(), r = 1, o = 1;
            if (B(t) && e) {
              var i = t.offsetHeight, a = t.offsetWidth;
              a > 0 && (r = Z(n.width) / a || 1), i > 0 && (o = Z(n.height) / i || 1);
            }
            return { width: n.width / r, height: n.height / o, top: n.top / o, right: n.right / r, bottom: n.bottom / o, left: n.left / r, x: n.left / r, y: n.top / o };
          }
          function ke(t) {
            var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
            return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
          }
          function it(t, e) {
            var n = e.getRootNode && e.getRootNode();
            if (t.contains(e)) return true;
            if (n && Pe(n)) {
              var r = e;
              do {
                if (r && t.isSameNode(r)) return true;
                r = r.parentNode || r.host;
              } while (r);
            }
            return false;
          }
          function N(t) {
            return H(t).getComputedStyle(t);
          }
          function Wt(t) {
            return ["table", "td", "th"].indexOf(C(t)) >= 0;
          }
          function I(t) {
            return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
          }
          function ge(t) {
            return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I(t);
          }
          function at(t) {
            return !B(t) || N(t).position === "fixed" ? null : t.offsetParent;
          }
          function Bt(t) {
            var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
            if (n && B(t)) {
              var r = N(t);
              if (r.position === "fixed") return null;
            }
            var o = ge(t);
            for (Pe(o) && (o = o.host); B(o) && ["html", "body"].indexOf(C(o)) < 0; ) {
              var i = N(o);
              if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none") return o;
              o = o.parentNode;
            }
            return null;
          }
          function se(t) {
            for (var e = H(t), n = at(t); n && Wt(n) && N(n).position === "static"; ) n = at(n);
            return n && (C(n) === "html" || C(n) === "body" && N(n).position === "static") ? e : n || Bt(t) || e;
          }
          function Le(t) {
            return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
          }
          function fe(t, e, n) {
            return X(t, ve(e, n));
          }
          function St(t, e, n) {
            var r = fe(t, e, n);
            return r > n ? n : r;
          }
          function st() {
            return { top: 0, right: 0, bottom: 0, left: 0 };
          }
          function ft(t) {
            return Object.assign({}, st(), t);
          }
          function ct(t, e) {
            return e.reduce(function(n, r) {
              return n[r] = t, n;
            }, {});
          }
          var Tt = function(t, e) {
            return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
          };
          function Ht(t) {
            var e, n = t.state, r = t.name, o = t.options, i = n.elements.arrow, a = n.modifiersData.popperOffsets, s = q(n.placement), f = Le(s), c = [P, W].indexOf(s) >= 0, u = c ? "height" : "width";
            if (!(!i || !a)) {
              var m = Tt(o.padding, n), v = ke(i), l = f === "y" ? E : P, h2 = f === "y" ? R : W, p2 = n.rects.reference[u] + n.rects.reference[f] - a[f] - n.rects.popper[u], g = a[f] - n.rects.reference[f], x = se(i), y = x ? f === "y" ? x.clientHeight || 0 : x.clientWidth || 0 : 0, $ = p2 / 2 - g / 2, d = m[l], b = y - v[u] - m[h2], w = y / 2 - v[u] / 2 + $, O = fe(d, w, b), j = f;
              n.modifiersData[r] = (e = {}, e[j] = O, e.centerOffset = O - w, e);
            }
          }
          function Ct(t) {
            var e = t.state, n = t.options, r = n.element, o = r === void 0 ? "[data-popper-arrow]" : r;
            o != null && (typeof o == "string" && (o = e.elements.popper.querySelector(o), !o) || !it(e.elements.popper, o) || (e.elements.arrow = o));
          }
          var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
          function te(t) {
            return t.split("-")[1];
          }
          var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
          function Vt(t) {
            var e = t.x, n = t.y, r = window, o = r.devicePixelRatio || 1;
            return { x: Z(e * o) / o || 0, y: Z(n * o) / o || 0 };
          }
          function ut(t) {
            var e, n = t.popper, r = t.popperRect, o = t.placement, i = t.variation, a = t.offsets, s = t.position, f = t.gpuAcceleration, c = t.adaptive, u = t.roundOffsets, m = t.isFixed, v = a.x, l = v === void 0 ? 0 : v, h2 = a.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u == "function" ? u({ x: l, y: p2 }) : { x: l, y: p2 };
            l = g.x, p2 = g.y;
            var x = a.hasOwnProperty("x"), y = a.hasOwnProperty("y"), $ = P, d = E, b = window;
            if (c) {
              var w = se(n), O = "clientHeight", j = "clientWidth";
              if (w === H(n) && (w = I(n), N(w).position !== "static" && s === "absolute" && (O = "scrollHeight", j = "scrollWidth")), w = w, o === E || (o === P || o === W) && i === J) {
                d = R;
                var A = m && w === b && b.visualViewport ? b.visualViewport.height : w[O];
                p2 -= A - r.height, p2 *= f ? 1 : -1;
              }
              if (o === P || (o === E || o === R) && i === J) {
                $ = W;
                var k = m && w === b && b.visualViewport ? b.visualViewport.width : w[j];
                l -= k - r.width, l *= f ? 1 : -1;
              }
            }
            var D = Object.assign({ position: s }, c && qt), S = u === true ? Vt({ x: l, y: p2 }) : { x: l, y: p2 };
            if (l = S.x, p2 = S.y, f) {
              var L;
              return Object.assign({}, D, (L = {}, L[d] = y ? "0" : "", L[$] = x ? "0" : "", L.transform = (b.devicePixelRatio || 1) <= 1 ? "translate(" + l + "px, " + p2 + "px)" : "translate3d(" + l + "px, " + p2 + "px, 0)", L));
            }
            return Object.assign({}, D, (e = {}, e[d] = y ? p2 + "px" : "", e[$] = x ? l + "px" : "", e.transform = "", e));
          }
          function Nt(t) {
            var e = t.state, n = t.options, r = n.gpuAcceleration, o = r === void 0 ? true : r, i = n.adaptive, a = i === void 0 ? true : i, s = n.roundOffsets, f = s === void 0 ? true : s, c = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o, isFixed: e.options.strategy === "fixed" };
            e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a, roundOffsets: f })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
          }
          var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
          function It(t) {
            var e = t.state, n = t.instance, r = t.options, o = r.scroll, i = o === void 0 ? true : o, a = r.resize, s = a === void 0 ? true : a, f = H(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
            return i && c.forEach(function(u) {
              u.addEventListener("scroll", n.update, ye);
            }), s && f.addEventListener("resize", n.update, ye), function() {
              i && c.forEach(function(u) {
                u.removeEventListener("scroll", n.update, ye);
              }), s && f.removeEventListener("resize", n.update, ye);
            };
          }
          var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
          }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
          function be(t) {
            return t.replace(/left|right|bottom|top/g, function(e) {
              return _t[e];
            });
          }
          var zt = { start: "end", end: "start" };
          function lt(t) {
            return t.replace(/start|end/g, function(e) {
              return zt[e];
            });
          }
          function We(t) {
            var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
            return { scrollLeft: n, scrollTop: r };
          }
          function Be(t) {
            return ee(I(t)).left + We(t).scrollLeft;
          }
          function Ft(t) {
            var e = H(t), n = I(t), r = e.visualViewport, o = n.clientWidth, i = n.clientHeight, a = 0, s = 0;
            return r && (o = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r.offsetLeft, s = r.offsetTop)), { width: o, height: i, x: a + Be(t), y: s };
          }
          function Ut(t) {
            var e, n = I(t), r = We(t), o = (e = t.ownerDocument) == null ? void 0 : e.body, i = X(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), a = X(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), s = -r.scrollLeft + Be(t), f = -r.scrollTop;
            return N(o || n).direction === "rtl" && (s += X(n.clientWidth, o ? o.clientWidth : 0) - i), { width: i, height: a, x: s, y: f };
          }
          function Se(t) {
            var e = N(t), n = e.overflow, r = e.overflowX, o = e.overflowY;
            return /auto|scroll|overlay|hidden/.test(n + o + r);
          }
          function dt(t) {
            return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
          }
          function ce(t, e) {
            var n;
            e === void 0 && (e = []);
            var r = dt(t), o = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a = o ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s = e.concat(a);
            return o ? s : s.concat(ce(ge(a)));
          }
          function Te(t) {
            return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
          }
          function Xt(t) {
            var e = ee(t);
            return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
          }
          function ht(t, e) {
            return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I(t)));
          }
          function Yt(t) {
            var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N(t).position) >= 0, r = n && B(t) ? se(t) : t;
            return Q(r) ? e.filter(function(o) {
              return Q(o) && it(o, r) && C(o) !== "body";
            }) : [];
          }
          function Gt(t, e, n) {
            var r = e === "clippingParents" ? Yt(t) : [].concat(e), o = [].concat(r, [n]), i = o[0], a = o.reduce(function(s, f) {
              var c = ht(t, f);
              return s.top = X(c.top, s.top), s.right = ve(c.right, s.right), s.bottom = ve(c.bottom, s.bottom), s.left = X(c.left, s.left), s;
            }, ht(t, i));
            return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
          }
          function mt(t) {
            var e = t.reference, n = t.element, r = t.placement, o = r ? q(r) : null, i = r ? te(r) : null, a = e.x + e.width / 2 - n.width / 2, s = e.y + e.height / 2 - n.height / 2, f;
            switch (o) {
              case E:
                f = { x: a, y: e.y - n.height };
                break;
              case R:
                f = { x: a, y: e.y + e.height };
                break;
              case W:
                f = { x: e.x + e.width, y: s };
                break;
              case P:
                f = { x: e.x - n.width, y: s };
                break;
              default:
                f = { x: e.x, y: e.y };
            }
            var c = o ? Le(o) : null;
            if (c != null) {
              var u = c === "y" ? "height" : "width";
              switch (i) {
                case U:
                  f[c] = f[c] - (e[u] / 2 - n[u] / 2);
                  break;
                case J:
                  f[c] = f[c] + (e[u] / 2 - n[u] / 2);
                  break;
              }
            }
            return f;
          }
          function ne(t, e) {
            e === void 0 && (e = {});
            var n = e, r = n.placement, o = r === void 0 ? t.placement : r, i = n.boundary, a = i === void 0 ? Xe : i, s = n.rootBoundary, f = s === void 0 ? je : s, c = n.elementContext, u = c === void 0 ? K : c, m = n.altBoundary, v = m === void 0 ? false : m, l = n.padding, h2 = l === void 0 ? 0 : l, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u === K ? Ye : K, x = t.rects.popper, y = t.elements[v ? g : u], $ = Gt(Q(y) ? y : y.contextElement || I(t.elements.popper), a, f), d = ee(t.elements.reference), b = mt({ reference: d, element: x, placement: o }), w = Te(Object.assign({}, x, b)), O = u === K ? w : d, j = { top: $.top - O.top + p2.top, bottom: O.bottom - $.bottom + p2.bottom, left: $.left - O.left + p2.left, right: O.right - $.right + p2.right }, A = t.modifiersData.offset;
            if (u === K && A) {
              var k = A[o];
              Object.keys(j).forEach(function(D) {
                var S = [W, R].indexOf(D) >= 0 ? 1 : -1, L = [E, R].indexOf(D) >= 0 ? "y" : "x";
                j[D] += k[L] * S;
              });
            }
            return j;
          }
          function Jt(t, e) {
            e === void 0 && (e = {});
            var n = e, r = n.placement, o = n.boundary, i = n.rootBoundary, a = n.padding, s = n.flipVariations, f = n.allowedAutoPlacements, c = f === void 0 ? Ee : f, u = te(r), m = u ? s ? De : De.filter(function(h2) {
              return te(h2) === u;
            }) : G, v = m.filter(function(h2) {
              return c.indexOf(h2) >= 0;
            });
            v.length === 0 && (v = m);
            var l = v.reduce(function(h2, p2) {
              return h2[p2] = ne(t, { placement: p2, boundary: o, rootBoundary: i, padding: a })[q(p2)], h2;
            }, {});
            return Object.keys(l).sort(function(h2, p2) {
              return l[h2] - l[p2];
            });
          }
          function Kt(t) {
            if (q(t) === me) return [];
            var e = be(t);
            return [lt(t), e, lt(e)];
          }
          function Qt(t) {
            var e = t.state, n = t.options, r = t.name;
            if (!e.modifiersData[r]._skip) {
              for (var o = n.mainAxis, i = o === void 0 ? true : o, a = n.altAxis, s = a === void 0 ? true : a, f = n.fallbackPlacements, c = n.padding, u = n.boundary, m = n.rootBoundary, v = n.altBoundary, l = n.flipVariations, h2 = l === void 0 ? true : l, p2 = n.allowedAutoPlacements, g = e.options.placement, x = q(g), y = x === g, $ = f || (y || !h2 ? [be(g)] : Kt(g)), d = [g].concat($).reduce(function(z, V) {
                return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u, rootBoundary: m, padding: c, flipVariations: h2, allowedAutoPlacements: p2 }) : V);
              }, []), b = e.rects.reference, w = e.rects.popper, O = /* @__PURE__ */ new Map(), j = true, A = d[0], k = 0; k < d.length; k++) {
                var D = d[k], S = q(D), L = te(D) === U, re = [E, R].indexOf(S) >= 0, oe = re ? "width" : "height", M = ne(e, { placement: D, boundary: u, rootBoundary: m, altBoundary: v, padding: c }), T = re ? L ? W : P : L ? R : E;
                b[oe] > w[oe] && (T = be(T));
                var pe = be(T), _ = [];
                if (i && _.push(M[S] <= 0), s && _.push(M[T] <= 0, M[pe] <= 0), _.every(function(z) {
                  return z;
                })) {
                  A = D, j = false;
                  break;
                }
                O.set(D, _);
              }
              if (j) for (var ue = h2 ? 3 : 1, xe = function(z) {
                var V = d.find(function(de) {
                  var ae = O.get(de);
                  if (ae) return ae.slice(0, z).every(function(Y) {
                    return Y;
                  });
                });
                if (V) return A = V, "break";
              }, ie = ue; ie > 0; ie--) {
                var le = xe(ie);
                if (le === "break") break;
              }
              e.placement !== A && (e.modifiersData[r]._skip = true, e.placement = A, e.reset = true);
            }
          }
          var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
          function gt(t, e, n) {
            return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
          }
          function yt(t) {
            return [E, W, R, P].some(function(e) {
              return t[e] >= 0;
            });
          }
          function Zt(t) {
            var e = t.state, n = t.name, r = e.rects.reference, o = e.rects.popper, i = e.modifiersData.preventOverflow, a = ne(e, { elementContext: "reference" }), s = ne(e, { altBoundary: true }), f = gt(a, r), c = gt(s, o, i), u = yt(f), m = yt(c);
            e.modifiersData[n] = { referenceClippingOffsets: f, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: m }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": m });
          }
          var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
          function en(t, e, n) {
            var r = q(t), o = [P, E].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a = i[0], s = i[1];
            return a = a || 0, s = (s || 0) * o, [P, W].indexOf(r) >= 0 ? { x: s, y: a } : { x: a, y: s };
          }
          function tn(t) {
            var e = t.state, n = t.options, r = t.name, o = n.offset, i = o === void 0 ? [0, 0] : o, a = Ee.reduce(function(u, m) {
              return u[m] = en(m, e.rects, i), u;
            }, {}), s = a[e.placement], f = s.x, c = s.y;
            e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = a;
          }
          var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
          function nn(t) {
            var e = t.state, n = t.name;
            e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, placement: e.placement });
          }
          var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
          function rn(t) {
            return t === "x" ? "y" : "x";
          }
          function on(t) {
            var e = t.state, n = t.options, r = t.name, o = n.mainAxis, i = o === void 0 ? true : o, a = n.altAxis, s = a === void 0 ? false : a, f = n.boundary, c = n.rootBoundary, u = n.altBoundary, m = n.padding, v = n.tether, l = v === void 0 ? true : v, h2 = n.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f, rootBoundary: c, padding: m, altBoundary: u }), x = q(e.placement), y = te(e.placement), $ = !y, d = Le(x), b = rn(d), w = e.modifiersData.popperOffsets, O = e.rects.reference, j = e.rects.popper, A = typeof p2 == "function" ? p2(Object.assign({}, e.rects, { placement: e.placement })) : p2, k = typeof A == "number" ? { mainAxis: A, altAxis: A } : Object.assign({ mainAxis: 0, altAxis: 0 }, A), D = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S = { x: 0, y: 0 };
            if (w) {
              if (i) {
                var L, re = d === "y" ? E : P, oe = d === "y" ? R : W, M = d === "y" ? "height" : "width", T = w[d], pe = T + g[re], _ = T - g[oe], ue = l ? -j[M] / 2 : 0, xe = y === U ? O[M] : j[M], ie = y === U ? -j[M] : -O[M], le = e.elements.arrow, z = l && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y = fe(0, O[M], z[M]), jt = $ ? O[M] / 2 - ue - Y - de - k.mainAxis : xe - Y - de - k.mainAxis, Dt = $ ? -O[M] / 2 + ue + Y + ae + k.mainAxis : ie + Y + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D == null ? void 0 : D[d]) != null ? L : 0, Pt = T + jt - Ce - Et, At = T + Dt - Ce, qe = fe(l ? ve(pe, Pt) : pe, T, l ? X(_, At) : _);
                w[d] = qe, S[d] = qe - T;
              }
              if (s) {
                var Ve, kt = d === "x" ? E : P, Lt = d === "x" ? R : W, F = w[b], he = b === "y" ? "height" : "width", Ne = F + g[kt], Ie = F - g[Lt], $e = [E, P].indexOf(x) !== -1, _e = (Ve = D == null ? void 0 : D[b]) != null ? Ve : 0, ze = $e ? Ne : F - O[he] - j[he] - _e + k.altAxis, Fe = $e ? F + O[he] + j[he] - _e - k.altAxis : Ie, Ue = l && $e ? St(ze, F, Fe) : fe(l ? ze : Ne, F, l ? Fe : Ie);
                w[b] = Ue, S[b] = Ue - F;
              }
              e.modifiersData[r] = S;
            }
          }
          var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
          function an(t) {
            return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
          }
          function sn(t) {
            return t === H(t) || !B(t) ? We(t) : an(t);
          }
          function fn(t) {
            var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
            return n !== 1 || r !== 1;
          }
          function cn(t, e, n) {
            n === void 0 && (n = false);
            var r = B(e), o = B(e) && fn(e), i = I(e), a = ee(t, o), s = { scrollLeft: 0, scrollTop: 0 }, f = { x: 0, y: 0 };
            return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s = sn(e)), B(e) ? (f = ee(e, true), f.x += e.clientLeft, f.y += e.clientTop) : i && (f.x = Be(i))), { x: a.left + s.scrollLeft - f.x, y: a.top + s.scrollTop - f.y, width: a.width, height: a.height };
          }
          function pn(t) {
            var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
            t.forEach(function(i) {
              e.set(i.name, i);
            });
            function o(i) {
              n.add(i.name);
              var a = [].concat(i.requires || [], i.requiresIfExists || []);
              a.forEach(function(s) {
                if (!n.has(s)) {
                  var f = e.get(s);
                  f && o(f);
                }
              }), r.push(i);
            }
            return t.forEach(function(i) {
              n.has(i.name) || o(i);
            }), r;
          }
          function un(t) {
            var e = pn(t);
            return ot.reduce(function(n, r) {
              return n.concat(e.filter(function(o) {
                return o.phase === r;
              }));
            }, []);
          }
          function ln(t) {
            var e;
            return function() {
              return e || (e = new Promise(function(n) {
                Promise.resolve().then(function() {
                  e = void 0, n(t());
                });
              })), e;
            };
          }
          function dn(t) {
            var e = t.reduce(function(n, r) {
              var o = n[r.name];
              return n[r.name] = o ? Object.assign({}, o, r, { options: Object.assign({}, o.options, r.options), data: Object.assign({}, o.data, r.data) }) : r, n;
            }, {});
            return Object.keys(e).map(function(n) {
              return e[n];
            });
          }
          var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
          function $t() {
            for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
            return !e.some(function(r) {
              return !(r && typeof r.getBoundingClientRect == "function");
            });
          }
          function we(t) {
            t === void 0 && (t = {});
            var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o = e.defaultOptions, i = o === void 0 ? Ot : o;
            return function(a, s, f) {
              f === void 0 && (f = i);
              var c = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a, popper: s }, attributes: {}, styles: {} }, u = [], m = false, v = { state: c, setOptions: function(p2) {
                var g = typeof p2 == "function" ? p2(c.options) : p2;
                h2(), c.options = Object.assign({}, i, c.options, g), c.scrollParents = { reference: Q(a) ? ce(a) : a.contextElement ? ce(a.contextElement) : [], popper: ce(s) };
                var x = un(dn([].concat(r, c.options.modifiers)));
                return c.orderedModifiers = x.filter(function(y) {
                  return y.enabled;
                }), l(), v.update();
              }, forceUpdate: function() {
                if (!m) {
                  var p2 = c.elements, g = p2.reference, x = p2.popper;
                  if ($t(g, x)) {
                    c.rects = { reference: cn(g, se(x), c.options.strategy === "fixed"), popper: ke(x) }, c.reset = false, c.placement = c.options.placement, c.orderedModifiers.forEach(function(j) {
                      return c.modifiersData[j.name] = Object.assign({}, j.data);
                    });
                    for (var y = 0; y < c.orderedModifiers.length; y++) {
                      if (c.reset === true) {
                        c.reset = false, y = -1;
                        continue;
                      }
                      var $ = c.orderedModifiers[y], d = $.fn, b = $.options, w = b === void 0 ? {} : b, O = $.name;
                      typeof d == "function" && (c = d({ state: c, options: w, name: O, instance: v }) || c);
                    }
                  }
                }
              }, update: ln(function() {
                return new Promise(function(p2) {
                  v.forceUpdate(), p2(c);
                });
              }), destroy: function() {
                h2(), m = true;
              } };
              if (!$t(a, s)) return v;
              v.setOptions(f).then(function(p2) {
                !m && f.onFirstUpdate && f.onFirstUpdate(p2);
              });
              function l() {
                c.orderedModifiers.forEach(function(p2) {
                  var g = p2.name, x = p2.options, y = x === void 0 ? {} : x, $ = p2.effect;
                  if (typeof $ == "function") {
                    var d = $({ state: c, name: g, instance: v, options: y }), b = function() {
                    };
                    u.push(d || b);
                  }
                });
              }
              function h2() {
                u.forEach(function(p2) {
                  return p2();
                }), u = [];
              }
              return v;
            };
          }
          we();
          var mn = [Re, He, Me, Ae];
          we({ defaultModifiers: mn });
          var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
          const popperArrowProps = buildProps({
            arrowOffset: {
              type: Number,
              default: 5
            }
          });
          const POSITIONING_STRATEGIES = ["fixed", "absolute"];
          const popperCoreConfigProps = buildProps({
            boundariesPadding: {
              type: Number,
              default: 0
            },
            fallbackPlacements: {
              type: definePropType(Array),
              default: void 0
            },
            gpuAcceleration: {
              type: Boolean,
              default: true
            },
            offset: {
              type: Number,
              default: 12
            },
            placement: {
              type: String,
              values: Ee,
              default: "bottom"
            },
            popperOptions: {
              type: definePropType(Object),
              default: () => ({})
            },
            strategy: {
              type: String,
              values: POSITIONING_STRATEGIES,
              default: "absolute"
            }
          });
          const popperContentProps = buildProps({
            ...popperCoreConfigProps,
            ...popperArrowProps,
            id: String,
            style: {
              type: definePropType([String, Array, Object])
            },
            className: {
              type: definePropType([String, Array, Object])
            },
            effect: {
              type: definePropType(String),
              default: "dark"
            },
            visible: Boolean,
            enterable: {
              type: Boolean,
              default: true
            },
            pure: Boolean,
            focusOnShow: {
              type: Boolean,
              default: false
            },
            trapping: {
              type: Boolean,
              default: false
            },
            popperClass: {
              type: definePropType([String, Array, Object])
            },
            popperStyle: {
              type: definePropType([String, Array, Object])
            },
            referenceEl: {
              type: definePropType(Object)
            },
            triggerTargetEl: {
              type: definePropType(Object)
            },
            stopPopperMouseEvent: {
              type: Boolean,
              default: true
            },
            virtualTriggering: Boolean,
            zIndex: Number,
            ...useAriaProps(["ariaLabel"])
          });
          const popperContentEmits = {
            mouseenter: (evt) => evt instanceof MouseEvent,
            mouseleave: (evt) => evt instanceof MouseEvent,
            focus: () => true,
            blur: () => true,
            close: () => true
          };
          const usePopperContentFocusTrap = (props, emit2) => {
            const trapped = ref(false);
            const focusStartRef = ref();
            const onFocusAfterTrapped = () => {
              emit2("focus");
            };
            const onFocusAfterReleased = (event) => {
              var _a2;
              if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
                focusStartRef.value = "first";
                emit2("blur");
              }
            };
            const onFocusInTrap = (event) => {
              if (props.visible && !trapped.value) {
                if (event.target) {
                  focusStartRef.value = event.target;
                }
                trapped.value = true;
              }
            };
            const onFocusoutPrevented = (event) => {
              if (!props.trapping) {
                if (event.detail.focusReason === "pointer") {
                  event.preventDefault();
                }
                trapped.value = false;
              }
            };
            const onReleaseRequested = () => {
              trapped.value = false;
              emit2("close");
            };
            return {
              focusStartRef,
              trapped,
              onFocusAfterReleased,
              onFocusAfterTrapped,
              onFocusInTrap,
              onFocusoutPrevented,
              onReleaseRequested
            };
          };
          const buildPopperOptions = (props, modifiers = []) => {
            const { placement, strategy, popperOptions } = props;
            const options = {
              placement,
              strategy,
              ...popperOptions,
              modifiers: [...genModifiers(props), ...modifiers]
            };
            deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
            return options;
          };
          const unwrapMeasurableEl = ($el) => {
            if (!isClient)
              return;
            return unrefElement($el);
          };
          function genModifiers(options) {
            const { offset, gpuAcceleration, fallbackPlacements } = options;
            return [
              {
                name: "offset",
                options: {
                  offset: [0, offset != null ? offset : 12]
                }
              },
              {
                name: "preventOverflow",
                options: {
                  padding: {
                    top: 2,
                    bottom: 2,
                    left: 5,
                    right: 5
                  }
                }
              },
              {
                name: "flip",
                options: {
                  padding: 5,
                  fallbackPlacements
                }
              },
              {
                name: "computeStyles",
                options: {
                  gpuAcceleration
                }
              }
            ];
          }
          function deriveExtraModifiers(options, modifiers) {
            if (modifiers) {
              options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
            }
          }
          const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
            const stateUpdater = {
              name: "updateState",
              enabled: true,
              phase: "write",
              fn: ({ state }) => {
                const derivedState = deriveState(state);
                Object.assign(states.value, derivedState);
              },
              requires: ["computeStyles"]
            };
            const options = computed(() => {
              const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
              return {
                onFirstUpdate,
                placement: placement || "bottom",
                strategy: strategy || "absolute",
                modifiers: [
                  ...modifiers || [],
                  stateUpdater,
                  { name: "applyStyles", enabled: false }
                ]
              };
            });
            const instanceRef = shallowRef();
            const states = ref({
              styles: {
                popper: {
                  position: unref(options).strategy,
                  left: "0",
                  top: "0"
                },
                arrow: {
                  position: "absolute"
                }
              },
              attributes: {}
            });
            const destroy = () => {
              if (!instanceRef.value)
                return;
              instanceRef.value.destroy();
              instanceRef.value = void 0;
            };
            watch(options, (newOptions) => {
              const instance = unref(instanceRef);
              if (instance) {
                instance.setOptions(newOptions);
              }
            }, {
              deep: true
            });
            watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
              destroy();
              if (!referenceElement || !popperElement)
                return;
              instanceRef.value = yn(referenceElement, popperElement, unref(options));
            });
            onBeforeUnmount(() => {
              destroy();
            });
            return {
              state: computed(() => {
                var _a2;
                return { ...((_a2 = unref(instanceRef)) == null ? void 0 : _a2.state) || {} };
              }),
              styles: computed(() => unref(states).styles),
              attributes: computed(() => unref(states).attributes),
              update: () => {
                var _a2;
                return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.update();
              },
              forceUpdate: () => {
                var _a2;
                return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.forceUpdate();
              },
              instanceRef: computed(() => unref(instanceRef))
            };
          };
          function deriveState(state) {
            const elements = Object.keys(state.elements);
            const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
            const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
            return {
              styles,
              attributes
            };
          }
          const DEFAULT_ARROW_OFFSET = 0;
          const usePopperContent = (props) => {
            const { popperInstanceRef, contentRef, triggerRef: triggerRef2, role } = inject(POPPER_INJECTION_KEY, void 0);
            const arrowRef = ref();
            const arrowOffset = computed(() => props.arrowOffset);
            const eventListenerModifier = computed(() => {
              return {
                name: "eventListeners",
                enabled: !!props.visible
              };
            });
            const arrowModifier = computed(() => {
              var _a2;
              const arrowEl = unref(arrowRef);
              const offset = (_a2 = unref(arrowOffset)) != null ? _a2 : DEFAULT_ARROW_OFFSET;
              return {
                name: "arrow",
                enabled: !isUndefined$1(arrowEl),
                options: {
                  element: arrowEl,
                  padding: offset
                }
              };
            });
            const options = computed(() => {
              return {
                onFirstUpdate: () => {
                  update();
                },
                ...buildPopperOptions(props, [
                  unref(arrowModifier),
                  unref(eventListenerModifier)
                ])
              };
            });
            const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef2));
            const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
            watch(instanceRef, (instance) => popperInstanceRef.value = instance, {
              flush: "sync"
            });
            onMounted(() => {
              watch(() => {
                var _a2;
                return (_a2 = unref(computedReference)) == null ? void 0 : _a2.getBoundingClientRect();
              }, () => {
                update();
              });
            });
            return {
              attributes,
              arrowRef,
              contentRef,
              instanceRef,
              state,
              styles,
              role,
              forceUpdate,
              update
            };
          };
          const usePopperContentDOM = (props, {
            attributes,
            styles,
            role
          }) => {
            const { nextZIndex } = useZIndex();
            const ns = useNamespace("popper");
            const contentAttrs = computed(() => unref(attributes).popper);
            const contentZIndex = ref(isNumber(props.zIndex) ? props.zIndex : nextZIndex());
            const contentClass = computed(() => [
              ns.b(),
              ns.is("pure", props.pure),
              ns.is(props.effect),
              props.popperClass
            ]);
            const contentStyle = computed(() => {
              return [
                { zIndex: unref(contentZIndex) },
                unref(styles).popper,
                props.popperStyle || {}
              ];
            });
            const ariaModal = computed(() => role.value === "dialog" ? "false" : void 0);
            const arrowStyle = computed(() => unref(styles).arrow || {});
            const updateZIndex = () => {
              contentZIndex.value = isNumber(props.zIndex) ? props.zIndex : nextZIndex();
            };
            return {
              ariaModal,
              arrowStyle,
              contentAttrs,
              contentClass,
              contentStyle,
              contentZIndex,
              updateZIndex
            };
          };
          const __default__$j = /* @__PURE__ */ defineComponent({
            name: "ElPopperContent"
          });
          const _sfc_main$t = /* @__PURE__ */ defineComponent({
            ...__default__$j,
            props: popperContentProps,
            emits: popperContentEmits,
            setup(__props, { expose, emit: emit2 }) {
              const props = __props;
              const {
                focusStartRef,
                trapped,
                onFocusAfterReleased,
                onFocusAfterTrapped,
                onFocusInTrap,
                onFocusoutPrevented,
                onReleaseRequested
              } = usePopperContentFocusTrap(props, emit2);
              const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
              const {
                ariaModal,
                arrowStyle,
                contentAttrs,
                contentClass,
                contentStyle,
                updateZIndex
              } = usePopperContentDOM(props, {
                styles,
                attributes,
                role
              });
              const formItemContext = inject(formItemContextKey, void 0);
              provide(POPPER_CONTENT_INJECTION_KEY, {
                arrowStyle,
                arrowRef
              });
              if (formItemContext) {
                provide(formItemContextKey, {
                  ...formItemContext,
                  addInputId: NOOP,
                  removeInputId: NOOP
                });
              }
              let triggerTargetAriaStopWatch = void 0;
              const updatePopper = (shouldUpdateZIndex = true) => {
                update();
                shouldUpdateZIndex && updateZIndex();
              };
              const togglePopperAlive = () => {
                updatePopper(false);
                if (props.visible && props.focusOnShow) {
                  trapped.value = true;
                } else if (props.visible === false) {
                  trapped.value = false;
                }
              };
              onMounted(() => {
                watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
                  triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
                  triggerTargetAriaStopWatch = void 0;
                  const el = unref(triggerTargetEl || contentRef.value);
                  const prevEl = unref(prevTriggerTargetEl || contentRef.value);
                  if (isElement(el)) {
                    triggerTargetAriaStopWatch = watch([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
                      ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                        isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                      });
                    }, { immediate: true });
                  }
                  if (prevEl !== el && isElement(prevEl)) {
                    ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                      prevEl.removeAttribute(key);
                    });
                  }
                }, { immediate: true });
                watch(() => props.visible, togglePopperAlive, { immediate: true });
              });
              onBeforeUnmount(() => {
                triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
                triggerTargetAriaStopWatch = void 0;
              });
              expose({
                popperContentRef: contentRef,
                popperInstanceRef: instanceRef,
                updatePopper,
                contentStyle
              });
              return (_ctx, _cache) => {
                return openBlock(), createElementBlock("div", mergeProps({
                  ref_key: "contentRef",
                  ref: contentRef
                }, unref(contentAttrs), {
                  style: unref(contentStyle),
                  class: unref(contentClass),
                  tabindex: "-1",
                  onMouseenter: (e) => _ctx.$emit("mouseenter", e),
                  onMouseleave: (e) => _ctx.$emit("mouseleave", e)
                }), [
                  createVNode(unref(ElFocusTrap), {
                    trapped: unref(trapped),
                    "trap-on-focus-in": true,
                    "focus-trap-el": unref(contentRef),
                    "focus-start-el": unref(focusStartRef),
                    onFocusAfterTrapped: unref(onFocusAfterTrapped),
                    onFocusAfterReleased: unref(onFocusAfterReleased),
                    onFocusin: unref(onFocusInTrap),
                    onFocusoutPrevented: unref(onFocusoutPrevented),
                    onReleaseRequested: unref(onReleaseRequested)
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "default")
                    ]),
                    _: 3
                  }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
                ], 16, ["onMouseenter", "onMouseleave"]);
              };
            }
          });
          var ElPopperContent = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__file", "content.vue"]]);
          const ElPopper = withInstall(Popper);
          const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
          const teleportProps = buildProps({
            to: {
              type: definePropType([String, Object]),
              required: true
            },
            disabled: Boolean
          });
          const useTooltipContentProps = buildProps({
            ...useDelayedToggleProps,
            ...popperContentProps,
            appendTo: {
              type: teleportProps.to.type
            },
            content: {
              type: String,
              default: ""
            },
            rawContent: Boolean,
            persistent: Boolean,
            visible: {
              type: definePropType(Boolean),
              default: null
            },
            transition: String,
            teleported: {
              type: Boolean,
              default: true
            },
            disabled: Boolean,
            ...useAriaProps(["ariaLabel"])
          });
          const useTooltipTriggerProps = buildProps({
            ...popperTriggerProps,
            disabled: Boolean,
            trigger: {
              type: definePropType([String, Array]),
              default: "hover"
            },
            triggerKeys: {
              type: definePropType(Array),
              default: () => [EVENT_CODE.enter, EVENT_CODE.numpadEnter, EVENT_CODE.space]
            }
          });
          const _prop = buildProp({
            type: definePropType(Boolean),
            default: null
          });
          const _event = buildProp({
            type: definePropType(Function)
          });
          const createModelToggleComposable = (name) => {
            const updateEventKey = `update:${name}`;
            const updateEventKeyRaw = `onUpdate:${name}`;
            const useModelToggleEmits2 = [updateEventKey];
            const useModelToggleProps2 = {
              [name]: _prop,
              [updateEventKeyRaw]: _event
            };
            const useModelToggle2 = ({
              indicator,
              toggleReason,
              shouldHideWhenRouteChanges,
              shouldProceed,
              onShow,
              onHide
            }) => {
              const instance = getCurrentInstance();
              const { emit: emit2 } = instance;
              const props = instance.props;
              const hasUpdateHandler = computed(() => isFunction$1(props[updateEventKeyRaw]));
              const isModelBindingAbsent = computed(() => props[name] === null);
              const doShow = (event) => {
                if (indicator.value === true) {
                  return;
                }
                indicator.value = true;
                if (toggleReason) {
                  toggleReason.value = event;
                }
                if (isFunction$1(onShow)) {
                  onShow(event);
                }
              };
              const doHide = (event) => {
                if (indicator.value === false) {
                  return;
                }
                indicator.value = false;
                if (toggleReason) {
                  toggleReason.value = event;
                }
                if (isFunction$1(onHide)) {
                  onHide(event);
                }
              };
              const show = (event) => {
                if (props.disabled === true || isFunction$1(shouldProceed) && !shouldProceed())
                  return;
                const shouldEmit = hasUpdateHandler.value && isClient;
                if (shouldEmit) {
                  emit2(updateEventKey, true);
                }
                if (isModelBindingAbsent.value || !shouldEmit) {
                  doShow(event);
                }
              };
              const hide = (event) => {
                if (props.disabled === true || !isClient)
                  return;
                const shouldEmit = hasUpdateHandler.value && isClient;
                if (shouldEmit) {
                  emit2(updateEventKey, false);
                }
                if (isModelBindingAbsent.value || !shouldEmit) {
                  doHide(event);
                }
              };
              const onChange = (val) => {
                if (!isBoolean(val))
                  return;
                if (props.disabled && val) {
                  if (hasUpdateHandler.value) {
                    emit2(updateEventKey, false);
                  }
                } else if (indicator.value !== val) {
                  if (val) {
                    doShow();
                  } else {
                    doHide();
                  }
                }
              };
              const toggle = () => {
                if (indicator.value) {
                  hide();
                } else {
                  show();
                }
              };
              watch(() => props[name], onChange);
              if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
                watch(() => ({
                  ...instance.proxy.$route
                }), () => {
                  if (shouldHideWhenRouteChanges.value && indicator.value) {
                    hide();
                  }
                });
              }
              onMounted(() => {
                onChange(props[name]);
              });
              return {
                hide,
                show,
                toggle,
                hasUpdateHandler
              };
            };
            return {
              useModelToggle: useModelToggle2,
              useModelToggleProps: useModelToggleProps2,
              useModelToggleEmits: useModelToggleEmits2
            };
          };
          const {
            useModelToggleProps: useTooltipModelToggleProps,
            useModelToggleEmits: useTooltipModelToggleEmits,
            useModelToggle: useTooltipModelToggle
          } = createModelToggleComposable("visible");
          const useTooltipProps = buildProps({
            ...popperProps,
            ...useTooltipModelToggleProps,
            ...useTooltipContentProps,
            ...useTooltipTriggerProps,
            ...popperArrowProps,
            showArrow: {
              type: Boolean,
              default: true
            }
          });
          const tooltipEmits = [
            ...useTooltipModelToggleEmits,
            "before-show",
            "before-hide",
            "show",
            "hide",
            "open",
            "close"
          ];
          const isTriggerType = (trigger2, type) => {
            if (isArray$1(trigger2)) {
              return trigger2.includes(type);
            }
            return trigger2 === type;
          };
          const whenTrigger = (trigger2, type, handler) => {
            return (e) => {
              isTriggerType(unref(trigger2), type) && handler(e);
            };
          };
          const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
            const handleEvent = (event) => {
              const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
              if (checkForDefaultPrevented === false || !shouldPrevent) {
                return oursHandler == null ? void 0 : oursHandler(event);
              }
            };
            return handleEvent;
          };
          const __default__$i = /* @__PURE__ */ defineComponent({
            name: "ElTooltipTrigger"
          });
          const _sfc_main$s = /* @__PURE__ */ defineComponent({
            ...__default__$i,
            props: useTooltipTriggerProps,
            setup(__props, { expose }) {
              const props = __props;
              const ns = useNamespace("tooltip");
              const { controlled, id, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
              const triggerRef2 = ref(null);
              const stopWhenControlledOrDisabled = () => {
                if (unref(controlled) || props.disabled) {
                  return true;
                }
              };
              const trigger2 = toRef(props, "trigger");
              const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onOpen));
              const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onClose));
              const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "click", (e) => {
                if (e.button === 0) {
                  onToggle(e);
                }
              }));
              const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onOpen));
              const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onClose));
              const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "contextmenu", (e) => {
                e.preventDefault();
                onToggle(e);
              }));
              const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
                const { code } = e;
                if (props.triggerKeys.includes(code)) {
                  e.preventDefault();
                  onToggle(e);
                }
              });
              expose({
                triggerRef: triggerRef2
              });
              return (_ctx, _cache) => {
                return openBlock(), createBlock(unref(ElPopperTrigger), {
                  id: unref(id),
                  "virtual-ref": _ctx.virtualRef,
                  open: unref(open),
                  "virtual-triggering": _ctx.virtualTriggering,
                  class: normalizeClass(unref(ns).e("trigger")),
                  onBlur: unref(onBlur),
                  onClick: unref(onClick),
                  onContextmenu: unref(onContextMenu),
                  onFocus: unref(onFocus),
                  onMouseenter: unref(onMouseenter),
                  onMouseleave: unref(onMouseleave),
                  onKeydown: unref(onKeydown)
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
              };
            }
          });
          var ElTooltipTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__file", "trigger.vue"]]);
          const _sfc_main$r = /* @__PURE__ */ defineComponent({
            __name: "teleport",
            props: teleportProps,
            setup(__props) {
              return (_ctx, _cache) => {
                return _ctx.disabled ? renderSlot(_ctx.$slots, "default", { key: 0 }) : (openBlock(), createBlock(Teleport$1, {
                  key: 1,
                  to: _ctx.to
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 8, ["to"]));
              };
            }
          });
          var Teleport = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__file", "teleport.vue"]]);
          const ElTeleport = withInstall(Teleport);
          const usePopperContainerId = () => {
            const namespace = useGetDerivedNamespace();
            const idInjection = useIdInjection();
            const id = computed(() => {
              return `${namespace.value}-popper-container-${idInjection.prefix}`;
            });
            const selector = computed(() => `#${id.value}`);
            return {
              id,
              selector
            };
          };
          const createContainer = (id) => {
            const container = document.createElement("div");
            container.id = id;
            document.body.appendChild(container);
            return container;
          };
          const usePopperContainer = () => {
            const { id, selector } = usePopperContainerId();
            onBeforeMount(() => {
              if (!isClient)
                return;
              if (!document.body.querySelector(selector.value)) {
                createContainer(id.value);
              }
            });
            return {
              id,
              selector
            };
          };
          const __default__$h = /* @__PURE__ */ defineComponent({
            name: "ElTooltipContent",
            inheritAttrs: false
          });
          const _sfc_main$q = /* @__PURE__ */ defineComponent({
            ...__default__$h,
            props: useTooltipContentProps,
            setup(__props, { expose }) {
              const props = __props;
              const { selector } = usePopperContainerId();
              const ns = useNamespace("tooltip");
              const contentRef = ref();
              const popperContentRef = computedEager(() => {
                var _a2;
                return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
              });
              let stopHandle;
              const {
                controlled,
                id,
                open,
                trigger: trigger2,
                onClose,
                onOpen,
                onShow,
                onHide,
                onBeforeShow,
                onBeforeHide
              } = inject(TOOLTIP_INJECTION_KEY, void 0);
              const transitionClass = computed(() => {
                return props.transition || `${ns.namespace.value}-fade-in-linear`;
              });
              const persistentRef = computed(() => {
                return props.persistent;
              });
              onBeforeUnmount(() => {
                stopHandle == null ? void 0 : stopHandle();
              });
              const shouldRender = computed(() => {
                return unref(persistentRef) ? true : unref(open);
              });
              const shouldShow = computed(() => {
                return props.disabled ? false : unref(open);
              });
              const appendTo = computed(() => {
                return props.appendTo || selector.value;
              });
              const contentStyle = computed(() => {
                var _a2;
                return (_a2 = props.style) != null ? _a2 : {};
              });
              const ariaHidden = ref(true);
              const onTransitionLeave = () => {
                onHide();
                isFocusInsideContent() && tryFocus(document.body);
                ariaHidden.value = true;
              };
              const stopWhenControlled = () => {
                if (unref(controlled))
                  return true;
              };
              const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
                if (props.enterable && unref(trigger2) === "hover") {
                  onOpen();
                }
              });
              const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
                if (unref(trigger2) === "hover") {
                  onClose();
                }
              });
              const onBeforeEnter = () => {
                var _a2, _b;
                (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
                onBeforeShow == null ? void 0 : onBeforeShow();
              };
              const onBeforeLeave = () => {
                onBeforeHide == null ? void 0 : onBeforeHide();
              };
              const onAfterShow = () => {
                onShow();
              };
              const onBlur = () => {
                if (!props.virtualTriggering) {
                  onClose();
                }
              };
              const isFocusInsideContent = (event) => {
                var _a2;
                const popperContent = (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
                const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
                return popperContent == null ? void 0 : popperContent.contains(activeElement);
              };
              watch(() => unref(open), (val) => {
                if (!val) {
                  stopHandle == null ? void 0 : stopHandle();
                } else {
                  ariaHidden.value = false;
                  stopHandle = onClickOutside(popperContentRef, () => {
                    if (unref(controlled))
                      return;
                    const $trigger = unref(trigger2);
                    if ($trigger !== "hover") {
                      onClose();
                    }
                  });
                }
              }, {
                flush: "post"
              });
              watch(() => props.content, () => {
                var _a2, _b;
                (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
              });
              expose({
                contentRef,
                isFocusInsideContent
              });
              return (_ctx, _cache) => {
                return openBlock(), createBlock(unref(ElTeleport), {
                  disabled: !_ctx.teleported,
                  to: unref(appendTo)
                }, {
                  default: withCtx(() => [
                    createVNode(Transition, {
                      name: unref(transitionClass),
                      onAfterLeave: onTransitionLeave,
                      onBeforeEnter,
                      onAfterEnter: onAfterShow,
                      onBeforeLeave
                    }, {
                      default: withCtx(() => [
                        unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
                          key: 0,
                          id: unref(id),
                          ref_key: "contentRef",
                          ref: contentRef
                        }, _ctx.$attrs, {
                          "aria-label": _ctx.ariaLabel,
                          "aria-hidden": ariaHidden.value,
                          "boundaries-padding": _ctx.boundariesPadding,
                          "fallback-placements": _ctx.fallbackPlacements,
                          "gpu-acceleration": _ctx.gpuAcceleration,
                          offset: _ctx.offset,
                          placement: _ctx.placement,
                          "popper-options": _ctx.popperOptions,
                          "arrow-offset": _ctx.arrowOffset,
                          strategy: _ctx.strategy,
                          effect: _ctx.effect,
                          enterable: _ctx.enterable,
                          pure: _ctx.pure,
                          "popper-class": _ctx.popperClass,
                          "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                          "reference-el": _ctx.referenceEl,
                          "trigger-target-el": _ctx.triggerTargetEl,
                          visible: unref(shouldShow),
                          "z-index": _ctx.zIndex,
                          onMouseenter: unref(onContentEnter),
                          onMouseleave: unref(onContentLeave),
                          onBlur,
                          onClose: unref(onClose)
                        }), {
                          default: withCtx(() => [
                            renderSlot(_ctx.$slots, "default")
                          ]),
                          _: 3
                        }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "arrow-offset", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                          [vShow, unref(shouldShow)]
                        ]) : createCommentVNode("v-if", true)
                      ]),
                      _: 3
                    }, 8, ["name"])
                  ]),
                  _: 3
                }, 8, ["disabled", "to"]);
              };
            }
          });
          var ElTooltipContent = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__file", "content.vue"]]);
          const __default__$g = /* @__PURE__ */ defineComponent({
            name: "ElTooltip"
          });
          const _sfc_main$p = /* @__PURE__ */ defineComponent({
            ...__default__$g,
            props: useTooltipProps,
            emits: tooltipEmits,
            setup(__props, { expose, emit: emit2 }) {
              const props = __props;
              usePopperContainer();
              const ns = useNamespace("tooltip");
              const id = useId();
              const popperRef = ref();
              const contentRef = ref();
              const updatePopper = () => {
                var _a2;
                const popperComponent = unref(popperRef);
                if (popperComponent) {
                  (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
                }
              };
              const open = ref(false);
              const toggleReason = ref();
              const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
                indicator: open,
                toggleReason
              });
              const { onOpen, onClose } = useDelayedToggle({
                showAfter: toRef(props, "showAfter"),
                hideAfter: toRef(props, "hideAfter"),
                autoClose: toRef(props, "autoClose"),
                open: show,
                close: hide
              });
              const controlled = computed(() => isBoolean(props.visible) && !hasUpdateHandler.value);
              const kls = computed(() => {
                return [ns.b(), props.popperClass];
              });
              provide(TOOLTIP_INJECTION_KEY, {
                controlled,
                id,
                open: readonly(open),
                trigger: toRef(props, "trigger"),
                onOpen: (event) => {
                  onOpen(event);
                },
                onClose: (event) => {
                  onClose(event);
                },
                onToggle: (event) => {
                  if (unref(open)) {
                    onClose(event);
                  } else {
                    onOpen(event);
                  }
                },
                onShow: () => {
                  emit2("show", toggleReason.value);
                },
                onHide: () => {
                  emit2("hide", toggleReason.value);
                },
                onBeforeShow: () => {
                  emit2("before-show", toggleReason.value);
                },
                onBeforeHide: () => {
                  emit2("before-hide", toggleReason.value);
                },
                updatePopper
              });
              watch(() => props.disabled, (disabled) => {
                if (disabled && open.value) {
                  open.value = false;
                }
              });
              const isFocusInsideContent = (event) => {
                var _a2;
                return (_a2 = contentRef.value) == null ? void 0 : _a2.isFocusInsideContent(event);
              };
              onDeactivated(() => open.value && hide());
              expose({
                popperRef,
                contentRef,
                isFocusInsideContent,
                updatePopper,
                onOpen,
                onClose,
                hide
              });
              return (_ctx, _cache) => {
                return openBlock(), createBlock(unref(ElPopper), {
                  ref_key: "popperRef",
                  ref: popperRef,
                  role: _ctx.role
                }, {
                  default: withCtx(() => [
                    createVNode(ElTooltipTrigger, {
                      disabled: _ctx.disabled,
                      trigger: _ctx.trigger,
                      "trigger-keys": _ctx.triggerKeys,
                      "virtual-ref": _ctx.virtualRef,
                      "virtual-triggering": _ctx.virtualTriggering
                    }, {
                      default: withCtx(() => [
                        _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                      ]),
                      _: 3
                    }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
                    createVNode(ElTooltipContent, {
                      ref_key: "contentRef",
                      ref: contentRef,
                      "aria-label": _ctx.ariaLabel,
                      "boundaries-padding": _ctx.boundariesPadding,
                      content: _ctx.content,
                      disabled: _ctx.disabled,
                      effect: _ctx.effect,
                      enterable: _ctx.enterable,
                      "fallback-placements": _ctx.fallbackPlacements,
                      "hide-after": _ctx.hideAfter,
                      "gpu-acceleration": _ctx.gpuAcceleration,
                      offset: _ctx.offset,
                      persistent: _ctx.persistent,
                      "popper-class": unref(kls),
                      "popper-style": _ctx.popperStyle,
                      placement: _ctx.placement,
                      "popper-options": _ctx.popperOptions,
                      "arrow-offset": _ctx.arrowOffset,
                      pure: _ctx.pure,
                      "raw-content": _ctx.rawContent,
                      "reference-el": _ctx.referenceEl,
                      "trigger-target-el": _ctx.triggerTargetEl,
                      "show-after": _ctx.showAfter,
                      strategy: _ctx.strategy,
                      teleported: _ctx.teleported,
                      transition: _ctx.transition,
                      "virtual-triggering": _ctx.virtualTriggering,
                      "z-index": _ctx.zIndex,
                      "append-to": _ctx.appendTo
                    }, {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "content", {}, () => [
                          _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                            key: 0,
                            innerHTML: _ctx.content
                          }, null, 8, ["innerHTML"])) : (openBlock(), createElementBlock("span", { key: 1 }, toDisplayString(_ctx.content), 1))
                        ]),
                        _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), { key: 0 })) : createCommentVNode("v-if", true)
                      ]),
                      _: 3
                    }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "arrow-offset", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
                  ]),
                  _: 3
                }, 8, ["role"]);
              };
            }
          });
          var Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__file", "tooltip.vue"]]);
          const ElTooltip = withInstall(Tooltip);
          const badgeProps = buildProps({
            value: {
              type: [String, Number],
              default: ""
            },
            max: {
              type: Number,
              default: 99
            },
            isDot: Boolean,
            hidden: Boolean,
            type: {
              type: String,
              values: ["primary", "success", "warning", "info", "danger"],
              default: "danger"
            },
            showZero: {
              type: Boolean,
              default: true
            },
            color: String,
            badgeStyle: {
              type: definePropType([String, Object, Array])
            },
            offset: {
              type: definePropType(Array),
              default: [0, 0]
            },
            badgeClass: {
              type: String
            }
          });
          const __default__$f = /* @__PURE__ */ defineComponent({
            name: "ElBadge"
          });
          const _sfc_main$o = /* @__PURE__ */ defineComponent({
            ...__default__$f,
            props: badgeProps,
            setup(__props, { expose }) {
              const props = __props;
              const ns = useNamespace("badge");
              const content = computed(() => {
                if (props.isDot)
                  return "";
                if (isNumber(props.value) && isNumber(props.max)) {
                  return props.max < props.value ? `${props.max}+` : `${props.value}`;
                }
                return `${props.value}`;
              });
              const style = computed(() => {
                var _a2, _b, _c, _d, _e;
                return [
                  {
                    backgroundColor: props.color,
                    marginRight: addUnit(-((_b = (_a2 = props.offset) == null ? void 0 : _a2[0]) != null ? _b : 0)),
                    marginTop: addUnit((_d = (_c = props.offset) == null ? void 0 : _c[1]) != null ? _d : 0)
                  },
                  (_e = props.badgeStyle) != null ? _e : {}
                ];
              });
              expose({
                content
              });
              return (_ctx, _cache) => {
                return openBlock(), createElementBlock("div", {
                  class: normalizeClass(unref(ns).b())
                }, [
                  renderSlot(_ctx.$slots, "default"),
                  createVNode(Transition, {
                    name: `${unref(ns).namespace.value}-zoom-in-center`,
                    persisted: ""
                  }, {
                    default: withCtx(() => [
                      withDirectives(createBaseVNode("sup", {
                        class: normalizeClass([
                          unref(ns).e("content"),
                          unref(ns).em("content", _ctx.type),
                          unref(ns).is("fixed", !!_ctx.$slots.default),
                          unref(ns).is("dot", _ctx.isDot),
                          unref(ns).is("hide-zero", !_ctx.showZero && props.value === 0),
                          _ctx.badgeClass
                        ]),
                        style: normalizeStyle(unref(style))
                      }, [
                        renderSlot(_ctx.$slots, "content", { value: unref(content) }, () => [
                          createTextVNode(toDisplayString(unref(content)), 1)
                        ])
                      ], 6), [
                        [vShow, !_ctx.hidden && (unref(content) || _ctx.isDot || _ctx.$slots.content)]
                      ])
                    ]),
                    _: 3
                  }, 8, ["name"])
                ], 2);
              };
            }
          });
          var Badge = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__file", "badge.vue"]]);
          const ElBadge = withInstall(Badge);
          const buttonGroupContextKey = Symbol("buttonGroupContextKey");
          const useDeprecated = ({ from, replacement, scope, version: version2, ref: ref2, type = "API" }, condition) => {
            watch(() => unref(condition), (val) => {
            }, {
              immediate: true
            });
          };
          const useButton = (props, emit2) => {
            useDeprecated({
              from: "type.text",
              replacement: "link",
              version: "3.0.0",
              scope: "props",
              ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
            }, computed(() => props.type === "text"));
            const buttonGroupContext = inject(buttonGroupContextKey, void 0);
            const globalConfig2 = useGlobalConfig("button");
            const { form } = useFormItem();
            const _size = useFormSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
            const _disabled = useFormDisabled();
            const _ref = ref();
            const slots = useSlots();
            const _type = computed(() => {
              var _a2;
              return props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || ((_a2 = globalConfig2.value) == null ? void 0 : _a2.type) || "";
            });
            const autoInsertSpace = computed(() => {
              var _a2, _b, _c;
              return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
            });
            const _plain = computed(() => {
              var _a2, _b, _c;
              return (_c = (_b = props.plain) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.plain) != null ? _c : false;
            });
            const _round = computed(() => {
              var _a2, _b, _c;
              return (_c = (_b = props.round) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.round) != null ? _c : false;
            });
            const _props = computed(() => {
              if (props.tag === "button") {
                return {
                  ariaDisabled: _disabled.value || props.loading,
                  disabled: _disabled.value || props.loading,
                  autofocus: props.autofocus,
                  type: props.nativeType
                };
              }
              return {};
            });
            const shouldAddSpace = computed(() => {
              var _a2;
              const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
              if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
                const slot = defaultSlot[0];
                if ((slot == null ? void 0 : slot.type) === Text) {
                  const text = slot.children;
                  return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(text.trim());
                }
              }
              return false;
            });
            const handleClick = (evt) => {
              if (_disabled.value || props.loading) {
                evt.stopPropagation();
                return;
              }
              if (props.nativeType === "reset") {
                form == null ? void 0 : form.resetFields();
              }
              emit2("click", evt);
            };
            return {
              _disabled,
              _size,
              _type,
              _ref,
              _props,
              _plain,
              _round,
              shouldAddSpace,
              handleClick
            };
          };
          const buttonTypes = [
            "default",
            "primary",
            "success",
            "warning",
            "info",
            "danger",
            "text",
            ""
          ];
          const buttonNativeTypes = ["button", "submit", "reset"];
          const buttonProps = buildProps({
            size: useSizeProp,
            disabled: Boolean,
            type: {
              type: String,
              values: buttonTypes,
              default: ""
            },
            icon: {
              type: iconPropType
            },
            nativeType: {
              type: String,
              values: buttonNativeTypes,
              default: "button"
            },
            loading: Boolean,
            loadingIcon: {
              type: iconPropType,
              default: () => loading_default
            },
            plain: {
              type: Boolean,
              default: void 0
            },
            text: Boolean,
            link: Boolean,
            bg: Boolean,
            autofocus: Boolean,
            round: {
              type: Boolean,
              default: void 0
            },
            circle: Boolean,
            color: String,
            dark: Boolean,
            autoInsertSpace: {
              type: Boolean,
              default: void 0
            },
            tag: {
              type: definePropType([String, Object]),
              default: "button"
            }
          });
          const buttonEmits = {
            click: (evt) => evt instanceof MouseEvent
          };
          function bound01(n, max) {
            if (isOnePointZero(n)) {
              n = "100%";
            }
            var isPercent = isPercentage(n);
            n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
            if (isPercent) {
              n = parseInt(String(n * max), 10) / 100;
            }
            if (Math.abs(n - max) < 1e-6) {
              return 1;
            }
            if (max === 360) {
              n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
            } else {
              n = n % max / parseFloat(String(max));
            }
            return n;
          }
          function clamp01(val) {
            return Math.min(1, Math.max(0, val));
          }
          function isOnePointZero(n) {
            return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
          }
          function isPercentage(n) {
            return typeof n === "string" && n.indexOf("%") !== -1;
          }
          function boundAlpha(a) {
            a = parseFloat(a);
            if (isNaN(a) || a < 0 || a > 1) {
              a = 1;
            }
            return a;
          }
          function convertToPercentage(n) {
            if (n <= 1) {
              return "".concat(Number(n) * 100, "%");
            }
            return n;
          }
          function pad2(c) {
            return c.length === 1 ? "0" + c : String(c);
          }
          function rgbToRgb(r, g, b) {
            return {
              r: bound01(r, 255) * 255,
              g: bound01(g, 255) * 255,
              b: bound01(b, 255) * 255
            };
          }
          function rgbToHsl(r, g, b) {
            r = bound01(r, 255);
            g = bound01(g, 255);
            b = bound01(b, 255);
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var h2 = 0;
            var s = 0;
            var l = (max + min) / 2;
            if (max === min) {
              s = 0;
              h2 = 0;
            } else {
              var d = max - min;
              s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
              switch (max) {
                case r:
                  h2 = (g - b) / d + (g < b ? 6 : 0);
                  break;
                case g:
                  h2 = (b - r) / d + 2;
                  break;
                case b:
                  h2 = (r - g) / d + 4;
                  break;
              }
              h2 /= 6;
            }
            return { h: h2, s, l };
          }
          function hue2rgb(p2, q2, t) {
            if (t < 0) {
              t += 1;
            }
            if (t > 1) {
              t -= 1;
            }
            if (t < 1 / 6) {
              return p2 + (q2 - p2) * (6 * t);
            }
            if (t < 1 / 2) {
              return q2;
            }
            if (t < 2 / 3) {
              return p2 + (q2 - p2) * (2 / 3 - t) * 6;
            }
            return p2;
          }
          function hslToRgb(h2, s, l) {
            var r;
            var g;
            var b;
            h2 = bound01(h2, 360);
            s = bound01(s, 100);
            l = bound01(l, 100);
            if (s === 0) {
              g = l;
              b = l;
              r = l;
            } else {
              var q2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
              var p2 = 2 * l - q2;
              r = hue2rgb(p2, q2, h2 + 1 / 3);
              g = hue2rgb(p2, q2, h2);
              b = hue2rgb(p2, q2, h2 - 1 / 3);
            }
            return { r: r * 255, g: g * 255, b: b * 255 };
          }
          function rgbToHsv(r, g, b) {
            r = bound01(r, 255);
            g = bound01(g, 255);
            b = bound01(b, 255);
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var h2 = 0;
            var v = max;
            var d = max - min;
            var s = max === 0 ? 0 : d / max;
            if (max === min) {
              h2 = 0;
            } else {
              switch (max) {
                case r:
                  h2 = (g - b) / d + (g < b ? 6 : 0);
                  break;
                case g:
                  h2 = (b - r) / d + 2;
                  break;
                case b:
                  h2 = (r - g) / d + 4;
                  break;
              }
              h2 /= 6;
            }
            return { h: h2, s, v };
          }
          function hsvToRgb(h2, s, v) {
            h2 = bound01(h2, 360) * 6;
            s = bound01(s, 100);
            v = bound01(v, 100);
            var i = Math.floor(h2);
            var f = h2 - i;
            var p2 = v * (1 - s);
            var q2 = v * (1 - f * s);
            var t = v * (1 - (1 - f) * s);
            var mod = i % 6;
            var r = [v, q2, p2, p2, t, v][mod];
            var g = [t, v, v, q2, p2, p2][mod];
            var b = [p2, p2, t, v, v, q2][mod];
            return { r: r * 255, g: g * 255, b: b * 255 };
          }
          function rgbToHex(r, g, b, allow3Char) {
            var hex = [
              pad2(Math.round(r).toString(16)),
              pad2(Math.round(g).toString(16)),
              pad2(Math.round(b).toString(16))
            ];
            if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
              return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
            }
            return hex.join("");
          }
          function rgbaToHex(r, g, b, a, allow4Char) {
            var hex = [
              pad2(Math.round(r).toString(16)),
              pad2(Math.round(g).toString(16)),
              pad2(Math.round(b).toString(16)),
              pad2(convertDecimalToHex(a))
            ];
            if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
              return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
            }
            return hex.join("");
          }
          function convertDecimalToHex(d) {
            return Math.round(parseFloat(d) * 255).toString(16);
          }
          function convertHexToDecimal(h2) {
            return parseIntFromHex(h2) / 255;
          }
          function parseIntFromHex(val) {
            return parseInt(val, 16);
          }
          function numberInputToObject(color) {
            return {
              r: color >> 16,
              g: (color & 65280) >> 8,
              b: color & 255
            };
          }
          var names = {
            aliceblue: "#f0f8ff",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            aquamarine: "#7fffd4",
            azure: "#f0ffff",
            beige: "#f5f5dc",
            bisque: "#ffe4c4",
            black: "#000000",
            blanchedalmond: "#ffebcd",
            blue: "#0000ff",
            blueviolet: "#8a2be2",
            brown: "#a52a2a",
            burlywood: "#deb887",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            cornflowerblue: "#6495ed",
            cornsilk: "#fff8dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkgrey: "#a9a9a9",
            darkkhaki: "#bdb76b",
            darkmagenta: "#8b008b",
            darkolivegreen: "#556b2f",
            darkorange: "#ff8c00",
            darkorchid: "#9932cc",
            darkred: "#8b0000",
            darksalmon: "#e9967a",
            darkseagreen: "#8fbc8f",
            darkslateblue: "#483d8b",
            darkslategray: "#2f4f4f",
            darkslategrey: "#2f4f4f",
            darkturquoise: "#00ced1",
            darkviolet: "#9400d3",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            dimgray: "#696969",
            dimgrey: "#696969",
            dodgerblue: "#1e90ff",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            forestgreen: "#228b22",
            fuchsia: "#ff00ff",
            gainsboro: "#dcdcdc",
            ghostwhite: "#f8f8ff",
            goldenrod: "#daa520",
            gold: "#ffd700",
            gray: "#808080",
            green: "#008000",
            greenyellow: "#adff2f",
            grey: "#808080",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            ivory: "#fffff0",
            khaki: "#f0e68c",
            lavenderblush: "#fff0f5",
            lavender: "#e6e6fa",
            lawngreen: "#7cfc00",
            lemonchiffon: "#fffacd",
            lightblue: "#add8e6",
            lightcoral: "#f08080",
            lightcyan: "#e0ffff",
            lightgoldenrodyellow: "#fafad2",
            lightgray: "#d3d3d3",
            lightgreen: "#90ee90",
            lightgrey: "#d3d3d3",
            lightpink: "#ffb6c1",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            lightskyblue: "#87cefa",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            lightsteelblue: "#b0c4de",
            lightyellow: "#ffffe0",
            lime: "#00ff00",
            limegreen: "#32cd32",
            linen: "#faf0e6",
            magenta: "#ff00ff",
            maroon: "#800000",
            mediumaquamarine: "#66cdaa",
            mediumblue: "#0000cd",
            mediumorchid: "#ba55d3",
            mediumpurple: "#9370db",
            mediumseagreen: "#3cb371",
            mediumslateblue: "#7b68ee",
            mediumspringgreen: "#00fa9a",
            mediumturquoise: "#48d1cc",
            mediumvioletred: "#c71585",
            midnightblue: "#191970",
            mintcream: "#f5fffa",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            navajowhite: "#ffdead",
            navy: "#000080",
            oldlace: "#fdf5e6",
            olive: "#808000",
            olivedrab: "#6b8e23",
            orange: "#ffa500",
            orangered: "#ff4500",
            orchid: "#da70d6",
            palegoldenrod: "#eee8aa",
            palegreen: "#98fb98",
            paleturquoise: "#afeeee",
            palevioletred: "#db7093",
            papayawhip: "#ffefd5",
            peachpuff: "#ffdab9",
            peru: "#cd853f",
            pink: "#ffc0cb",
            plum: "#dda0dd",
            powderblue: "#b0e0e6",
            purple: "#800080",
            rebeccapurple: "#663399",
            red: "#ff0000",
            rosybrown: "#bc8f8f",
            royalblue: "#4169e1",
            saddlebrown: "#8b4513",
            salmon: "#fa8072",
            sandybrown: "#f4a460",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            sienna: "#a0522d",
            silver: "#c0c0c0",
            skyblue: "#87ceeb",
            slateblue: "#6a5acd",
            slategray: "#708090",
            slategrey: "#708090",
            snow: "#fffafa",
            springgreen: "#00ff7f",
            steelblue: "#4682b4",
            tan: "#d2b48c",
            teal: "#008080",
            thistle: "#d8bfd8",
            tomato: "#ff6347",
            turquoise: "#40e0d0",
            violet: "#ee82ee",
            wheat: "#f5deb3",
            white: "#ffffff",
            whitesmoke: "#f5f5f5",
            yellow: "#ffff00",
            yellowgreen: "#9acd32"
          };
          function inputToRGB(color) {
            var rgb = { r: 0, g: 0, b: 0 };
            var a = 1;
            var s = null;
            var v = null;
            var l = null;
            var ok = false;
            var format2 = false;
            if (typeof color === "string") {
              color = stringInputToObject(color);
            }
            if (typeof color === "object") {
              if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
                rgb = rgbToRgb(color.r, color.g, color.b);
                ok = true;
                format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
              } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
                s = convertToPercentage(color.s);
                v = convertToPercentage(color.v);
                rgb = hsvToRgb(color.h, s, v);
                ok = true;
                format2 = "hsv";
              } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
                s = convertToPercentage(color.s);
                l = convertToPercentage(color.l);
                rgb = hslToRgb(color.h, s, l);
                ok = true;
                format2 = "hsl";
              }
              if (Object.prototype.hasOwnProperty.call(color, "a")) {
                a = color.a;
              }
            }
            a = boundAlpha(a);
            return {
              ok,
              format: color.format || format2,
              r: Math.min(255, Math.max(rgb.r, 0)),
              g: Math.min(255, Math.max(rgb.g, 0)),
              b: Math.min(255, Math.max(rgb.b, 0)),
              a
            };
          }
          var CSS_INTEGER = "[-\\+]?\\d+%?";
          var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
          var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
          var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
          var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
          var matchers = {
            CSS_UNIT: new RegExp(CSS_UNIT),
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
          };
          function stringInputToObject(color) {
            color = color.trim().toLowerCase();
            if (color.length === 0) {
              return false;
            }
            var named = false;
            if (names[color]) {
              color = names[color];
              named = true;
            } else if (color === "transparent") {
              return { r: 0, g: 0, b: 0, a: 0, format: "name" };
            }
            var match = matchers.rgb.exec(color);
            if (match) {
              return { r: match[1], g: match[2], b: match[3] };
            }
            match = matchers.rgba.exec(color);
            if (match) {
              return { r: match[1], g: match[2], b: match[3], a: match[4] };
            }
            match = matchers.hsl.exec(color);
            if (match) {
              return { h: match[1], s: match[2], l: match[3] };
            }
            match = matchers.hsla.exec(color);
            if (match) {
              return { h: match[1], s: match[2], l: match[3], a: match[4] };
            }
            match = matchers.hsv.exec(color);
            if (match) {
              return { h: match[1], s: match[2], v: match[3] };
            }
            match = matchers.hsva.exec(color);
            if (match) {
              return { h: match[1], s: match[2], v: match[3], a: match[4] };
            }
            match = matchers.hex8.exec(color);
            if (match) {
              return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                a: convertHexToDecimal(match[4]),
                format: named ? "name" : "hex8"
              };
            }
            match = matchers.hex6.exec(color);
            if (match) {
              return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                format: named ? "name" : "hex"
              };
            }
            match = matchers.hex4.exec(color);
            if (match) {
              return {
                r: parseIntFromHex(match[1] + match[1]),
                g: parseIntFromHex(match[2] + match[2]),
                b: parseIntFromHex(match[3] + match[3]),
                a: convertHexToDecimal(match[4] + match[4]),
                format: named ? "name" : "hex8"
              };
            }
            match = matchers.hex3.exec(color);
            if (match) {
              return {
                r: parseIntFromHex(match[1] + match[1]),
                g: parseIntFromHex(match[2] + match[2]),
                b: parseIntFromHex(match[3] + match[3]),
                format: named ? "name" : "hex"
              };
            }
            return false;
          }
          function isValidCSSUnit(color) {
            return Boolean(matchers.CSS_UNIT.exec(String(color)));
          }
          var TinyColor = (
            /** @class */
            function() {
              function TinyColor2(color, opts) {
                if (color === void 0) {
                  color = "";
                }
                if (opts === void 0) {
                  opts = {};
                }
                var _a2;
                if (color instanceof TinyColor2) {
                  return color;
                }
                if (typeof color === "number") {
                  color = numberInputToObject(color);
                }
                this.originalInput = color;
                var rgb = inputToRGB(color);
                this.originalInput = color;
                this.r = rgb.r;
                this.g = rgb.g;
                this.b = rgb.b;
                this.a = rgb.a;
                this.roundA = Math.round(100 * this.a) / 100;
                this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
                this.gradientType = opts.gradientType;
                if (this.r < 1) {
                  this.r = Math.round(this.r);
                }
                if (this.g < 1) {
                  this.g = Math.round(this.g);
                }
                if (this.b < 1) {
                  this.b = Math.round(this.b);
                }
                this.isValid = rgb.ok;
              }
              TinyColor2.prototype.isDark = function() {
                return this.getBrightness() < 128;
              };
              TinyColor2.prototype.isLight = function() {
                return !this.isDark();
              };
              TinyColor2.prototype.getBrightness = function() {
                var rgb = this.toRgb();
                return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
              };
              TinyColor2.prototype.getLuminance = function() {
                var rgb = this.toRgb();
                var R2;
                var G2;
                var B2;
                var RsRGB = rgb.r / 255;
                var GsRGB = rgb.g / 255;
                var BsRGB = rgb.b / 255;
                if (RsRGB <= 0.03928) {
                  R2 = RsRGB / 12.92;
                } else {
                  R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
                }
                if (GsRGB <= 0.03928) {
                  G2 = GsRGB / 12.92;
                } else {
                  G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
                }
                if (BsRGB <= 0.03928) {
                  B2 = BsRGB / 12.92;
                } else {
                  B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
                }
                return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
              };
              TinyColor2.prototype.getAlpha = function() {
                return this.a;
              };
              TinyColor2.prototype.setAlpha = function(alpha) {
                this.a = boundAlpha(alpha);
                this.roundA = Math.round(100 * this.a) / 100;
                return this;
              };
              TinyColor2.prototype.isMonochrome = function() {
                var s = this.toHsl().s;
                return s === 0;
              };
              TinyColor2.prototype.toHsv = function() {
                var hsv = rgbToHsv(this.r, this.g, this.b);
                return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
              };
              TinyColor2.prototype.toHsvString = function() {
                var hsv = rgbToHsv(this.r, this.g, this.b);
                var h2 = Math.round(hsv.h * 360);
                var s = Math.round(hsv.s * 100);
                var v = Math.round(hsv.v * 100);
                return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
              };
              TinyColor2.prototype.toHsl = function() {
                var hsl = rgbToHsl(this.r, this.g, this.b);
                return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
              };
              TinyColor2.prototype.toHslString = function() {
                var hsl = rgbToHsl(this.r, this.g, this.b);
                var h2 = Math.round(hsl.h * 360);
                var s = Math.round(hsl.s * 100);
                var l = Math.round(hsl.l * 100);
                return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
              };
              TinyColor2.prototype.toHex = function(allow3Char) {
                if (allow3Char === void 0) {
                  allow3Char = false;
                }
                return rgbToHex(this.r, this.g, this.b, allow3Char);
              };
              TinyColor2.prototype.toHexString = function(allow3Char) {
                if (allow3Char === void 0) {
                  allow3Char = false;
                }
                return "#" + this.toHex(allow3Char);
              };
              TinyColor2.prototype.toHex8 = function(allow4Char) {
                if (allow4Char === void 0) {
                  allow4Char = false;
                }
                return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
              };
              TinyColor2.prototype.toHex8String = function(allow4Char) {
                if (allow4Char === void 0) {
                  allow4Char = false;
                }
                return "#" + this.toHex8(allow4Char);
              };
              TinyColor2.prototype.toHexShortString = function(allowShortChar) {
                if (allowShortChar === void 0) {
                  allowShortChar = false;
                }
                return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
              };
              TinyColor2.prototype.toRgb = function() {
                return {
                  r: Math.round(this.r),
                  g: Math.round(this.g),
                  b: Math.round(this.b),
                  a: this.a
                };
              };
              TinyColor2.prototype.toRgbString = function() {
                var r = Math.round(this.r);
                var g = Math.round(this.g);
                var b = Math.round(this.b);
                return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
              };
              TinyColor2.prototype.toPercentageRgb = function() {
                var fmt = function(x) {
                  return "".concat(Math.round(bound01(x, 255) * 100), "%");
                };
                return {
                  r: fmt(this.r),
                  g: fmt(this.g),
                  b: fmt(this.b),
                  a: this.a
                };
              };
              TinyColor2.prototype.toPercentageRgbString = function() {
                var rnd = function(x) {
                  return Math.round(bound01(x, 255) * 100);
                };
                return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
              };
              TinyColor2.prototype.toName = function() {
                if (this.a === 0) {
                  return "transparent";
                }
                if (this.a < 1) {
                  return false;
                }
                var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
                for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
                  var _b = _a2[_i], key = _b[0], value = _b[1];
                  if (hex === value) {
                    return key;
                  }
                }
                return false;
              };
              TinyColor2.prototype.toString = function(format2) {
                var formatSet = Boolean(format2);
                format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
                var formattedString = false;
                var hasAlpha = this.a < 1 && this.a >= 0;
                var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
                if (needsAlphaFormat) {
                  if (format2 === "name" && this.a === 0) {
                    return this.toName();
                  }
                  return this.toRgbString();
                }
                if (format2 === "rgb") {
                  formattedString = this.toRgbString();
                }
                if (format2 === "prgb") {
                  formattedString = this.toPercentageRgbString();
                }
                if (format2 === "hex" || format2 === "hex6") {
                  formattedString = this.toHexString();
                }
                if (format2 === "hex3") {
                  formattedString = this.toHexString(true);
                }
                if (format2 === "hex4") {
                  formattedString = this.toHex8String(true);
                }
                if (format2 === "hex8") {
                  formattedString = this.toHex8String();
                }
                if (format2 === "name") {
                  formattedString = this.toName();
                }
                if (format2 === "hsl") {
                  formattedString = this.toHslString();
                }
                if (format2 === "hsv") {
                  formattedString = this.toHsvString();
                }
                return formattedString || this.toHexString();
              };
              TinyColor2.prototype.toNumber = function() {
                return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
              };
              TinyColor2.prototype.clone = function() {
                return new TinyColor2(this.toString());
              };
              TinyColor2.prototype.lighten = function(amount) {
                if (amount === void 0) {
                  amount = 10;
                }
                var hsl = this.toHsl();
                hsl.l += amount / 100;
                hsl.l = clamp01(hsl.l);
                return new TinyColor2(hsl);
              };
              TinyColor2.prototype.brighten = function(amount) {
                if (amount === void 0) {
                  amount = 10;
                }
                var rgb = this.toRgb();
                rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
                rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
                rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
                return new TinyColor2(rgb);
              };
              TinyColor2.prototype.darken = function(amount) {
                if (amount === void 0) {
                  amount = 10;
                }
                var hsl = this.toHsl();
                hsl.l -= amount / 100;
                hsl.l = clamp01(hsl.l);
                return new TinyColor2(hsl);
              };
              TinyColor2.prototype.tint = function(amount) {
                if (amount === void 0) {
                  amount = 10;
                }
                return this.mix("white", amount);
              };
              TinyColor2.prototype.shade = function(amount) {
                if (amount === void 0) {
                  amount = 10;
                }
                return this.mix("black", amount);
              };
              TinyColor2.prototype.desaturate = function(amount) {
                if (amount === void 0) {
                  amount = 10;
                }
                var hsl = this.toHsl();
                hsl.s -= amount / 100;
                hsl.s = clamp01(hsl.s);
                return new TinyColor2(hsl);
              };
              TinyColor2.prototype.saturate = function(amount) {
                if (amount === void 0) {
                  amount = 10;
                }
                var hsl = this.toHsl();
                hsl.s += amount / 100;
                hsl.s = clamp01(hsl.s);
                return new TinyColor2(hsl);
              };
              TinyColor2.prototype.greyscale = function() {
                return this.desaturate(100);
              };
              TinyColor2.prototype.spin = function(amount) {
                var hsl = this.toHsl();
                var hue = (hsl.h + amount) % 360;
                hsl.h = hue < 0 ? 360 + hue : hue;
                return new TinyColor2(hsl);
              };
              TinyColor2.prototype.mix = function(color, amount) {
                if (amount === void 0) {
                  amount = 50;
                }
                var rgb1 = this.toRgb();
                var rgb2 = new TinyColor2(color).toRgb();
                var p2 = amount / 100;
                var rgba = {
                  r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
                  g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
                  b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
                  a: (rgb2.a - rgb1.a) * p2 + rgb1.a
                };
                return new TinyColor2(rgba);
              };
              TinyColor2.prototype.analogous = function(results, slices) {
                if (results === void 0) {
                  results = 6;
                }
                if (slices === void 0) {
                  slices = 30;
                }
                var hsl = this.toHsl();
                var part = 360 / slices;
                var ret = [this];
                for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
                  hsl.h = (hsl.h + part) % 360;
                  ret.push(new TinyColor2(hsl));
                }
                return ret;
              };
              TinyColor2.prototype.complement = function() {
                var hsl = this.toHsl();
                hsl.h = (hsl.h + 180) % 360;
                return new TinyColor2(hsl);
              };
              TinyColor2.prototype.monochromatic = function(results) {
                if (results === void 0) {
                  results = 6;
                }
                var hsv = this.toHsv();
                var h2 = hsv.h;
                var s = hsv.s;
                var v = hsv.v;
                var res = [];
                var modification = 1 / results;
                while (results--) {
                  res.push(new TinyColor2({ h: h2, s, v }));
                  v = (v + modification) % 1;
                }
                return res;
              };
              TinyColor2.prototype.splitcomplement = function() {
                var hsl = this.toHsl();
                var h2 = hsl.h;
                return [
                  this,
                  new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
                  new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
                ];
              };
              TinyColor2.prototype.onBackground = function(background) {
                var fg = this.toRgb();
                var bg = new TinyColor2(background).toRgb();
                var alpha = fg.a + bg.a * (1 - fg.a);
                return new TinyColor2({
                  r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
                  g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
                  b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
                  a: alpha
                });
              };
              TinyColor2.prototype.triad = function() {
                return this.polyad(3);
              };
              TinyColor2.prototype.tetrad = function() {
                return this.polyad(4);
              };
              TinyColor2.prototype.polyad = function(n) {
                var hsl = this.toHsl();
                var h2 = hsl.h;
                var result = [this];
                var increment = 360 / n;
                for (var i = 1; i < n; i++) {
                  result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
                }
                return result;
              };
              TinyColor2.prototype.equals = function(color) {
                return this.toRgbString() === new TinyColor2(color).toRgbString();
              };
              return TinyColor2;
            }()
          );
          function darken(color, amount = 20) {
            return color.mix("#141414", amount).toString();
          }
          function useButtonCustomStyle(props) {
            const _disabled = useFormDisabled();
            const ns = useNamespace("button");
            return computed(() => {
              let styles = {};
              let buttonColor = props.color;
              if (buttonColor) {
                const match = buttonColor.match(/var\((.*?)\)/);
                if (match) {
                  buttonColor = window.getComputedStyle(window.document.documentElement).getPropertyValue(match[1]);
                }
                const color = new TinyColor(buttonColor);
                const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
                if (props.plain) {
                  styles = ns.cssVarBlock({
                    "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
                    "text-color": buttonColor,
                    "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
                    "hover-text-color": `var(${ns.cssVarName("color-white")})`,
                    "hover-bg-color": buttonColor,
                    "hover-border-color": buttonColor,
                    "active-bg-color": activeBgColor,
                    "active-text-color": `var(${ns.cssVarName("color-white")})`,
                    "active-border-color": activeBgColor
                  });
                  if (_disabled.value) {
                    styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
                    styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
                    styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
                  }
                } else {
                  const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
                  const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
                  styles = ns.cssVarBlock({
                    "bg-color": buttonColor,
                    "text-color": textColor,
                    "border-color": buttonColor,
                    "hover-bg-color": hoverBgColor,
                    "hover-text-color": textColor,
                    "hover-border-color": hoverBgColor,
                    "active-bg-color": activeBgColor,
                    "active-border-color": activeBgColor
                  });
                  if (_disabled.value) {
                    const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
                    styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
                    styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
                    styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
                  }
                }
              }
              return styles;
            });
          }
          const __default__$e = /* @__PURE__ */ defineComponent({
            name: "ElButton"
          });
          const _sfc_main$n = /* @__PURE__ */ defineComponent({
            ...__default__$e,
            props: buttonProps,
            emits: buttonEmits,
            setup(__props, { expose, emit: emit2 }) {
              const props = __props;
              const buttonStyle = useButtonCustomStyle(props);
              const ns = useNamespace("button");
              const {
                _ref,
                _size,
                _type,
                _disabled,
                _props,
                _plain,
                _round,
                shouldAddSpace,
                handleClick
              } = useButton(props, emit2);
              const buttonKls = computed(() => [
                ns.b(),
                ns.m(_type.value),
                ns.m(_size.value),
                ns.is("disabled", _disabled.value),
                ns.is("loading", props.loading),
                ns.is("plain", _plain.value),
                ns.is("round", _round.value),
                ns.is("circle", props.circle),
                ns.is("text", props.text),
                ns.is("link", props.link),
                ns.is("has-bg", props.bg)
              ]);
              expose({
                ref: _ref,
                size: _size,
                type: _type,
                disabled: _disabled,
                shouldAddSpace
              });
              return (_ctx, _cache) => {
                return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
                  ref_key: "_ref",
                  ref: _ref
                }, unref(_props), {
                  class: unref(buttonKls),
                  style: unref(buttonStyle),
                  onClick: unref(handleClick)
                }), {
                  default: withCtx(() => [
                    _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass(unref(ns).is("loading"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"]))
                    ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                      default: withCtx(() => [
                        _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
                      ]),
                      _: 3
                    })) : createCommentVNode("v-if", true),
                    _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                      key: 2,
                      class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
                    }, [
                      renderSlot(_ctx.$slots, "default")
                    ], 2)) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 16, ["class", "style", "onClick"]);
              };
            }
          });
          var Button = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__file", "button.vue"]]);
          const buttonGroupProps = {
            size: buttonProps.size,
            type: buttonProps.type
          };
          const __default__$d = /* @__PURE__ */ defineComponent({
            name: "ElButtonGroup"
          });
          const _sfc_main$m = /* @__PURE__ */ defineComponent({
            ...__default__$d,
            props: buttonGroupProps,
            setup(__props) {
              const props = __props;
              provide(buttonGroupContextKey, reactive({
                size: toRef(props, "size"),
                type: toRef(props, "type")
              }));
              const ns = useNamespace("button");
              return (_ctx, _cache) => {
                return openBlock(), createElementBlock("div", {
                  class: normalizeClass(unref(ns).b("group"))
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2);
              };
            }
          });
          var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__file", "button-group.vue"]]);
          const ElButton = withInstall(Button, {
            ButtonGroup
          });
          withNoopInstall(ButtonGroup);
          const cardProps = buildProps({
            header: {
              type: String,
              default: ""
            },
            footer: {
              type: String,
              default: ""
            },
            bodyStyle: {
              type: definePropType([String, Object, Array]),
              default: ""
            },
            headerClass: String,
            bodyClass: String,
            footerClass: String,
            shadow: {
              type: String,
              values: ["always", "hover", "never"],
              default: "always"
            }
          });
          const __default__$c = /* @__PURE__ */ defineComponent({
            name: "ElCard"
          });
          const _sfc_main$l = /* @__PURE__ */ defineComponent({
            ...__default__$c,
            props: cardProps,
            setup(__props) {
              const ns = useNamespace("card");
              return (_ctx, _cache) => {
                return openBlock(), createElementBlock("div", {
                  class: normalizeClass([unref(ns).b(), unref(ns).is(`${_ctx.shadow}-shadow`)])
                }, [
                  _ctx.$slots.header || _ctx.header ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass([unref(ns).e("header"), _ctx.headerClass])
                  }, [
                    renderSlot(_ctx.$slots, "header", {}, () => [
                      createTextVNode(toDisplayString(_ctx.header), 1)
                    ])
                  ], 2)) : createCommentVNode("v-if", true),
                  createBaseVNode("div", {
                    class: normalizeClass([unref(ns).e("body"), _ctx.bodyClass]),
                    style: normalizeStyle(_ctx.bodyStyle)
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 6),
                  _ctx.$slots.footer || _ctx.footer ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass([unref(ns).e("footer"), _ctx.footerClass])
                  }, [
                    renderSlot(_ctx.$slots, "footer", {}, () => [
                      createTextVNode(toDisplayString(_ctx.footer), 1)
                    ])
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2);
              };
            }
          });
          var Card = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__file", "card.vue"]]);
          const ElCard = withInstall(Card);
          var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
            PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
            PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
            PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
            PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
            PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
            PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
            PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
            PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
            PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
            PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
            PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
            PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
            PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
            return PatchFlags2;
          })(PatchFlags || {});
          const flattedChildren = (children) => {
            const vNodes = isArray$1(children) ? children : [children];
            const result = [];
            vNodes.forEach((child) => {
              var _a2;
              if (isArray$1(child)) {
                result.push(...flattedChildren(child));
              } else if (isVNode(child) && ((_a2 = child.component) == null ? void 0 : _a2.subTree)) {
                result.push(child, ...flattedChildren(child.component.subTree));
              } else if (isVNode(child) && isArray$1(child.children)) {
                result.push(...flattedChildren(child.children));
              } else if (isVNode(child) && child.shapeFlag === 2) {
                result.push(...flattedChildren(child.type()));
              } else {
                result.push(child);
              }
            });
            return result;
          };
          const getOrderedChildren = (vm, childComponentName, children) => {
            const nodes = flattedChildren(vm.subTree).filter((n) => {
              var _a2;
              return isVNode(n) && ((_a2 = n.type) == null ? void 0 : _a2.name) === childComponentName && !!n.component;
            });
            const uids = nodes.map((n) => n.component.uid);
            return uids.map((uid2) => children[uid2]).filter((p2) => !!p2);
          };
          const useOrderedChildren = (vm, childComponentName) => {
            const children = shallowRef({});
            const orderedChildren = shallowRef([]);
            const nodesMap = /* @__PURE__ */ new WeakMap();
            const addChild = (child) => {
              children.value[child.uid] = child;
              triggerRef(children);
              onMounted(() => {
                const childNode = child.getVnode().el;
                const parentNode = childNode.parentNode;
                if (!nodesMap.has(parentNode)) {
                  nodesMap.set(parentNode, []);
                  const originalFn = parentNode.insertBefore.bind(parentNode);
                  parentNode.insertBefore = (node, anchor) => {
                    const shouldSortChildren = nodesMap.get(parentNode).some((el) => node === el || anchor === el);
                    if (shouldSortChildren)
                      triggerRef(children);
                    return originalFn(node, anchor);
                  };
                }
                nodesMap.get(parentNode).push(childNode);
              });
            };
            const removeChild = (child) => {
              delete children.value[child.uid];
              triggerRef(children);
              const childNode = child.getVnode().el;
              const parentNode = childNode.parentNode;
              const childNodes = nodesMap.get(parentNode);
              const index = childNodes.indexOf(childNode);
              childNodes.splice(index, 1);
            };
            const sortChildren = () => {
              orderedChildren.value = getOrderedChildren(vm, childComponentName, children.value);
            };
            const IsolatedRenderer = (props) => {
              return props.render();
            };
            const ChildrenSorter = /* @__PURE__ */ defineComponent({
              setup(_, { slots }) {
                return () => {
                  sortChildren();
                  return slots.default ? h(IsolatedRenderer, {
                    render: slots.default
                  }) : null;
                };
              }
            });
            return {
              children: orderedChildren,
              addChild,
              removeChild,
              ChildrenSorter
            };
          };
          const nodeList = /* @__PURE__ */ new Map();
          if (isClient) {
            let startClick;
            document.addEventListener("mousedown", (e) => startClick = e);
            document.addEventListener("mouseup", (e) => {
              if (startClick) {
                for (const handlers of nodeList.values()) {
                  for (const { documentHandler } of handlers) {
                    documentHandler(e, startClick);
                  }
                }
                startClick = void 0;
              }
            });
          }
          function createDocumentHandler(el, binding) {
            let excludes = [];
            if (isArray$1(binding.arg)) {
              excludes = binding.arg;
            } else if (isElement(binding.arg)) {
              excludes.push(binding.arg);
            }
            return function(mouseup, mousedown) {
              const popperRef = binding.instance.popperRef;
              const mouseUpTarget = mouseup.target;
              const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
              const isBound = !binding || !binding.instance;
              const isTargetExists = !mouseUpTarget || !mouseDownTarget;
              const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
              const isSelf = el === mouseUpTarget;
              const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
              const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
              if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
                return;
              }
              binding.value(mouseup, mousedown);
            };
          }
          const ClickOutside = {
            beforeMount(el, binding) {
              if (!nodeList.has(el)) {
                nodeList.set(el, []);
              }
              nodeList.get(el).push({
                documentHandler: createDocumentHandler(el, binding),
                bindingFn: binding.value
              });
            },
            updated(el, binding) {
              if (!nodeList.has(el)) {
                nodeList.set(el, []);
              }
              const handlers = nodeList.get(el);
              const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
              const newHandler = {
                documentHandler: createDocumentHandler(el, binding),
                bindingFn: binding.value
              };
              if (oldHandlerIndex >= 0) {
                handlers.splice(oldHandlerIndex, 1, newHandler);
              } else {
                handlers.push(newHandler);
              }
            },
            unmounted(el) {
              nodeList.delete(el);
            }
          };
          const __default__$b = /* @__PURE__ */ defineComponent({
            name: "ElCollapseTransition"
          });
          const _sfc_main$k = /* @__PURE__ */ defineComponent({
            ...__default__$b,
            setup(__props) {
              const ns = useNamespace("collapse-transition");
              const reset = (el) => {
                el.style.maxHeight = "";
                el.style.overflow = el.dataset.oldOverflow;
                el.style.paddingTop = el.dataset.oldPaddingTop;
                el.style.paddingBottom = el.dataset.oldPaddingBottom;
              };
              const on2 = {
                beforeEnter(el) {
                  if (!el.dataset)
                    el.dataset = {};
                  el.dataset.oldPaddingTop = el.style.paddingTop;
                  el.dataset.oldPaddingBottom = el.style.paddingBottom;
                  if (el.style.height)
                    el.dataset.elExistsHeight = el.style.height;
                  el.style.maxHeight = 0;
                  el.style.paddingTop = 0;
                  el.style.paddingBottom = 0;
                },
                enter(el) {
                  requestAnimationFrame(() => {
                    el.dataset.oldOverflow = el.style.overflow;
                    if (el.dataset.elExistsHeight) {
                      el.style.maxHeight = el.dataset.elExistsHeight;
                    } else if (el.scrollHeight !== 0) {
                      el.style.maxHeight = `${el.scrollHeight}px`;
                    } else {
                      el.style.maxHeight = 0;
                    }
                    el.style.paddingTop = el.dataset.oldPaddingTop;
                    el.style.paddingBottom = el.dataset.oldPaddingBottom;
                    el.style.overflow = "hidden";
                  });
                },
                afterEnter(el) {
                  el.style.maxHeight = "";
                  el.style.overflow = el.dataset.oldOverflow;
                },
                enterCancelled(el) {
                  reset(el);
                },
                beforeLeave(el) {
                  if (!el.dataset)
                    el.dataset = {};
                  el.dataset.oldPaddingTop = el.style.paddingTop;
                  el.dataset.oldPaddingBottom = el.style.paddingBottom;
                  el.dataset.oldOverflow = el.style.overflow;
                  el.style.maxHeight = `${el.scrollHeight}px`;
                  el.style.overflow = "hidden";
                },
                leave(el) {
                  if (el.scrollHeight !== 0) {
                    el.style.maxHeight = 0;
                    el.style.paddingTop = 0;
                    el.style.paddingBottom = 0;
                  }
                },
                afterLeave(el) {
                  reset(el);
                },
                leaveCancelled(el) {
                  reset(el);
                }
              };
              return (_ctx, _cache) => {
                return openBlock(), createBlock(Transition, mergeProps({
                  name: unref(ns).b()
                }, toHandlers(on2)), {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 16, ["name"]);
              };
            }
          });
          var CollapseTransition = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__file", "collapse-transition.vue"]]);
          const ElCollapseTransition = withInstall(CollapseTransition);
          const alphaSliderProps = buildProps({
            color: {
              type: definePropType(Object),
              required: true
            },
            vertical: {
              type: Boolean,
              default: false
            }
          });
          let isDragging = false;
          function draggable(element, options) {
            if (!isClient)
              return;
            const moveFn = function(event) {
              var _a2;
              (_a2 = options.drag) == null ? void 0 : _a2.call(options, event);
            };
            const upFn = function(event) {
              var _a2;
              document.removeEventListener("mousemove", moveFn);
              document.removeEventListener("mouseup", upFn);
              document.removeEventListener("touchmove", moveFn);
              document.removeEventListener("touchend", upFn);
              document.onselectstart = null;
              document.ondragstart = null;
              isDragging = false;
              (_a2 = options.end) == null ? void 0 : _a2.call(options, event);
            };
            const downFn = function(event) {
              var _a2;
              if (isDragging)
                return;
              event.preventDefault();
              document.onselectstart = () => false;
              document.ondragstart = () => false;
              document.addEventListener("mousemove", moveFn);
              document.addEventListener("mouseup", upFn);
              document.addEventListener("touchmove", moveFn);
              document.addEventListener("touchend", upFn);
              isDragging = true;
              (_a2 = options.start) == null ? void 0 : _a2.call(options, event);
            };
            element.addEventListener("mousedown", downFn);
            element.addEventListener("touchstart", downFn, { passive: false });
          }
          const getClientXY = (event) => {
            let clientX;
            let clientY;
            if (event.type === "touchend") {
              clientY = event.changedTouches[0].clientY;
              clientX = event.changedTouches[0].clientX;
            } else if (event.type.startsWith("touch")) {
              clientY = event.touches[0].clientY;
              clientX = event.touches[0].clientX;
            } else {
              clientY = event.clientY;
              clientX = event.clientX;
            }
            return {
              clientX,
              clientY
            };
          };
          const useAlphaSlider = (props) => {
            const instance = getCurrentInstance();
            const { t } = useLocale();
            const thumb = shallowRef();
            const bar = shallowRef();
            const alpha = computed(() => props.color.get("alpha"));
            const alphaLabel = computed(() => t("el.colorpicker.alphaLabel"));
            function handleClick(event) {
              var _a2;
              const target = event.target;
              if (target !== thumb.value) {
                handleDrag(event);
              }
              (_a2 = thumb.value) == null ? void 0 : _a2.focus();
            }
            function handleDrag(event) {
              if (!bar.value || !thumb.value)
                return;
              const el = instance.vnode.el;
              const rect = el.getBoundingClientRect();
              const { clientX, clientY } = getClientXY(event);
              if (!props.vertical) {
                let left = clientX - rect.left;
                left = Math.max(thumb.value.offsetWidth / 2, left);
                left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);
                props.color.set("alpha", Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));
              } else {
                let top = clientY - rect.top;
                top = Math.max(thumb.value.offsetHeight / 2, top);
                top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
                props.color.set("alpha", Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));
              }
            }
            function handleKeydown(event) {
              const { code, shiftKey } = event;
              const step = shiftKey ? 10 : 1;
              switch (code) {
                case EVENT_CODE.left:
                case EVENT_CODE.down:
                  event.preventDefault();
                  event.stopPropagation();
                  incrementPosition(-step);
                  break;
                case EVENT_CODE.right:
                case EVENT_CODE.up:
                  event.preventDefault();
                  event.stopPropagation();
                  incrementPosition(step);
                  break;
              }
            }
            function incrementPosition(step) {
              let next = alpha.value + step;
              next = next < 0 ? 0 : next > 100 ? 100 : next;
              props.color.set("alpha", next);
            }
            return {
              thumb,
              bar,
              alpha,
              alphaLabel,
              handleDrag,
              handleClick,
              handleKeydown
            };
          };
          const useAlphaSliderDOM = (props, {
            bar,
            thumb,
            handleDrag
          }) => {
            const instance = getCurrentInstance();
            const ns = useNamespace("color-alpha-slider");
            const thumbLeft = ref(0);
            const thumbTop = ref(0);
            const background = ref();
            function getThumbLeft() {
              if (!thumb.value)
                return 0;
              if (props.vertical)
                return 0;
              const el = instance.vnode.el;
              const alpha = props.color.get("alpha");
              if (!el)
                return 0;
              return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);
            }
            function getThumbTop() {
              if (!thumb.value)
                return 0;
              const el = instance.vnode.el;
              if (!props.vertical)
                return 0;
              const alpha = props.color.get("alpha");
              if (!el)
                return 0;
              return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);
            }
            function getBackground() {
              if (props.color && props.color.value) {
                const { r, g, b } = props.color.toRgb();
                return `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgba(${r}, ${g}, ${b}, 1) 100%)`;
              }
              return "";
            }
            function update() {
              thumbLeft.value = getThumbLeft();
              thumbTop.value = getThumbTop();
              background.value = getBackground();
            }
            onMounted(() => {
              if (!bar.value || !thumb.value)
                return;
              const dragConfig = {
                drag: (event) => {
                  handleDrag(event);
                },
                end: (event) => {
                  handleDrag(event);
                }
              };
              draggable(bar.value, dragConfig);
              draggable(thumb.value, dragConfig);
              update();
            });
            watch(() => props.color.get("alpha"), () => update());
            watch(() => props.color.value, () => update());
            const rootKls = computed(() => [ns.b(), ns.is("vertical", props.vertical)]);
            const barKls = computed(() => ns.e("bar"));
            const thumbKls = computed(() => ns.e("thumb"));
            const barStyle = computed(() => ({ background: background.value }));
            const thumbStyle = computed(() => ({
              left: addUnit(thumbLeft.value),
              top: addUnit(thumbTop.value)
            }));
            return { rootKls, barKls, barStyle, thumbKls, thumbStyle, update };
          };
          const COMPONENT_NAME$6 = "ElColorAlphaSlider";
          const __default__$a = /* @__PURE__ */ defineComponent({
            name: COMPONENT_NAME$6
          });
          const _sfc_main$j = /* @__PURE__ */ defineComponent({
            ...__default__$a,
            props: alphaSliderProps,
            setup(__props, { expose }) {
              const props = __props;
              const {
                alpha,
                alphaLabel,
                bar,
                thumb,
                handleDrag,
                handleClick,
                handleKeydown
              } = useAlphaSlider(props);
              const { rootKls, barKls, barStyle, thumbKls, thumbStyle, update } = useAlphaSliderDOM(props, {
                bar,
                thumb,
                handleDrag
              });
              expose({
                update,
                bar,
                thumb
              });
              return (_ctx, _cache) => {
                return openBlock(), createElementBlock("div", {
                  class: normalizeClass(unref(rootKls))
                }, [
                  createBaseVNode("div", {
                    ref_key: "bar",
                    ref: bar,
                    class: normalizeClass(unref(barKls)),
                    style: normalizeStyle(unref(barStyle)),
                    onClick: unref(handleClick)
                  }, null, 14, ["onClick"]),
                  createBaseVNode("div", {
                    ref_key: "thumb",
                    ref: thumb,
                    class: normalizeClass(unref(thumbKls)),
                    style: normalizeStyle(unref(thumbStyle)),
                    "aria-label": unref(alphaLabel),
                    "aria-valuenow": unref(alpha),
                    "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                    "aria-valuemin": "0",
                    "aria-valuemax": "100",
                    role: "slider",
                    tabindex: "0",
                    onKeydown: unref(handleKeydown)
                  }, null, 46, ["aria-label", "aria-valuenow", "aria-orientation", "onKeydown"])
                ], 2);
              };
            }
          });
          var AlphaSlider = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__file", "alpha-slider.vue"]]);
          const _sfc_main$i = /* @__PURE__ */ defineComponent({
            name: "ElColorHueSlider",
            props: {
              color: {
                type: Object,
                required: true
              },
              vertical: Boolean
            },
            setup(props) {
              const ns = useNamespace("color-hue-slider");
              const instance = getCurrentInstance();
              const thumb = ref();
              const bar = ref();
              const thumbLeft = ref(0);
              const thumbTop = ref(0);
              const hueValue = computed(() => {
                return props.color.get("hue");
              });
              watch(() => hueValue.value, () => {
                update();
              });
              function handleClick(event) {
                const target = event.target;
                if (target !== thumb.value) {
                  handleDrag(event);
                }
              }
              function handleDrag(event) {
                if (!bar.value || !thumb.value)
                  return;
                const el = instance.vnode.el;
                const rect = el.getBoundingClientRect();
                const { clientX, clientY } = getClientXY(event);
                let hue;
                if (!props.vertical) {
                  let left = clientX - rect.left;
                  left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);
                  left = Math.max(thumb.value.offsetWidth / 2, left);
                  hue = Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 360);
                } else {
                  let top = clientY - rect.top;
                  top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
                  top = Math.max(thumb.value.offsetHeight / 2, top);
                  hue = Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 360);
                }
                props.color.set("hue", hue);
              }
              function getThumbLeft() {
                if (!thumb.value)
                  return 0;
                const el = instance.vnode.el;
                if (props.vertical)
                  return 0;
                const hue = props.color.get("hue");
                if (!el)
                  return 0;
                return Math.round(hue * (el.offsetWidth - thumb.value.offsetWidth / 2) / 360);
              }
              function getThumbTop() {
                if (!thumb.value)
                  return 0;
                const el = instance.vnode.el;
                if (!props.vertical)
                  return 0;
                const hue = props.color.get("hue");
                if (!el)
                  return 0;
                return Math.round(hue * (el.offsetHeight - thumb.value.offsetHeight / 2) / 360);
              }
              function update() {
                thumbLeft.value = getThumbLeft();
                thumbTop.value = getThumbTop();
              }
              onMounted(() => {
                if (!bar.value || !thumb.value)
                  return;
                const dragConfig = {
                  drag: (event) => {
                    handleDrag(event);
                  },
                  end: (event) => {
                    handleDrag(event);
                  }
                };
                draggable(bar.value, dragConfig);
                draggable(thumb.value, dragConfig);
                update();
              });
              return {
                bar,
                thumb,
                thumbLeft,
                thumbTop,
                hueValue,
                handleClick,
                update,
                ns
              };
            }
          });
          function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("vertical", _ctx.vertical)])
            }, [
              createBaseVNode("div", {
                ref: "bar",
                class: normalizeClass(_ctx.ns.e("bar")),
                onClick: _ctx.handleClick
              }, null, 10, ["onClick"]),
              createBaseVNode("div", {
                ref: "thumb",
                class: normalizeClass(_ctx.ns.e("thumb")),
                style: normalizeStyle({
                  left: _ctx.thumbLeft + "px",
                  top: _ctx.thumbTop + "px"
                })
              }, null, 6)
            ], 2);
          }
          var HueSlider = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$2], ["__file", "hue-slider.vue"]]);
          const colorPickerProps = buildProps({
            modelValue: {
              type: definePropType(String),
              default: void 0
            },
            id: String,
            showAlpha: Boolean,
            colorFormat: String,
            disabled: Boolean,
            size: useSizeProp,
            popperClass: {
              type: String,
              default: ""
            },
            tabindex: {
              type: [String, Number],
              default: 0
            },
            teleported: useTooltipContentProps.teleported,
            predefine: {
              type: definePropType(Array)
            },
            validateEvent: {
              type: Boolean,
              default: true
            },
            ...useEmptyValuesProps,
            ...useAriaProps(["ariaLabel"])
          });
          const colorPickerEmits = {
            [UPDATE_MODEL_EVENT]: (val) => isString$1(val) || isNil(val),
            [CHANGE_EVENT]: (val) => isString$1(val) || isNil(val),
            activeChange: (val) => isString$1(val) || isNil(val),
            focus: (evt) => evt instanceof FocusEvent,
            blur: (evt) => evt instanceof FocusEvent
          };
          const colorPickerContextKey = Symbol("colorPickerContextKey");
          class Color {
            constructor(options = {}) {
              this._hue = 0;
              this._saturation = 100;
              this._value = 100;
              this._alpha = 100;
              this._tiny = new TinyColor();
              this._isValid = false;
              this.enableAlpha = false;
              this.format = "";
              this.value = "";
              for (const option in options) {
                if (hasOwn(options, option)) {
                  this[option] = options[option];
                }
              }
              if (options.value) {
                this.fromString(options.value);
              } else {
                this.doOnChange();
              }
            }
            set(prop, value) {
              if (arguments.length === 1 && typeof prop === "object") {
                for (const p2 in prop) {
                  if (hasOwn(prop, p2)) {
                    this.set(p2, prop[p2]);
                  }
                }
                return;
              }
              this[`_${prop}`] = value;
              this._isValid = true;
              this.doOnChange();
            }
            get(prop) {
              if (["hue", "saturation", "value", "alpha"].includes(prop)) {
                return Math.round(this[`_${prop}`]);
              }
              return this[`_${prop}`];
            }
            toRgb() {
              return this._isValid ? this._tiny.toRgb() : { r: 255, g: 255, b: 255, a: 0 };
            }
            fromString(value) {
              const color = new TinyColor(value);
              this._isValid = color.isValid;
              if (color.isValid) {
                const { h: h2, s, v, a } = color.toHsv();
                this._hue = h2;
                this._saturation = s * 100;
                this._value = v * 100;
                this._alpha = a * 100;
              } else {
                this._hue = 0;
                this._saturation = 100;
                this._value = 100;
                this._alpha = 100;
              }
              this.doOnChange();
            }
            compare(color) {
              const compareColor = new TinyColor({
                h: color._hue,
                s: color._saturation / 100,
                v: color._value / 100,
                a: color._alpha / 100
              });
              return this._tiny.equals(compareColor);
            }
            doOnChange() {
              const { _hue, _saturation, _value, _alpha, format: format2, enableAlpha } = this;
              let _format = format2 || (enableAlpha ? "rgb" : "hex");
              if (format2 === "hex" && enableAlpha) {
                _format = "hex8";
              }
              this._tiny = new TinyColor({
                h: _hue,
                s: _saturation / 100,
                v: _value / 100,
                a: _alpha / 100
              });
              this.value = this._isValid ? this._tiny.toString(_format) : "";
            }
          }
          const _sfc_main$h = /* @__PURE__ */ defineComponent({
            props: {
              colors: {
                type: Array,
                required: true
              },
              color: {
                type: Object,
                required: true
              },
              enableAlpha: {
                type: Boolean,
                required: true
              }
            },
            setup(props) {
              const ns = useNamespace("color-predefine");
              const { currentColor } = inject(colorPickerContextKey);
              const rgbaColors = ref(parseColors(props.colors, props.color));
              watch(() => currentColor.value, (val) => {
                const color = new Color({
                  value: val
                });
                rgbaColors.value.forEach((item) => {
                  item.selected = color.compare(item);
                });
              });
              watchEffect(() => {
                rgbaColors.value = parseColors(props.colors, props.color);
              });
              function handleSelect(index) {
                props.color.fromString(props.colors[index]);
              }
              function parseColors(colors, color) {
                return colors.map((value) => {
                  const c = new Color({
                    value
                  });
                  c.selected = c.compare(color);
                  return c;
                });
              }
              return {
                rgbaColors,
                handleSelect,
                ns
              };
            }
          });
          function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(_ctx.ns.b())
            }, [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.ns.e("colors"))
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rgbaColors, (item, index) => {
                  return openBlock(), createElementBlock("div", {
                    key: _ctx.colors[index],
                    class: normalizeClass([
                      _ctx.ns.e("color-selector"),
                      _ctx.ns.is("alpha", item.get("alpha") < 100),
                      { selected: item.selected }
                    ]),
                    onClick: ($event) => _ctx.handleSelect(index)
                  }, [
                    createBaseVNode("div", {
                      style: normalizeStyle({ backgroundColor: item.value })
                    }, null, 4)
                  ], 10, ["onClick"]);
                }), 128))
              ], 2)
            ], 2);
          }
          var Predefine = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$1], ["__file", "predefine.vue"]]);
          const _sfc_main$g = /* @__PURE__ */ defineComponent({
            name: "ElSlPanel",
            props: {
              color: {
                type: Object,
                required: true
              }
            },
            setup(props) {
              const ns = useNamespace("color-svpanel");
              const instance = getCurrentInstance();
              const cursorTop = ref(0);
              const cursorLeft = ref(0);
              const background = ref("hsl(0, 100%, 50%)");
              const colorValue = computed(() => {
                const hue = props.color.get("hue");
                const value = props.color.get("value");
                return { hue, value };
              });
              function update() {
                const saturation = props.color.get("saturation");
                const value = props.color.get("value");
                const el = instance.vnode.el;
                const { clientWidth: width, clientHeight: height } = el;
                cursorLeft.value = saturation * width / 100;
                cursorTop.value = (100 - value) * height / 100;
                background.value = `hsl(${props.color.get("hue")}, 100%, 50%)`;
              }
              function handleDrag(event) {
                const el = instance.vnode.el;
                const rect = el.getBoundingClientRect();
                const { clientX, clientY } = getClientXY(event);
                let left = clientX - rect.left;
                let top = clientY - rect.top;
                left = Math.max(0, left);
                left = Math.min(left, rect.width);
                top = Math.max(0, top);
                top = Math.min(top, rect.height);
                cursorLeft.value = left;
                cursorTop.value = top;
                props.color.set({
                  saturation: left / rect.width * 100,
                  value: 100 - top / rect.height * 100
                });
              }
              watch(() => colorValue.value, () => {
                update();
              });
              onMounted(() => {
                draggable(instance.vnode.el, {
                  drag: (event) => {
                    handleDrag(event);
                  },
                  end: (event) => {
                    handleDrag(event);
                  }
                });
                update();
              });
              return {
                cursorTop,
                cursorLeft,
                background,
                colorValue,
                handleDrag,
                update,
                ns
              };
            }
          });
          function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(_ctx.ns.b()),
              style: normalizeStyle({
                backgroundColor: _ctx.background
              })
            }, [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.ns.e("white"))
              }, null, 2),
              createBaseVNode("div", {
                class: normalizeClass(_ctx.ns.e("black"))
              }, null, 2),
              createBaseVNode("div", {
                class: normalizeClass(_ctx.ns.e("cursor")),
                style: normalizeStyle({
                  top: _ctx.cursorTop + "px",
                  left: _ctx.cursorLeft + "px"
                })
              }, [
                createBaseVNode("div")
              ], 6)
            ], 6);
          }
          var SvPanel = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render], ["__file", "sv-panel.vue"]]);
          const __default__$9 = /* @__PURE__ */ defineComponent({
            name: "ElColorPicker"
          });
          const _sfc_main$f = /* @__PURE__ */ defineComponent({
            ...__default__$9,
            props: colorPickerProps,
            emits: colorPickerEmits,
            setup(__props, { expose, emit: emit2 }) {
              const props = __props;
              const { t } = useLocale();
              const ns = useNamespace("color");
              const { formItem } = useFormItem();
              const colorSize = useFormSize();
              const colorDisabled = useFormDisabled();
              const { valueOnClear, isEmptyValue: isEmptyValue2 } = useEmptyValues(props, null);
              const { inputId: buttonId, isLabeledByFormItem } = useFormItemInputId(props, {
                formItemContext: formItem
              });
              const hue = ref();
              const sv = ref();
              const alpha = ref();
              const popper = ref();
              const triggerRef2 = ref();
              const inputRef = ref();
              const { isFocused, handleFocus, handleBlur } = useFocusController(triggerRef2, {
                disabled: colorDisabled,
                beforeBlur(event) {
                  var _a2;
                  return (_a2 = popper.value) == null ? void 0 : _a2.isFocusInsideContent(event);
                },
                afterBlur() {
                  setShowPicker(false);
                  resetColor();
                }
              });
              let shouldActiveChange = true;
              const color = reactive(new Color({
                enableAlpha: props.showAlpha,
                format: props.colorFormat || "",
                value: props.modelValue
              }));
              const showPicker = ref(false);
              const showPanelColor = ref(false);
              const customInput = ref("");
              const displayedColor = computed(() => {
                if (!props.modelValue && !showPanelColor.value) {
                  return "transparent";
                }
                return displayedRgb(color, props.showAlpha);
              });
              const currentColor = computed(() => {
                return !props.modelValue && !showPanelColor.value ? "" : color.value;
              });
              const buttonAriaLabel = computed(() => {
                return !isLabeledByFormItem.value ? props.ariaLabel || t("el.colorpicker.defaultLabel") : void 0;
              });
              const buttonAriaLabelledby = computed(() => {
                return isLabeledByFormItem.value ? formItem == null ? void 0 : formItem.labelId : void 0;
              });
              const btnKls = computed(() => {
                return [
                  ns.b("picker"),
                  ns.is("disabled", colorDisabled.value),
                  ns.bm("picker", colorSize.value),
                  ns.is("focused", isFocused.value)
                ];
              });
              function displayedRgb(color2, showAlpha) {
                const { r, g, b, a } = color2.toRgb();
                return showAlpha ? `rgba(${r}, ${g}, ${b}, ${a})` : `rgb(${r}, ${g}, ${b})`;
              }
              function setShowPicker(value) {
                showPicker.value = value;
              }
              const debounceSetShowPicker = debounce(setShowPicker, 100, { leading: true });
              function show() {
                if (colorDisabled.value)
                  return;
                setShowPicker(true);
              }
              function hide() {
                debounceSetShowPicker(false);
                resetColor();
              }
              function resetColor() {
                nextTick(() => {
                  if (props.modelValue) {
                    color.fromString(props.modelValue);
                  } else {
                    color.value = "";
                    if (!currentColor.value && customInput.value) {
                      customInput.value = "";
                    }
                    nextTick(() => {
                      showPanelColor.value = false;
                    });
                  }
                });
              }
              function handleTrigger() {
                if (colorDisabled.value)
                  return;
                if (showPicker.value) {
                  resetColor();
                }
                debounceSetShowPicker(!showPicker.value);
              }
              function handleConfirm() {
                color.fromString(customInput.value);
                if (color.value !== customInput.value) {
                  customInput.value = color.value;
                }
              }
              function confirmValue() {
                const value = isEmptyValue2(color.value) ? valueOnClear.value : color.value;
                emit2(UPDATE_MODEL_EVENT, value);
                emit2(CHANGE_EVENT, value);
                if (props.validateEvent) {
                  formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
                }
                debounceSetShowPicker(false);
                nextTick(() => {
                  const newColor = new Color({
                    enableAlpha: props.showAlpha,
                    format: props.colorFormat || "",
                    value: props.modelValue
                  });
                  if (!color.compare(newColor)) {
                    resetColor();
                  }
                });
              }
              function clear() {
                debounceSetShowPicker(false);
                emit2(UPDATE_MODEL_EVENT, valueOnClear.value);
                emit2(CHANGE_EVENT, valueOnClear.value);
                if (props.modelValue !== valueOnClear.value && props.validateEvent) {
                  formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
                }
                resetColor();
              }
              function handleClickOutside() {
                if (!showPicker.value)
                  return;
                hide();
                isFocused.value && focus();
              }
              function handleEsc(event) {
                event.preventDefault();
                event.stopPropagation();
                setShowPicker(false);
                resetColor();
              }
              function handleKeyDown(event) {
                switch (event.code) {
                  case EVENT_CODE.enter:
                  case EVENT_CODE.numpadEnter:
                  case EVENT_CODE.space:
                    event.preventDefault();
                    event.stopPropagation();
                    show();
                    inputRef.value.focus();
                    break;
                  case EVENT_CODE.esc:
                    handleEsc(event);
                    break;
                }
              }
              function focus() {
                triggerRef2.value.focus();
              }
              function blur() {
                triggerRef2.value.blur();
              }
              onMounted(() => {
                if (props.modelValue) {
                  customInput.value = currentColor.value;
                }
              });
              watch(() => props.modelValue, (newVal) => {
                if (!newVal) {
                  showPanelColor.value = false;
                } else if (newVal && newVal !== color.value) {
                  shouldActiveChange = false;
                  color.fromString(newVal);
                }
              });
              watch(() => [props.colorFormat, props.showAlpha], () => {
                color.enableAlpha = props.showAlpha;
                color.format = props.colorFormat || color.format;
                color.doOnChange();
                emit2(UPDATE_MODEL_EVENT, color.value);
              });
              watch(() => currentColor.value, (val) => {
                customInput.value = val;
                shouldActiveChange && emit2("activeChange", val);
                shouldActiveChange = true;
              });
              watch(() => color.value, () => {
                if (!props.modelValue && !showPanelColor.value) {
                  showPanelColor.value = true;
                }
              });
              watch(() => showPicker.value, () => {
                nextTick(() => {
                  var _a2, _b, _c;
                  (_a2 = hue.value) == null ? void 0 : _a2.update();
                  (_b = sv.value) == null ? void 0 : _b.update();
                  (_c = alpha.value) == null ? void 0 : _c.update();
                });
              });
              provide(colorPickerContextKey, {
                currentColor
              });
              expose({
                color,
                show,
                hide,
                focus,
                blur
              });
              return (_ctx, _cache) => {
                return openBlock(), createBlock(unref(ElTooltip), {
                  ref_key: "popper",
                  ref: popper,
                  visible: showPicker.value,
                  "show-arrow": false,
                  "fallback-placements": ["bottom", "top", "right", "left"],
                  offset: 0,
                  "gpu-acceleration": false,
                  "popper-class": [unref(ns).be("picker", "panel"), unref(ns).b("dropdown"), _ctx.popperClass],
                  "stop-popper-mouse-event": false,
                  effect: "light",
                  trigger: "click",
                  teleported: _ctx.teleported,
                  transition: `${unref(ns).namespace.value}-zoom-in-top`,
                  persistent: "",
                  onHide: ($event) => setShowPicker(false)
                }, {
                  content: withCtx(() => [
                    withDirectives((openBlock(), createElementBlock("div", {
                      onKeydown: withKeys(handleEsc, ["esc"])
                    }, [
                      createBaseVNode("div", {
                        class: normalizeClass(unref(ns).be("dropdown", "main-wrapper"))
                      }, [
                        createVNode(HueSlider, {
                          ref_key: "hue",
                          ref: hue,
                          class: "hue-slider",
                          color: unref(color),
                          vertical: ""
                        }, null, 8, ["color"]),
                        createVNode(SvPanel, {
                          ref_key: "sv",
                          ref: sv,
                          color: unref(color)
                        }, null, 8, ["color"])
                      ], 2),
                      _ctx.showAlpha ? (openBlock(), createBlock(AlphaSlider, {
                        key: 0,
                        ref_key: "alpha",
                        ref: alpha,
                        color: unref(color)
                      }, null, 8, ["color"])) : createCommentVNode("v-if", true),
                      _ctx.predefine ? (openBlock(), createBlock(Predefine, {
                        key: 1,
                        ref: "predefine",
                        "enable-alpha": _ctx.showAlpha,
                        color: unref(color),
                        colors: _ctx.predefine
                      }, null, 8, ["enable-alpha", "color", "colors"])) : createCommentVNode("v-if", true),
                      createBaseVNode("div", {
                        class: normalizeClass(unref(ns).be("dropdown", "btns"))
                      }, [
                        createBaseVNode("span", {
                          class: normalizeClass(unref(ns).be("dropdown", "value"))
                        }, [
                          createVNode(unref(ElInput), {
                            ref_key: "inputRef",
                            ref: inputRef,
                            modelValue: customInput.value,
                            "onUpdate:modelValue": ($event) => customInput.value = $event,
                            "validate-event": false,
                            size: "small",
                            onChange: handleConfirm
                          }, null, 8, ["modelValue", "onUpdate:modelValue"])
                        ], 2),
                        createVNode(unref(ElButton), {
                          class: normalizeClass(unref(ns).be("dropdown", "link-btn")),
                          text: "",
                          size: "small",
                          onClick: clear
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(unref(t)("el.colorpicker.clear")), 1)
                          ]),
                          _: 1
                        }, 8, ["class"]),
                        createVNode(unref(ElButton), {
                          plain: "",
                          size: "small",
                          class: normalizeClass(unref(ns).be("dropdown", "btn")),
                          onClick: confirmValue
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(unref(t)("el.colorpicker.confirm")), 1)
                          ]),
                          _: 1
                        }, 8, ["class"])
                      ], 2)
                    ], 40, ["onKeydown"])), [
                      [unref(ClickOutside), handleClickOutside, triggerRef2.value]
                    ])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("div", mergeProps({
                      id: unref(buttonId),
                      ref_key: "triggerRef",
                      ref: triggerRef2
                    }, _ctx.$attrs, {
                      class: unref(btnKls),
                      role: "button",
                      "aria-label": unref(buttonAriaLabel),
                      "aria-labelledby": unref(buttonAriaLabelledby),
                      "aria-description": unref(t)("el.colorpicker.description", { color: _ctx.modelValue || "" }),
                      "aria-disabled": unref(colorDisabled),
                      tabindex: unref(colorDisabled) ? void 0 : _ctx.tabindex,
                      onKeydown: handleKeyDown,
                      onFocus: unref(handleFocus),
                      onBlur: unref(handleBlur)
                    }), [
                      createBaseVNode("div", {
                        class: normalizeClass(unref(ns).be("picker", "trigger")),
                        onClick: handleTrigger
                      }, [
                        createBaseVNode("span", {
                          class: normalizeClass([unref(ns).be("picker", "color"), unref(ns).is("alpha", _ctx.showAlpha)])
                        }, [
                          createBaseVNode("span", {
                            class: normalizeClass(unref(ns).be("picker", "color-inner")),
                            style: normalizeStyle({
                              backgroundColor: unref(displayedColor)
                            })
                          }, [
                            withDirectives(createVNode(unref(ElIcon), {
                              class: normalizeClass([unref(ns).be("picker", "icon"), unref(ns).is("icon-arrow-down")])
                            }, {
                              default: withCtx(() => [
                                createVNode(unref(arrow_down_default))
                              ]),
                              _: 1
                            }, 8, ["class"]), [
                              [vShow, _ctx.modelValue || showPanelColor.value]
                            ]),
                            withDirectives(createVNode(unref(ElIcon), {
                              class: normalizeClass([unref(ns).be("picker", "empty"), unref(ns).is("icon-close")])
                            }, {
                              default: withCtx(() => [
                                createVNode(unref(close_default))
                              ]),
                              _: 1
                            }, 8, ["class"]), [
                              [vShow, !_ctx.modelValue && !showPanelColor.value]
                            ])
                          ], 6)
                        ], 2)
                      ], 2)
                    ], 16, ["id", "aria-label", "aria-labelledby", "aria-description", "aria-disabled", "tabindex", "onFocus", "onBlur"])
                  ]),
                  _: 1
                }, 8, ["visible", "popper-class", "teleported", "transition", "onHide"]);
              };
            }
          });
          var ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__file", "color-picker.vue"]]);
          const ElColorPicker = withInstall(ColorPicker);
          const messageConfig = {};
          const REPEAT_INTERVAL = 100;
          const REPEAT_DELAY = 600;
          const vRepeatClick = {
            beforeMount(el, binding) {
              const value = binding.value;
              const { interval = REPEAT_INTERVAL, delay = REPEAT_DELAY } = isFunction$1(value) ? {} : value;
              let intervalId;
              let delayId;
              const handler = () => isFunction$1(value) ? value() : value.handler();
              const clear = () => {
                if (delayId) {
                  clearTimeout(delayId);
                  delayId = void 0;
                }
                if (intervalId) {
                  clearInterval(intervalId);
                  intervalId = void 0;
                }
              };
              el.addEventListener("mousedown", (evt) => {
                if (evt.button !== 0)
                  return;
                clear();
                handler();
                document.addEventListener("mouseup", () => clear(), {
                  once: true
                });
                delayId = setTimeout(() => {
                  intervalId = setInterval(() => {
                    handler();
                  }, interval);
                }, delay);
              });
            }
          };
          const useSameTarget = (handleClick) => {
            if (!handleClick) {
              return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
            }
            let mousedownTarget = false;
            let mouseupTarget = false;
            const onClick = (e) => {
              if (mousedownTarget && mouseupTarget) {
                handleClick(e);
              }
              mousedownTarget = mouseupTarget = false;
            };
            const onMousedown = (e) => {
              mousedownTarget = e.target === e.currentTarget;
            };
            const onMouseup = (e) => {
              mouseupTarget = e.target === e.currentTarget;
            };
            return { onClick, onMousedown, onMouseup };
          };
          const overlayProps = buildProps({
            mask: {
              type: Boolean,
              default: true
            },
            customMaskEvent: Boolean,
            overlayClass: {
              type: definePropType([
                String,
                Array,
                Object
              ])
            },
            zIndex: {
              type: definePropType([String, Number])
            }
          });
          const overlayEmits = {
            click: (evt) => evt instanceof MouseEvent
          };
          const BLOCK = "overlay";
          var Overlay = /* @__PURE__ */ defineComponent({
            name: "ElOverlay",
            props: overlayProps,
            emits: overlayEmits,
            setup(props, { slots, emit: emit2 }) {
              const ns = useNamespace(BLOCK);
              const onMaskClick = (e) => {
                emit2("click", e);
              };
              const { onClick, onMousedown, onMouseup } = useSameTarget(props.customMaskEvent ? void 0 : onMaskClick);
              return () => {
                return props.mask ? createVNode("div", {
                  class: [ns.b(), props.overlayClass],
                  style: {
                    zIndex: props.zIndex
                  },
                  onClick,
                  onMousedown,
                  onMouseup
                }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h("div", {
                  class: props.overlayClass,
                  style: {
                    zIndex: props.zIndex,
                    position: "fixed",
                    top: "0px",
                    right: "0px",
                    bottom: "0px",
                    left: "0px"
                  }
                }, [renderSlot(slots, "default")]);
              };
            }
          });
          const ElOverlay = Overlay;
          const dialogInjectionKey = Symbol("dialogInjectionKey");
          const dialogContentProps = buildProps({
            center: Boolean,
            alignCenter: Boolean,
            closeIcon: {
              type: iconPropType
            },
            draggable: Boolean,
            overflow: Boolean,
            fullscreen: Boolean,
            headerClass: String,
            bodyClass: String,
            footerClass: String,
            showClose: {
              type: Boolean,
              default: true
            },
            title: {
              type: String,
              default: ""
            },
            ariaLevel: {
              type: String,
              default: "2"
            }
          });
          const dialogContentEmits = {
            close: () => true
          };
          const useDraggable = (targetRef, dragRef, draggable2, overflow) => {
            const transform = {
              offsetX: 0,
              offsetY: 0
            };
            const adjustPosition = (moveX, moveY) => {
              if (targetRef.value) {
                const { offsetX, offsetY } = transform;
                const targetRect = targetRef.value.getBoundingClientRect();
                const targetLeft = targetRect.left;
                const targetTop = targetRect.top;
                const targetWidth = targetRect.width;
                const targetHeight = targetRect.height;
                const clientWidth = document.documentElement.clientWidth;
                const clientHeight = document.documentElement.clientHeight;
                const minLeft = -targetLeft + offsetX;
                const minTop = -targetTop + offsetY;
                const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
                const maxTop = clientHeight - targetTop - (targetHeight < clientHeight ? targetHeight : 0) + offsetY;
                if (!(overflow == null ? void 0 : overflow.value)) {
                  moveX = Math.min(Math.max(moveX, minLeft), maxLeft);
                  moveY = Math.min(Math.max(moveY, minTop), maxTop);
                }
                transform.offsetX = moveX;
                transform.offsetY = moveY;
                targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
              }
            };
            const onMousedown = (e) => {
              const downX = e.clientX;
              const downY = e.clientY;
              const { offsetX, offsetY } = transform;
              const onMousemove = (e2) => {
                const moveX = offsetX + e2.clientX - downX;
                const moveY = offsetY + e2.clientY - downY;
                adjustPosition(moveX, moveY);
              };
              const onMouseup = () => {
                document.removeEventListener("mousemove", onMousemove);
                document.removeEventListener("mouseup", onMouseup);
              };
              document.addEventListener("mousemove", onMousemove);
              document.addEventListener("mouseup", onMouseup);
            };
            const onDraggable = () => {
              if (dragRef.value && targetRef.value) {
                dragRef.value.addEventListener("mousedown", onMousedown);
                window.addEventListener("resize", updatePosition);
              }
            };
            const offDraggable = () => {
              if (dragRef.value && targetRef.value) {
                dragRef.value.removeEventListener("mousedown", onMousedown);
                window.removeEventListener("resize", updatePosition);
              }
            };
            const resetPosition = () => {
              transform.offsetX = 0;
              transform.offsetY = 0;
              if (targetRef.value) {
                targetRef.value.style.transform = "";
              }
            };
            const updatePosition = () => {
              const { offsetX, offsetY } = transform;
              adjustPosition(offsetX, offsetY);
            };
            onMounted(() => {
              watchEffect(() => {
                if (draggable2.value) {
                  onDraggable();
                } else {
                  offDraggable();
                }
              });
            });
            onBeforeUnmount(() => {
              offDraggable();
            });
            return {
              resetPosition,
              updatePosition
            };
          };
          const composeRefs = (...refs) => {
            return (el) => {
              refs.forEach((ref2) => {
                if (isFunction$1(ref2)) {
                  ref2(el);
                } else {
                  ref2.value = el;
                }
              });
            };
          };
          const __default__$8 = /* @__PURE__ */ defineComponent({ name: "ElDialogContent" });
          const _sfc_main$e = /* @__PURE__ */ defineComponent({
            ...__default__$8,
            props: dialogContentProps,
            emits: dialogContentEmits,
            setup(__props, { expose }) {
              const props = __props;
              const { t } = useLocale();
              const { Close } = CloseComponents;
              const { dialogRef, headerRef, bodyId, ns, style } = inject(dialogInjectionKey);
              const { focusTrapRef } = inject(FOCUS_TRAP_INJECTION_KEY);
              const dialogKls = computed(() => [
                ns.b(),
                ns.is("fullscreen", props.fullscreen),
                ns.is("draggable", props.draggable),
                ns.is("align-center", props.alignCenter),
                { [ns.m("center")]: props.center }
              ]);
              const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
              const draggable2 = computed(() => props.draggable);
              const overflow = computed(() => props.overflow);
              const { resetPosition, updatePosition } = useDraggable(dialogRef, headerRef, draggable2, overflow);
              expose({
                resetPosition,
                updatePosition
              });
              return (_ctx, _cache) => {
                return openBlock(), createElementBlock("div", {
                  ref: unref(composedDialogRef),
                  class: normalizeClass(unref(dialogKls)),
                  style: normalizeStyle(unref(style)),
                  tabindex: "-1"
                }, [
                  createBaseVNode("header", {
                    ref_key: "headerRef",
                    ref: headerRef,
                    class: normalizeClass([unref(ns).e("header"), _ctx.headerClass, { "show-close": _ctx.showClose }])
                  }, [
                    renderSlot(_ctx.$slots, "header", {}, () => [
                      createBaseVNode("span", {
                        role: "heading",
                        "aria-level": _ctx.ariaLevel,
                        class: normalizeClass(unref(ns).e("title"))
                      }, toDisplayString(_ctx.title), 11, ["aria-level"])
                    ]),
                    _ctx.showClose ? (openBlock(), createElementBlock("button", {
                      key: 0,
                      "aria-label": unref(t)("el.dialog.close"),
                      class: normalizeClass(unref(ns).e("headerbtn")),
                      type: "button",
                      onClick: ($event) => _ctx.$emit("close")
                    }, [
                      createVNode(unref(ElIcon), {
                        class: normalizeClass(unref(ns).e("close"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
                        ]),
                        _: 1
                      }, 8, ["class"])
                    ], 10, ["aria-label", "onClick"])) : createCommentVNode("v-if", true)
                  ], 2),
                  createBaseVNode("div", {
                    id: unref(bodyId),
                    class: normalizeClass([unref(ns).e("body"), _ctx.bodyClass])
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 10, ["id"]),
                  _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
                    key: 0,
                    class: normalizeClass([unref(ns).e("footer"), _ctx.footerClass])
                  }, [
                    renderSlot(_ctx.$slots, "footer")
                  ], 2)) : createCommentVNode("v-if", true)
                ], 6);
              };
            }
          });
          var ElDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__file", "dialog-content.vue"]]);
          const dialogProps = buildProps({
            ...dialogContentProps,
            appendToBody: Boolean,
            appendTo: {
              type: teleportProps.to.type,
              default: "body"
            },
            beforeClose: {
              type: definePropType(Function)
            },
            destroyOnClose: Boolean,
            closeOnClickModal: {
              type: Boolean,
              default: true
            },
            closeOnPressEscape: {
              type: Boolean,
              default: true
            },
            lockScroll: {
              type: Boolean,
              default: true
            },
            modal: {
              type: Boolean,
              default: true
            },
            openDelay: {
              type: Number,
              default: 0
            },
            closeDelay: {
              type: Number,
              default: 0
            },
            top: {
              type: String
            },
            modelValue: Boolean,
            modalClass: String,
            headerClass: String,
            bodyClass: String,
            footerClass: String,
            width: {
              type: [String, Number]
            },
            zIndex: {
              type: Number
            },
            trapFocus: Boolean,
            headerAriaLevel: {
              type: String,
              default: "2"
            }
          });
          const dialogEmits = {
            open: () => true,
            opened: () => true,
            close: () => true,
            closed: () => true,
            [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
            openAutoFocus: () => true,
            closeAutoFocus: () => true
          };
          const useLockscreen = (trigger2, options = {}) => {
            if (!isRef(trigger2)) {
              throwError("[useLockscreen]", "You need to pass a ref param to this function");
            }
            const ns = options.ns || useNamespace("popup");
            const hiddenCls = computed(() => ns.bm("parent", "hidden"));
            if (!isClient || hasClass(document.body, hiddenCls.value)) {
              return;
            }
            let scrollBarWidth2 = 0;
            let withoutHiddenClass = false;
            let bodyWidth = "0";
            const cleanup = () => {
              setTimeout(() => {
                if (typeof document === "undefined")
                  return;
                if (withoutHiddenClass && document) {
                  document.body.style.width = bodyWidth;
                  removeClass(document.body, hiddenCls.value);
                }
              }, 200);
            };
            watch(trigger2, (val) => {
              if (!val) {
                cleanup();
                return;
              }
              withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
              if (withoutHiddenClass) {
                bodyWidth = document.body.style.width;
                addClass(document.body, hiddenCls.value);
              }
              scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
              const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
              const bodyOverflowY = getStyle(document.body, "overflowY");
              if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
                document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
              }
            });
            onScopeDispose(() => cleanup());
          };
          const useDialog = (props, targetRef) => {
            var _a2;
            const instance = getCurrentInstance();
            const emit2 = instance.emit;
            const { nextZIndex } = useZIndex();
            let lastPosition = "";
            const titleId = useId();
            const bodyId = useId();
            const visible = ref(false);
            const closed = ref(false);
            const rendered = ref(false);
            const zIndex2 = ref((_a2 = props.zIndex) != null ? _a2 : nextZIndex());
            let openTimer = void 0;
            let closeTimer = void 0;
            const namespace = useGlobalConfig("namespace", defaultNamespace);
            const style = computed(() => {
              const style2 = {};
              const varPrefix = `--${namespace.value}-dialog`;
              if (!props.fullscreen) {
                if (props.top) {
                  style2[`${varPrefix}-margin-top`] = props.top;
                }
                if (props.width) {
                  style2[`${varPrefix}-width`] = addUnit(props.width);
                }
              }
              return style2;
            });
            const overlayDialogStyle = computed(() => {
              if (props.alignCenter) {
                return { display: "flex" };
              }
              return {};
            });
            function afterEnter() {
              emit2("opened");
            }
            function afterLeave() {
              emit2("closed");
              emit2(UPDATE_MODEL_EVENT, false);
              if (props.destroyOnClose) {
                rendered.value = false;
              }
            }
            function beforeLeave() {
              emit2("close");
            }
            function open() {
              closeTimer == null ? void 0 : closeTimer();
              openTimer == null ? void 0 : openTimer();
              if (props.openDelay && props.openDelay > 0) {
                ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props.openDelay));
              } else {
                doOpen();
              }
            }
            function close() {
              openTimer == null ? void 0 : openTimer();
              closeTimer == null ? void 0 : closeTimer();
              if (props.closeDelay && props.closeDelay > 0) {
                ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props.closeDelay));
              } else {
                doClose();
              }
            }
            function handleClose() {
              function hide(shouldCancel) {
                if (shouldCancel)
                  return;
                closed.value = true;
                visible.value = false;
              }
              if (props.beforeClose) {
                props.beforeClose(hide);
              } else {
                close();
              }
            }
            function onModalClick() {
              if (props.closeOnClickModal) {
                handleClose();
              }
            }
            function doOpen() {
              if (!isClient)
                return;
              visible.value = true;
            }
            function doClose() {
              visible.value = false;
            }
            function onOpenAutoFocus() {
              emit2("openAutoFocus");
            }
            function onCloseAutoFocus() {
              emit2("closeAutoFocus");
            }
            function onFocusoutPrevented(event) {
              var _a22;
              if (((_a22 = event.detail) == null ? void 0 : _a22.focusReason) === "pointer") {
                event.preventDefault();
              }
            }
            if (props.lockScroll) {
              useLockscreen(visible);
            }
            function onCloseRequested() {
              if (props.closeOnPressEscape) {
                handleClose();
              }
            }
            watch(() => props.zIndex, () => {
              var _a22;
              zIndex2.value = (_a22 = props.zIndex) != null ? _a22 : nextZIndex();
            });
            watch(() => props.modelValue, (val) => {
              var _a22;
              if (val) {
                closed.value = false;
                open();
                rendered.value = true;
                zIndex2.value = (_a22 = props.zIndex) != null ? _a22 : nextZIndex();
                nextTick(() => {
                  emit2("open");
                  if (targetRef.value) {
                    targetRef.value.parentElement.scrollTop = 0;
                    targetRef.value.parentElement.scrollLeft = 0;
                    targetRef.value.scrollTop = 0;
                  }
                });
              } else {
                if (visible.value) {
                  close();
                }
              }
            });
            watch(() => props.fullscreen, (val) => {
              if (!targetRef.value)
                return;
              if (val) {
                lastPosition = targetRef.value.style.transform;
                targetRef.value.style.transform = "";
              } else {
                targetRef.value.style.transform = lastPosition;
              }
            });
            onMounted(() => {
              if (props.modelValue) {
                visible.value = true;
                rendered.value = true;
                open();
              }
            });
            return {
              afterEnter,
              afterLeave,
              beforeLeave,
              handleClose,
              onModalClick,
              close,
              doClose,
              onOpenAutoFocus,
              onCloseAutoFocus,
              onCloseRequested,
              onFocusoutPrevented,
              titleId,
              bodyId,
              closed,
              style,
              overlayDialogStyle,
              rendered,
              visible,
              zIndex: zIndex2
            };
          };
          const __default__$7 = /* @__PURE__ */ defineComponent({
            name: "ElDialog",
            inheritAttrs: false
          });
          const _sfc_main$d = /* @__PURE__ */ defineComponent({
            ...__default__$7,
            props: dialogProps,
            emits: dialogEmits,
            setup(__props, { expose }) {
              const props = __props;
              const slots = useSlots();
              useDeprecated({
                scope: "el-dialog",
                from: "the title slot",
                replacement: "the header slot",
                version: "3.0.0",
                ref: "https://element-plus.org/en-US/component/dialog.html#slots"
              }, computed(() => !!slots.title));
              const ns = useNamespace("dialog");
              const dialogRef = ref();
              const headerRef = ref();
              const dialogContentRef = ref();
              const {
                visible,
                titleId,
                bodyId,
                style,
                overlayDialogStyle,
                rendered,
                zIndex: zIndex2,
                afterEnter,
                afterLeave,
                beforeLeave,
                handleClose,
                onModalClick,
                onOpenAutoFocus,
                onCloseAutoFocus,
                onCloseRequested,
                onFocusoutPrevented
              } = useDialog(props, dialogRef);
              provide(dialogInjectionKey, {
                dialogRef,
                headerRef,
                bodyId,
                ns,
                rendered,
                style
              });
              const overlayEvent = useSameTarget(onModalClick);
              const draggable2 = computed(() => props.draggable && !props.fullscreen);
              const resetPosition = () => {
                var _a2;
                (_a2 = dialogContentRef.value) == null ? void 0 : _a2.resetPosition();
              };
              expose({
                visible,
                dialogContentRef,
                resetPosition,
                handleClose
              });
              return (_ctx, _cache) => {
                return openBlock(), createBlock(unref(ElTeleport), {
                  to: _ctx.appendTo,
                  disabled: _ctx.appendTo !== "body" ? false : !_ctx.appendToBody
                }, {
                  default: withCtx(() => [
                    createVNode(Transition, {
                      name: "dialog-fade",
                      onAfterEnter: unref(afterEnter),
                      onAfterLeave: unref(afterLeave),
                      onBeforeLeave: unref(beforeLeave),
                      persisted: ""
                    }, {
                      default: withCtx(() => [
                        withDirectives(createVNode(unref(ElOverlay), {
                          "custom-mask-event": "",
                          mask: _ctx.modal,
                          "overlay-class": _ctx.modalClass,
                          "z-index": unref(zIndex2)
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("div", {
                              role: "dialog",
                              "aria-modal": "true",
                              "aria-label": _ctx.title || void 0,
                              "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                              "aria-describedby": unref(bodyId),
                              class: normalizeClass(`${unref(ns).namespace.value}-overlay-dialog`),
                              style: normalizeStyle(unref(overlayDialogStyle)),
                              onClick: unref(overlayEvent).onClick,
                              onMousedown: unref(overlayEvent).onMousedown,
                              onMouseup: unref(overlayEvent).onMouseup
                            }, [
                              createVNode(unref(ElFocusTrap), {
                                loop: "",
                                trapped: unref(visible),
                                "focus-start-el": "container",
                                onFocusAfterTrapped: unref(onOpenAutoFocus),
                                onFocusAfterReleased: unref(onCloseAutoFocus),
                                onFocusoutPrevented: unref(onFocusoutPrevented),
                                onReleaseRequested: unref(onCloseRequested)
                              }, {
                                default: withCtx(() => [
                                  unref(rendered) ? (openBlock(), createBlock(ElDialogContent, mergeProps({
                                    key: 0,
                                    ref_key: "dialogContentRef",
                                    ref: dialogContentRef
                                  }, _ctx.$attrs, {
                                    center: _ctx.center,
                                    "align-center": _ctx.alignCenter,
                                    "close-icon": _ctx.closeIcon,
                                    draggable: unref(draggable2),
                                    overflow: _ctx.overflow,
                                    fullscreen: _ctx.fullscreen,
                                    "header-class": _ctx.headerClass,
                                    "body-class": _ctx.bodyClass,
                                    "footer-class": _ctx.footerClass,
                                    "show-close": _ctx.showClose,
                                    title: _ctx.title,
                                    "aria-level": _ctx.headerAriaLevel,
                                    onClose: unref(handleClose)
                                  }), createSlots({
                                    header: withCtx(() => [
                                      !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                                        key: 0,
                                        close: unref(handleClose),
                                        titleId: unref(titleId),
                                        titleClass: unref(ns).e("title")
                                      }) : renderSlot(_ctx.$slots, "title", { key: 1 })
                                    ]),
                                    default: withCtx(() => [
                                      renderSlot(_ctx.$slots, "default")
                                    ]),
                                    _: 2
                                  }, [
                                    _ctx.$slots.footer ? {
                                      name: "footer",
                                      fn: withCtx(() => [
                                        renderSlot(_ctx.$slots, "footer")
                                      ])
                                    } : void 0
                                  ]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "header-class", "body-class", "footer-class", "show-close", "title", "aria-level", "onClose"])) : createCommentVNode("v-if", true)
                                ]),
                                _: 3
                              }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                            ], 46, ["aria-label", "aria-labelledby", "aria-describedby", "onClick", "onMousedown", "onMouseup"])
                          ]),
                          _: 3
                        }, 8, ["mask", "overlay-class", "z-index"]), [
                          [vShow, unref(visible)]
                        ])
                      ]),
                      _: 3
                    }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
                  ]),
                  _: 3
                }, 8, ["to", "disabled"]);
              };
            }
          });
          var Dialog = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__file", "dialog.vue"]]);
          const ElDialog = withInstall(Dialog);
          const formMetaProps = buildProps({
            size: {
              type: String,
              values: componentSizes
            },
            disabled: Boolean
          });
          const formProps = buildProps({
            ...formMetaProps,
            model: Object,
            rules: {
              type: definePropType(Object)
            },
            labelPosition: {
              type: String,
              values: ["left", "right", "top"],
              default: "right"
            },
            requireAsteriskPosition: {
              type: String,
              values: ["left", "right"],
              default: "left"
            },
            labelWidth: {
              type: [String, Number],
              default: ""
            },
            labelSuffix: {
              type: String,
              default: ""
            },
            inline: Boolean,
            inlineMessage: Boolean,
            statusIcon: Boolean,
            showMessage: {
              type: Boolean,
              default: true
            },
            validateOnRuleChange: {
              type: Boolean,
              default: true
            },
            hideRequiredAsterisk: Boolean,
            scrollToError: Boolean,
            scrollIntoViewOptions: {
              type: [Object, Boolean],
              default: true
            }
          });
          const formEmits = {
            validate: (prop, isValid, message2) => (isArray$1(prop) || isString$1(prop)) && isBoolean(isValid) && isString$1(message2)
          };
          function useFormLabelWidth() {
            const potentialLabelWidthArr = ref([]);
            const autoLabelWidth = computed(() => {
              if (!potentialLabelWidthArr.value.length)
                return "0";
              const max = Math.max(...potentialLabelWidthArr.value);
              return max ? `${max}px` : "";
            });
            function getLabelWidthIndex(width) {
              const index = potentialLabelWidthArr.value.indexOf(width);
              if (index === -1 && autoLabelWidth.value === "0") ;
              return index;
            }
            function registerLabelWidth(val, oldVal) {
              if (val && oldVal) {
                const index = getLabelWidthIndex(oldVal);
                potentialLabelWidthArr.value.splice(index, 1, val);
              } else if (val) {
                potentialLabelWidthArr.value.push(val);
              }
            }
            function deregisterLabelWidth(val) {
              const index = getLabelWidthIndex(val);
              if (index > -1) {
                potentialLabelWidthArr.value.splice(index, 1);
              }
            }
            return {
              autoLabelWidth,
              registerLabelWidth,
              deregisterLabelWidth
            };
          }
          const filterFields = (fields, props) => {
            const normalized = castArray(props).map((prop) => isArray$1(prop) ? prop.join(".") : prop);
            return normalized.length > 0 ? fields.filter((field) => field.propString && normalized.includes(field.propString)) : fields;
          };
          const COMPONENT_NAME$5 = "ElForm";
          const __default__$6 = /* @__PURE__ */ defineComponent({
            name: COMPONENT_NAME$5
          });
          const _sfc_main$c = /* @__PURE__ */ defineComponent({
            ...__default__$6,
            props: formProps,
            emits: formEmits,
            setup(__props, { expose, emit: emit2 }) {
              const props = __props;
              const formRef = ref();
              const fields = reactive([]);
              const formSize = useFormSize();
              const ns = useNamespace("form");
              const formClasses = computed(() => {
                const { labelPosition, inline } = props;
                return [
                  ns.b(),
                  ns.m(formSize.value || "default"),
                  {
                    [ns.m(`label-${labelPosition}`)]: labelPosition,
                    [ns.m("inline")]: inline
                  }
                ];
              });
              const getField = (prop) => {
                return filterFields(fields, [prop])[0];
              };
              const addField = (field) => {
                fields.push(field);
              };
              const removeField = (field) => {
                if (field.prop) {
                  fields.splice(fields.indexOf(field), 1);
                }
              };
              const resetFields = (properties = []) => {
                if (!props.model) {
                  return;
                }
                filterFields(fields, properties).forEach((field) => field.resetField());
              };
              const clearValidate = (props2 = []) => {
                filterFields(fields, props2).forEach((field) => field.clearValidate());
              };
              const isValidatable = computed(() => {
                const hasModel = !!props.model;
                return hasModel;
              });
              const obtainValidateFields = (props2) => {
                if (fields.length === 0)
                  return [];
                const filteredFields = filterFields(fields, props2);
                if (!filteredFields.length) {
                  return [];
                }
                return filteredFields;
              };
              const validate = async (callback) => validateField(void 0, callback);
              const doValidateField = async (props2 = []) => {
                if (!isValidatable.value)
                  return false;
                const fields2 = obtainValidateFields(props2);
                if (fields2.length === 0)
                  return true;
                let validationErrors = {};
                for (const field of fields2) {
                  try {
                    await field.validate("");
                    if (field.validateState === "error")
                      field.resetField();
                  } catch (fields3) {
                    validationErrors = {
                      ...validationErrors,
                      ...fields3
                    };
                  }
                }
                if (Object.keys(validationErrors).length === 0)
                  return true;
                return Promise.reject(validationErrors);
              };
              const validateField = async (modelProps = [], callback) => {
                let result = false;
                const shouldThrow = !isFunction$1(callback);
                try {
                  result = await doValidateField(modelProps);
                  if (result === true) {
                    await (callback == null ? void 0 : callback(result));
                  }
                  return result;
                } catch (e) {
                  if (e instanceof Error)
                    throw e;
                  const invalidFields = e;
                  if (props.scrollToError) {
                    if (formRef.value) {
                      const formItem = formRef.value.querySelector(`.${ns.b()}-item.is-error`);
                      formItem == null ? void 0 : formItem.scrollIntoView(props.scrollIntoViewOptions);
                    }
                  }
                  !result && await (callback == null ? void 0 : callback(false, invalidFields));
                  return shouldThrow && Promise.reject(invalidFields);
                }
              };
              const scrollToField = (prop) => {
                var _a2;
                const field = getField(prop);
                if (field) {
                  (_a2 = field.$el) == null ? void 0 : _a2.scrollIntoView(props.scrollIntoViewOptions);
                }
              };
              watch(() => props.rules, () => {
                if (props.validateOnRuleChange) {
                  validate().catch((err) => debugWarn());
                }
              }, { deep: true, flush: "post" });
              provide(formContextKey, reactive({
                ...toRefs(props),
                emit: emit2,
                resetFields,
                clearValidate,
                validateField,
                getField,
                addField,
                removeField,
                ...useFormLabelWidth()
              }));
              expose({
                validate,
                validateField,
                resetFields,
                clearValidate,
                scrollToField,
                getField,
                fields
              });
              return (_ctx, _cache) => {
                return openBlock(), createElementBlock("form", {
                  ref_key: "formRef",
                  ref: formRef,
                  class: normalizeClass(unref(formClasses))
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2);
              };
            }
          });
          var Form = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__file", "form.vue"]]);
          function _extends() {
            _extends = Object.assign ? Object.assign.bind() : function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            return _extends.apply(this, arguments);
          }
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            _setPrototypeOf(subClass, superClass);
          }
          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf(o);
          }
          function _setPrototypeOf(o, p2) {
            _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p22) {
              o2.__proto__ = p22;
              return o2;
            };
            return _setPrototypeOf(o, p2);
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if (typeof Proxy === "function") return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _construct(Parent, args, Class) {
            if (_isNativeReflectConstruct()) {
              _construct = Reflect.construct.bind();
            } else {
              _construct = function _construct2(Parent2, args2, Class2) {
                var a = [null];
                a.push.apply(a, args2);
                var Constructor = Function.bind.apply(Parent2, a);
                var instance = new Constructor();
                if (Class2) _setPrototypeOf(instance, Class2.prototype);
                return instance;
              };
            }
            return _construct.apply(null, arguments);
          }
          function _isNativeFunction(fn2) {
            return Function.toString.call(fn2).indexOf("[native code]") !== -1;
          }
          function _wrapNativeSuper(Class) {
            var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
            _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
              if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
              if (typeof Class2 !== "function") {
                throw new TypeError("Super expression must either be null or a function");
              }
              if (typeof _cache !== "undefined") {
                if (_cache.has(Class2)) return _cache.get(Class2);
                _cache.set(Class2, Wrapper);
              }
              function Wrapper() {
                return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
              }
              Wrapper.prototype = Object.create(Class2.prototype, {
                constructor: {
                  value: Wrapper,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
              return _setPrototypeOf(Wrapper, Class2);
            };
            return _wrapNativeSuper(Class);
          }
          var formatRegExp = /%[sdj%]/g;
          var warning = function warning2() {
          };
          function convertFieldsError(errors) {
            if (!errors || !errors.length) return null;
            var fields = {};
            errors.forEach(function(error) {
              var field = error.field;
              fields[field] = fields[field] || [];
              fields[field].push(error);
            });
            return fields;
          }
          function format(template) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            var i = 0;
            var len = args.length;
            if (typeof template === "function") {
              return template.apply(null, args);
            }
            if (typeof template === "string") {
              var str = template.replace(formatRegExp, function(x) {
                if (x === "%%") {
                  return "%";
                }
                if (i >= len) {
                  return x;
                }
                switch (x) {
                  case "%s":
                    return String(args[i++]);
                  case "%d":
                    return Number(args[i++]);
                  case "%j":
                    try {
                      return JSON.stringify(args[i++]);
                    } catch (_) {
                      return "[Circular]";
                    }
                    break;
                  default:
                    return x;
                }
              });
              return str;
            }
            return template;
          }
          function isNativeStringType(type4) {
            return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
          }
          function isEmptyValue(value, type4) {
            if (value === void 0 || value === null) {
              return true;
            }
            if (type4 === "array" && Array.isArray(value) && !value.length) {
              return true;
            }
            if (isNativeStringType(type4) && typeof value === "string" && !value) {
              return true;
            }
            return false;
          }
          function asyncParallelArray(arr, func, callback) {
            var results = [];
            var total = 0;
            var arrLength = arr.length;
            function count(errors) {
              results.push.apply(results, errors || []);
              total++;
              if (total === arrLength) {
                callback(results);
              }
            }
            arr.forEach(function(a) {
              func(a, count);
            });
          }
          function asyncSerialArray(arr, func, callback) {
            var index = 0;
            var arrLength = arr.length;
            function next(errors) {
              if (errors && errors.length) {
                callback(errors);
                return;
              }
              var original = index;
              index = index + 1;
              if (original < arrLength) {
                func(arr[original], next);
              } else {
                callback([]);
              }
            }
            next([]);
          }
          function flattenObjArr(objArr) {
            var ret = [];
            Object.keys(objArr).forEach(function(k) {
              ret.push.apply(ret, objArr[k] || []);
            });
            return ret;
          }
          var AsyncValidationError = /* @__PURE__ */ function(_Error) {
            _inheritsLoose(AsyncValidationError2, _Error);
            function AsyncValidationError2(errors, fields) {
              var _this;
              _this = _Error.call(this, "Async Validation Error") || this;
              _this.errors = errors;
              _this.fields = fields;
              return _this;
            }
            return AsyncValidationError2;
          }(/* @__PURE__ */ _wrapNativeSuper(Error));
          function asyncMap(objArr, option, func, callback, source) {
            if (option.first) {
              var _pending = new Promise(function(resolve2, reject) {
                var next = function next2(errors) {
                  callback(errors);
                  return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
                };
                var flattenArr = flattenObjArr(objArr);
                asyncSerialArray(flattenArr, func, next);
              });
              _pending["catch"](function(e) {
                return e;
              });
              return _pending;
            }
            var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
            var objArrKeys = Object.keys(objArr);
            var objArrLength = objArrKeys.length;
            var total = 0;
            var results = [];
            var pending = new Promise(function(resolve2, reject) {
              var next = function next2(errors) {
                results.push.apply(results, errors);
                total++;
                if (total === objArrLength) {
                  callback(results);
                  return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
                }
              };
              if (!objArrKeys.length) {
                callback(results);
                resolve2(source);
              }
              objArrKeys.forEach(function(key) {
                var arr = objArr[key];
                if (firstFields.indexOf(key) !== -1) {
                  asyncSerialArray(arr, func, next);
                } else {
                  asyncParallelArray(arr, func, next);
                }
              });
            });
            pending["catch"](function(e) {
              return e;
            });
            return pending;
          }
          function isErrorObj(obj) {
            return !!(obj && obj.message !== void 0);
          }
          function getValue(value, path) {
            var v = value;
            for (var i = 0; i < path.length; i++) {
              if (v == void 0) {
                return v;
              }
              v = v[path[i]];
            }
            return v;
          }
          function complementError(rule, source) {
            return function(oe) {
              var fieldValue;
              if (rule.fullFields) {
                fieldValue = getValue(source, rule.fullFields);
              } else {
                fieldValue = source[oe.field || rule.fullField];
              }
              if (isErrorObj(oe)) {
                oe.field = oe.field || rule.fullField;
                oe.fieldValue = fieldValue;
                return oe;
              }
              return {
                message: typeof oe === "function" ? oe() : oe,
                fieldValue,
                field: oe.field || rule.fullField
              };
            };
          }
          function deepMerge(target, source) {
            if (source) {
              for (var s in source) {
                if (source.hasOwnProperty(s)) {
                  var value = source[s];
                  if (typeof value === "object" && typeof target[s] === "object") {
                    target[s] = _extends({}, target[s], value);
                  } else {
                    target[s] = value;
                  }
                }
              }
            }
            return target;
          }
          var required$1 = function required(rule, value, source, errors, options, type4) {
            if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
              errors.push(format(options.messages.required, rule.fullField));
            }
          };
          var whitespace = function whitespace2(rule, value, source, errors, options) {
            if (/^\s+$/.test(value) || value === "") {
              errors.push(format(options.messages.whitespace, rule.fullField));
            }
          };
          var urlReg;
          var getUrlRegex = function() {
            if (urlReg) {
              return urlReg;
            }
            var word = "[a-fA-F\\d:]";
            var b = function b2(options) {
              return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
            };
            var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
            var v6seg = "[a-fA-F\\d]{1,4}";
            var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
            var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
            var v4exact = new RegExp("^" + v4 + "$");
            var v6exact = new RegExp("^" + v6 + "$");
            var ip = function ip2(options) {
              return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
            };
            ip.v4 = function(options) {
              return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
            };
            ip.v6 = function(options) {
              return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
            };
            var protocol = "(?:(?:[a-z]+:)?//)";
            var auth = "(?:\\S+(?::\\S*)?@)?";
            var ipv4 = ip.v4().source;
            var ipv6 = ip.v6().source;
            var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
            var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
            var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
            var port = "(?::\\d{2,5})?";
            var path = '(?:[/?#][^\\s"]*)?';
            var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
            urlReg = new RegExp("(?:^" + regex + "$)", "i");
            return urlReg;
          };
          var pattern$2 = {
            // http://emailregex.com/
            email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
            // url: new RegExp(
            //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
            //   'i',
            // ),
            hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
          };
          var types = {
            integer: function integer(value) {
              return types.number(value) && parseInt(value, 10) === value;
            },
            "float": function float(value) {
              return types.number(value) && !types.integer(value);
            },
            array: function array(value) {
              return Array.isArray(value);
            },
            regexp: function regexp(value) {
              if (value instanceof RegExp) {
                return true;
              }
              try {
                return !!new RegExp(value);
              } catch (e) {
                return false;
              }
            },
            date: function date(value) {
              return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
            },
            number: function number(value) {
              if (isNaN(value)) {
                return false;
              }
              return typeof value === "number";
            },
            object: function object(value) {
              return typeof value === "object" && !types.array(value);
            },
            method: function method(value) {
              return typeof value === "function";
            },
            email: function email(value) {
              return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
            },
            url: function url(value) {
              return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
            },
            hex: function hex(value) {
              return typeof value === "string" && !!value.match(pattern$2.hex);
            }
          };
          var type$1 = function type(rule, value, source, errors, options) {
            if (rule.required && value === void 0) {
              required$1(rule, value, source, errors, options);
              return;
            }
            var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
            var ruleType = rule.type;
            if (custom.indexOf(ruleType) > -1) {
              if (!types[ruleType](value)) {
                errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
              }
            } else if (ruleType && typeof value !== rule.type) {
              errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
            }
          };
          var range = function range2(rule, value, source, errors, options) {
            var len = typeof rule.len === "number";
            var min = typeof rule.min === "number";
            var max = typeof rule.max === "number";
            var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
            var val = value;
            var key = null;
            var num = typeof value === "number";
            var str = typeof value === "string";
            var arr = Array.isArray(value);
            if (num) {
              key = "number";
            } else if (str) {
              key = "string";
            } else if (arr) {
              key = "array";
            }
            if (!key) {
              return false;
            }
            if (arr) {
              val = value.length;
            }
            if (str) {
              val = value.replace(spRegexp, "_").length;
            }
            if (len) {
              if (val !== rule.len) {
                errors.push(format(options.messages[key].len, rule.fullField, rule.len));
              }
            } else if (min && !max && val < rule.min) {
              errors.push(format(options.messages[key].min, rule.fullField, rule.min));
            } else if (max && !min && val > rule.max) {
              errors.push(format(options.messages[key].max, rule.fullField, rule.max));
            } else if (min && max && (val < rule.min || val > rule.max)) {
              errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
            }
          };
          var ENUM$1 = "enum";
          var enumerable$1 = function enumerable(rule, value, source, errors, options) {
            rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
            if (rule[ENUM$1].indexOf(value) === -1) {
              errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
            }
          };
          var pattern$1 = function pattern(rule, value, source, errors, options) {
            if (rule.pattern) {
              if (rule.pattern instanceof RegExp) {
                rule.pattern.lastIndex = 0;
                if (!rule.pattern.test(value)) {
                  errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
                }
              } else if (typeof rule.pattern === "string") {
                var _pattern = new RegExp(rule.pattern);
                if (!_pattern.test(value)) {
                  errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
                }
              }
            }
          };
          var rules = {
            required: required$1,
            whitespace,
            type: type$1,
            range,
            "enum": enumerable$1,
            pattern: pattern$1
          };
          var string = function string2(rule, value, callback, source, options) {
            var errors = [];
            var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
            if (validate) {
              if (isEmptyValue(value, "string") && !rule.required) {
                return callback();
              }
              rules.required(rule, value, source, errors, options, "string");
              if (!isEmptyValue(value, "string")) {
                rules.type(rule, value, source, errors, options);
                rules.range(rule, value, source, errors, options);
                rules.pattern(rule, value, source, errors, options);
                if (rule.whitespace === true) {
                  rules.whitespace(rule, value, source, errors, options);
                }
              }
            }
            callback(errors);
          };
          var method2 = function method3(rule, value, callback, source, options) {
            var errors = [];
            var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
            if (validate) {
              if (isEmptyValue(value) && !rule.required) {
                return callback();
              }
              rules.required(rule, value, source, errors, options);
              if (value !== void 0) {
                rules.type(rule, value, source, errors, options);
              }
            }
            callback(errors);
          };
          var number2 = function number3(rule, value, callback, source, options) {
            var errors = [];
            var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
            if (validate) {
              if (value === "") {
                value = void 0;
              }
              if (isEmptyValue(value) && !rule.required) {
                return callback();
              }
              rules.required(rule, value, source, errors, options);
              if (value !== void 0) {
                rules.type(rule, value, source, errors, options);
                rules.range(rule, value, source, errors, options);
              }
            }
            callback(errors);
          };
          var _boolean = function _boolean2(rule, value, callback, source, options) {
            var errors = [];
            var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
            if (validate) {
              if (isEmptyValue(value) && !rule.required) {
                return callback();
              }
              rules.required(rule, value, source, errors, options);
              if (value !== void 0) {
                rules.type(rule, value, source, errors, options);
              }
            }
            callback(errors);
          };
          var regexp2 = function regexp3(rule, value, callback, source, options) {
            var errors = [];
            var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
            if (validate) {
              if (isEmptyValue(value) && !rule.required) {
                return callback();
              }
              rules.required(rule, value, source, errors, options);
              if (!isEmptyValue(value)) {
                rules.type(rule, value, source, errors, options);
              }
            }
            callback(errors);
          };
          var integer2 = function integer3(rule, value, callback, source, options) {
            var errors = [];
            var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
            if (validate) {
              if (isEmptyValue(value) && !rule.required) {
                return callback();
              }
              rules.required(rule, value, source, errors, options);
              if (value !== void 0) {
                rules.type(rule, value, source, errors, options);
                rules.range(rule, value, source, errors, options);
              }
            }
            callback(errors);
          };
          var floatFn = function floatFn2(rule, value, callback, source, options) {
            var errors = [];
            var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
            if (validate) {
              if (isEmptyValue(value) && !rule.required) {
                return callback();
              }
              rules.required(rule, value, source, errors, options);
              if (value !== void 0) {
                rules.type(rule, value, source, errors, options);
                rules.range(rule, value, source, errors, options);
              }
            }
            callback(errors);
          };
          var array2 = function array3(rule, value, callback, source, options) {
            var errors = [];
            var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
            if (validate) {
              if ((value === void 0 || value === null) && !rule.required) {
                return callback();
              }
              rules.required(rule, value, source, errors, options, "array");
              if (value !== void 0 && value !== null) {
                rules.type(rule, value, source, errors, options);
                rules.range(rule, value, source, errors, options);
              }
            }
            callback(errors);
          };
          var object2 = function object3(rule, value, callback, source, options) {
            var errors = [];
            var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
            if (validate) {
              if (isEmptyValue(value) && !rule.required) {
                return callback();
              }
              rules.required(rule, value, source, errors, options);
              if (value !== void 0) {
                rules.type(rule, value, source, errors, options);
              }
            }
            callback(errors);
          };
          var ENUM = "enum";
          var enumerable2 = function enumerable3(rule, value, callback, source, options) {
            var errors = [];
            var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
            if (validate) {
              if (isEmptyValue(value) && !rule.required) {
                return callback();
              }
              rules.required(rule, value, source, errors, options);
              if (value !== void 0) {
                rules[ENUM](rule, value, source, errors, options);
              }
            }
            callback(errors);
          };
          var pattern2 = function pattern3(rule, value, callback, source, options) {
            var errors = [];
            var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
            if (validate) {
              if (isEmptyValue(value, "string") && !rule.required) {
                return callback();
              }
              rules.required(rule, value, source, errors, options);
              if (!isEmptyValue(value, "string")) {
                rules.pattern(rule, value, source, errors, options);
              }
            }
            callback(errors);
          };
          var date2 = function date3(rule, value, callback, source, options) {
            var errors = [];
            var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
            if (validate) {
              if (isEmptyValue(value, "date") && !rule.required) {
                return callback();
              }
              rules.required(rule, value, source, errors, options);
              if (!isEmptyValue(value, "date")) {
                var dateObject;
                if (value instanceof Date) {
                  dateObject = value;
                } else {
                  dateObject = new Date(value);
                }
                rules.type(rule, dateObject, source, errors, options);
                if (dateObject) {
                  rules.range(rule, dateObject.getTime(), source, errors, options);
                }
              }
            }
            callback(errors);
          };
          var required2 = function required3(rule, value, callback, source, options) {
            var errors = [];
            var type4 = Array.isArray(value) ? "array" : typeof value;
            rules.required(rule, value, source, errors, options, type4);
            callback(errors);
          };
          var type2 = function type3(rule, value, callback, source, options) {
            var ruleType = rule.type;
            var errors = [];
            var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
            if (validate) {
              if (isEmptyValue(value, ruleType) && !rule.required) {
                return callback();
              }
              rules.required(rule, value, source, errors, options, ruleType);
              if (!isEmptyValue(value, ruleType)) {
                rules.type(rule, value, source, errors, options);
              }
            }
            callback(errors);
          };
          var any = function any2(rule, value, callback, source, options) {
            var errors = [];
            var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
            if (validate) {
              if (isEmptyValue(value) && !rule.required) {
                return callback();
              }
              rules.required(rule, value, source, errors, options);
            }
            callback(errors);
          };
          var validators = {
            string,
            method: method2,
            number: number2,
            "boolean": _boolean,
            regexp: regexp2,
            integer: integer2,
            "float": floatFn,
            array: array2,
            object: object2,
            "enum": enumerable2,
            pattern: pattern2,
            date: date2,
            url: type2,
            hex: type2,
            email: type2,
            required: required2,
            any
          };
          function newMessages() {
            return {
              "default": "Validation error on field %s",
              required: "%s is required",
              "enum": "%s must be one of %s",
              whitespace: "%s cannot be empty",
              date: {
                format: "%s date %s is invalid for format %s",
                parse: "%s date could not be parsed, %s is invalid ",
                invalid: "%s date %s is invalid"
              },
              types: {
                string: "%s is not a %s",
                method: "%s is not a %s (function)",
                array: "%s is not an %s",
                object: "%s is not an %s",
                number: "%s is not a %s",
                date: "%s is not a %s",
                "boolean": "%s is not a %s",
                integer: "%s is not an %s",
                "float": "%s is not a %s",
                regexp: "%s is not a valid %s",
                email: "%s is not a valid %s",
                url: "%s is not a valid %s",
                hex: "%s is not a valid %s"
              },
              string: {
                len: "%s must be exactly %s characters",
                min: "%s must be at least %s characters",
                max: "%s cannot be longer than %s characters",
                range: "%s must be between %s and %s characters"
              },
              number: {
                len: "%s must equal %s",
                min: "%s cannot be less than %s",
                max: "%s cannot be greater than %s",
                range: "%s must be between %s and %s"
              },
              array: {
                len: "%s must be exactly %s in length",
                min: "%s cannot be less than %s in length",
                max: "%s cannot be greater than %s in length",
                range: "%s must be between %s and %s in length"
              },
              pattern: {
                mismatch: "%s value %s does not match pattern %s"
              },
              clone: function clone2() {
                var cloned = JSON.parse(JSON.stringify(this));
                cloned.clone = this.clone;
                return cloned;
              }
            };
          }
          var messages = newMessages();
          var Schema = /* @__PURE__ */ function() {
            function Schema2(descriptor) {
              this.rules = null;
              this._messages = messages;
              this.define(descriptor);
            }
            var _proto = Schema2.prototype;
            _proto.define = function define(rules2) {
              var _this = this;
              if (!rules2) {
                throw new Error("Cannot configure a schema with no rules");
              }
              if (typeof rules2 !== "object" || Array.isArray(rules2)) {
                throw new Error("Rules must be an object");
              }
              this.rules = {};
              Object.keys(rules2).forEach(function(name) {
                var item = rules2[name];
                _this.rules[name] = Array.isArray(item) ? item : [item];
              });
            };
            _proto.messages = function messages2(_messages) {
              if (_messages) {
                this._messages = deepMerge(newMessages(), _messages);
              }
              return this._messages;
            };
            _proto.validate = function validate(source_, o, oc) {
              var _this2 = this;
              if (o === void 0) {
                o = {};
              }
              if (oc === void 0) {
                oc = function oc2() {
                };
              }
              var source = source_;
              var options = o;
              var callback = oc;
              if (typeof options === "function") {
                callback = options;
                options = {};
              }
              if (!this.rules || Object.keys(this.rules).length === 0) {
                if (callback) {
                  callback(null, source);
                }
                return Promise.resolve(source);
              }
              function complete(results) {
                var errors = [];
                var fields = {};
                function add(e) {
                  if (Array.isArray(e)) {
                    var _errors;
                    errors = (_errors = errors).concat.apply(_errors, e);
                  } else {
                    errors.push(e);
                  }
                }
                for (var i = 0; i < results.length; i++) {
                  add(results[i]);
                }
                if (!errors.length) {
                  callback(null, source);
                } else {
                  fields = convertFieldsError(errors);
                  callback(errors, fields);
                }
              }
              if (options.messages) {
                var messages$1 = this.messages();
                if (messages$1 === messages) {
                  messages$1 = newMessages();
                }
                deepMerge(messages$1, options.messages);
                options.messages = messages$1;
              } else {
                options.messages = this.messages();
              }
              var series = {};
              var keys2 = options.keys || Object.keys(this.rules);
              keys2.forEach(function(z) {
                var arr = _this2.rules[z];
                var value = source[z];
                arr.forEach(function(r) {
                  var rule = r;
                  if (typeof rule.transform === "function") {
                    if (source === source_) {
                      source = _extends({}, source);
                    }
                    value = source[z] = rule.transform(value);
                  }
                  if (typeof rule === "function") {
                    rule = {
                      validator: rule
                    };
                  } else {
                    rule = _extends({}, rule);
                  }
                  rule.validator = _this2.getValidationMethod(rule);
                  if (!rule.validator) {
                    return;
                  }
                  rule.field = z;
                  rule.fullField = rule.fullField || z;
                  rule.type = _this2.getType(rule);
                  series[z] = series[z] || [];
                  series[z].push({
                    rule,
                    value,
                    source,
                    field: z
                  });
                });
              });
              var errorFields = {};
              return asyncMap(series, options, function(data, doIt) {
                var rule = data.rule;
                var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
                deep = deep && (rule.required || !rule.required && data.value);
                rule.field = data.field;
                function addFullField(key, schema) {
                  return _extends({}, schema, {
                    fullField: rule.fullField + "." + key,
                    fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
                  });
                }
                function cb(e) {
                  if (e === void 0) {
                    e = [];
                  }
                  var errorList = Array.isArray(e) ? e : [e];
                  if (!options.suppressWarning && errorList.length) {
                    Schema2.warning("async-validator:", errorList);
                  }
                  if (errorList.length && rule.message !== void 0) {
                    errorList = [].concat(rule.message);
                  }
                  var filledErrors = errorList.map(complementError(rule, source));
                  if (options.first && filledErrors.length) {
                    errorFields[rule.field] = 1;
                    return doIt(filledErrors);
                  }
                  if (!deep) {
                    doIt(filledErrors);
                  } else {
                    if (rule.required && !data.value) {
                      if (rule.message !== void 0) {
                        filledErrors = [].concat(rule.message).map(complementError(rule, source));
                      } else if (options.error) {
                        filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                      }
                      return doIt(filledErrors);
                    }
                    var fieldsSchema = {};
                    if (rule.defaultField) {
                      Object.keys(data.value).map(function(key) {
                        fieldsSchema[key] = rule.defaultField;
                      });
                    }
                    fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
                    var paredFieldsSchema = {};
                    Object.keys(fieldsSchema).forEach(function(field) {
                      var fieldSchema = fieldsSchema[field];
                      var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                      paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                    });
                    var schema = new Schema2(paredFieldsSchema);
                    schema.messages(options.messages);
                    if (data.rule.options) {
                      data.rule.options.messages = options.messages;
                      data.rule.options.error = options.error;
                    }
                    schema.validate(data.value, data.rule.options || options, function(errs) {
                      var finalErrors = [];
                      if (filledErrors && filledErrors.length) {
                        finalErrors.push.apply(finalErrors, filledErrors);
                      }
                      if (errs && errs.length) {
                        finalErrors.push.apply(finalErrors, errs);
                      }
                      doIt(finalErrors.length ? finalErrors : null);
                    });
                  }
                }
                var res;
                if (rule.asyncValidator) {
                  res = rule.asyncValidator(rule, data.value, cb, data.source, options);
                } else if (rule.validator) {
                  try {
                    res = rule.validator(rule, data.value, cb, data.source, options);
                  } catch (error) {
                    console.error == null ? void 0 : console.error(error);
                    if (!options.suppressValidatorError) {
                      setTimeout(function() {
                        throw error;
                      }, 0);
                    }
                    cb(error.message);
                  }
                  if (res === true) {
                    cb();
                  } else if (res === false) {
                    cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
                  } else if (res instanceof Array) {
                    cb(res);
                  } else if (res instanceof Error) {
                    cb(res.message);
                  }
                }
                if (res && res.then) {
                  res.then(function() {
                    return cb();
                  }, function(e) {
                    return cb(e);
                  });
                }
              }, function(results) {
                complete(results);
              }, source);
            };
            _proto.getType = function getType(rule) {
              if (rule.type === void 0 && rule.pattern instanceof RegExp) {
                rule.type = "pattern";
              }
              if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
                throw new Error(format("Unknown rule type %s", rule.type));
              }
              return rule.type || "string";
            };
            _proto.getValidationMethod = function getValidationMethod(rule) {
              if (typeof rule.validator === "function") {
                return rule.validator;
              }
              var keys2 = Object.keys(rule);
              var messageIndex = keys2.indexOf("message");
              if (messageIndex !== -1) {
                keys2.splice(messageIndex, 1);
              }
              if (keys2.length === 1 && keys2[0] === "required") {
                return validators.required;
              }
              return validators[this.getType(rule)] || void 0;
            };
            return Schema2;
          }();
          Schema.register = function register(type4, validator) {
            if (typeof validator !== "function") {
              throw new Error("Cannot register a validator by type, validator is not a function");
            }
            validators[type4] = validator;
          };
          Schema.warning = warning;
          Schema.messages = messages;
          Schema.validators = validators;
          const formItemValidateStates = [
            "",
            "error",
            "validating",
            "success"
          ];
          const formItemProps = buildProps({
            label: String,
            labelWidth: {
              type: [String, Number],
              default: ""
            },
            labelPosition: {
              type: String,
              values: ["left", "right", "top", ""],
              default: ""
            },
            prop: {
              type: definePropType([String, Array])
            },
            required: {
              type: Boolean,
              default: void 0
            },
            rules: {
              type: definePropType([Object, Array])
            },
            error: String,
            validateStatus: {
              type: String,
              values: formItemValidateStates
            },
            for: String,
            inlineMessage: {
              type: [String, Boolean],
              default: ""
            },
            showMessage: {
              type: Boolean,
              default: true
            },
            size: {
              type: String,
              values: componentSizes
            }
          });
          const COMPONENT_NAME$4 = "ElLabelWrap";
          var FormLabelWrap = /* @__PURE__ */ defineComponent({
            name: COMPONENT_NAME$4,
            props: {
              isAutoWidth: Boolean,
              updateAll: Boolean
            },
            setup(props, {
              slots
            }) {
              const formContext = inject(formContextKey, void 0);
              const formItemContext = inject(formItemContextKey);
              if (!formItemContext)
                throwError(COMPONENT_NAME$4, "usage: <el-form-item><label-wrap /></el-form-item>");
              const ns = useNamespace("form");
              const el = ref();
              const computedWidth = ref(0);
              const getLabelWidth = () => {
                var _a2;
                if ((_a2 = el.value) == null ? void 0 : _a2.firstElementChild) {
                  const width = window.getComputedStyle(el.value.firstElementChild).width;
                  return Math.ceil(Number.parseFloat(width));
                } else {
                  return 0;
                }
              };
              const updateLabelWidth = (action = "update") => {
                nextTick(() => {
                  if (slots.default && props.isAutoWidth) {
                    if (action === "update") {
                      computedWidth.value = getLabelWidth();
                    } else if (action === "remove") {
                      formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
                    }
                  }
                });
              };
              const updateLabelWidthFn = () => updateLabelWidth("update");
              onMounted(() => {
                updateLabelWidthFn();
              });
              onBeforeUnmount(() => {
                updateLabelWidth("remove");
              });
              onUpdated(() => updateLabelWidthFn());
              watch(computedWidth, (val, oldVal) => {
                if (props.updateAll) {
                  formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
                }
              });
              useResizeObserver(computed(() => {
                var _a2, _b;
                return (_b = (_a2 = el.value) == null ? void 0 : _a2.firstElementChild) != null ? _b : null;
              }), updateLabelWidthFn);
              return () => {
                var _a2, _b;
                if (!slots)
                  return null;
                const {
                  isAutoWidth
                } = props;
                if (isAutoWidth) {
                  const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
                  const hasLabel = formItemContext == null ? void 0 : formItemContext.hasLabel;
                  const style = {};
                  if (hasLabel && autoLabelWidth && autoLabelWidth !== "auto") {
                    const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
                    const labelPosition = formItemContext.labelPosition || formContext.labelPosition;
                    const marginPosition = labelPosition === "left" ? "marginRight" : "marginLeft";
                    if (marginWidth) {
                      style[marginPosition] = `${marginWidth}px`;
                    }
                  }
                  return createVNode("div", {
                    "ref": el,
                    "class": [ns.be("item", "label-wrap")],
                    "style": style
                  }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
                } else {
                  return createVNode(Fragment, {
                    "ref": el
                  }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
                }
              };
            }
          });
          const __default__$5 = /* @__PURE__ */ defineComponent({
            name: "ElFormItem"
          });
          const _sfc_main$b = /* @__PURE__ */ defineComponent({
            ...__default__$5,
            props: formItemProps,
            setup(__props, { expose }) {
              const props = __props;
              const slots = useSlots();
              const formContext = inject(formContextKey, void 0);
              const parentFormItemContext = inject(formItemContextKey, void 0);
              const _size = useFormSize(void 0, { formItem: false });
              const ns = useNamespace("form-item");
              const labelId = useId().value;
              const inputIds = ref([]);
              const validateState = ref("");
              const validateStateDebounced = refDebounced(validateState, 100);
              const validateMessage = ref("");
              const formItemRef = ref();
              let initialValue = void 0;
              let isResettingField = false;
              const labelPosition = computed(() => props.labelPosition || (formContext == null ? void 0 : formContext.labelPosition));
              const labelStyle = computed(() => {
                if (labelPosition.value === "top") {
                  return {};
                }
                const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
                if (labelWidth)
                  return { width: labelWidth };
                return {};
              });
              const contentStyle = computed(() => {
                if (labelPosition.value === "top" || (formContext == null ? void 0 : formContext.inline)) {
                  return {};
                }
                if (!props.label && !props.labelWidth && isNested) {
                  return {};
                }
                const labelWidth = addUnit(props.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
                if (!props.label && !slots.label) {
                  return { marginLeft: labelWidth };
                }
                return {};
              });
              const formItemClasses = computed(() => [
                ns.b(),
                ns.m(_size.value),
                ns.is("error", validateState.value === "error"),
                ns.is("validating", validateState.value === "validating"),
                ns.is("success", validateState.value === "success"),
                ns.is("required", isRequired.value || props.required),
                ns.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
                (formContext == null ? void 0 : formContext.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
                {
                  [ns.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon,
                  [ns.m(`label-${labelPosition.value}`)]: labelPosition.value
                }
              ]);
              const _inlineMessage = computed(() => isBoolean(props.inlineMessage) ? props.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
              const validateClasses = computed(() => [
                ns.e("error"),
                { [ns.em("error", "inline")]: _inlineMessage.value }
              ]);
              const propString = computed(() => {
                if (!props.prop)
                  return "";
                return isArray$1(props.prop) ? props.prop.join(".") : props.prop;
              });
              const hasLabel = computed(() => {
                return !!(props.label || slots.label);
              });
              const labelFor = computed(() => {
                var _a2;
                return (_a2 = props.for) != null ? _a2 : inputIds.value.length === 1 ? inputIds.value[0] : void 0;
              });
              const isGroup = computed(() => {
                return !labelFor.value && hasLabel.value;
              });
              const isNested = !!parentFormItemContext;
              const fieldValue = computed(() => {
                const model = formContext == null ? void 0 : formContext.model;
                if (!model || !props.prop) {
                  return;
                }
                return getProp(model, props.prop).value;
              });
              const normalizedRules = computed(() => {
                const { required } = props;
                const rules2 = [];
                if (props.rules) {
                  rules2.push(...castArray(props.rules));
                }
                const formRules = formContext == null ? void 0 : formContext.rules;
                if (formRules && props.prop) {
                  const _rules = getProp(formRules, props.prop).value;
                  if (_rules) {
                    rules2.push(...castArray(_rules));
                  }
                }
                if (required !== void 0) {
                  const requiredRules = rules2.map((rule, i) => [rule, i]).filter(([rule]) => Object.keys(rule).includes("required"));
                  if (requiredRules.length > 0) {
                    for (const [rule, i] of requiredRules) {
                      if (rule.required === required)
                        continue;
                      rules2[i] = { ...rule, required };
                    }
                  } else {
                    rules2.push({ required });
                  }
                }
                return rules2;
              });
              const validateEnabled = computed(() => normalizedRules.value.length > 0);
              const getFilteredRule = (trigger2) => {
                const rules2 = normalizedRules.value;
                return rules2.filter((rule) => {
                  if (!rule.trigger || !trigger2)
                    return true;
                  if (isArray$1(rule.trigger)) {
                    return rule.trigger.includes(trigger2);
                  } else {
                    return rule.trigger === trigger2;
                  }
                }).map(({ trigger: trigger22, ...rule }) => rule);
              };
              const isRequired = computed(() => normalizedRules.value.some((rule) => rule.required));
              const shouldShowError = computed(() => {
                var _a2;
                return validateStateDebounced.value === "error" && props.showMessage && ((_a2 = formContext == null ? void 0 : formContext.showMessage) != null ? _a2 : true);
              });
              const currentLabel = computed(() => `${props.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
              const setValidationState = (state) => {
                validateState.value = state;
              };
              const onValidationFailed = (error) => {
                var _a2, _b;
                const { errors, fields } = error;
                if (!errors || !fields) {
                  console.error(error);
                }
                setValidationState("error");
                validateMessage.value = errors ? (_b = (_a2 = errors == null ? void 0 : errors[0]) == null ? void 0 : _a2.message) != null ? _b : `${props.prop} is required` : "";
                formContext == null ? void 0 : formContext.emit("validate", props.prop, false, validateMessage.value);
              };
              const onValidationSucceeded = () => {
                setValidationState("success");
                formContext == null ? void 0 : formContext.emit("validate", props.prop, true, "");
              };
              const doValidate = async (rules2) => {
                const modelName = propString.value;
                const validator = new Schema({
                  [modelName]: rules2
                });
                return validator.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
                  onValidationSucceeded();
                  return true;
                }).catch((err) => {
                  onValidationFailed(err);
                  return Promise.reject(err);
                });
              };
              const validate = async (trigger2, callback) => {
                if (isResettingField || !props.prop) {
                  return false;
                }
                const hasCallback = isFunction$1(callback);
                if (!validateEnabled.value) {
                  callback == null ? void 0 : callback(false);
                  return false;
                }
                const rules2 = getFilteredRule(trigger2);
                if (rules2.length === 0) {
                  callback == null ? void 0 : callback(true);
                  return true;
                }
                setValidationState("validating");
                return doValidate(rules2).then(() => {
                  callback == null ? void 0 : callback(true);
                  return true;
                }).catch((err) => {
                  const { fields } = err;
                  callback == null ? void 0 : callback(false, fields);
                  return hasCallback ? false : Promise.reject(fields);
                });
              };
              const clearValidate = () => {
                setValidationState("");
                validateMessage.value = "";
                isResettingField = false;
              };
              const resetField = async () => {
                const model = formContext == null ? void 0 : formContext.model;
                if (!model || !props.prop)
                  return;
                const computedValue = getProp(model, props.prop);
                isResettingField = true;
                computedValue.value = clone(initialValue);
                await nextTick();
                clearValidate();
                isResettingField = false;
              };
              const addInputId = (id) => {
                if (!inputIds.value.includes(id)) {
                  inputIds.value.push(id);
                }
              };
              const removeInputId = (id) => {
                inputIds.value = inputIds.value.filter((listId) => listId !== id);
              };
              watch(() => props.error, (val) => {
                validateMessage.value = val || "";
                setValidationState(val ? "error" : "");
              }, { immediate: true });
              watch(() => props.validateStatus, (val) => setValidationState(val || ""));
              const context = reactive({
                ...toRefs(props),
                $el: formItemRef,
                size: _size,
                validateMessage,
                validateState,
                labelId,
                inputIds,
                isGroup,
                hasLabel,
                fieldValue,
                addInputId,
                removeInputId,
                resetField,
                clearValidate,
                validate,
                propString
              });
              provide(formItemContextKey, context);
              onMounted(() => {
                if (props.prop) {
                  formContext == null ? void 0 : formContext.addField(context);
                  initialValue = clone(fieldValue.value);
                }
              });
              onBeforeUnmount(() => {
                formContext == null ? void 0 : formContext.removeField(context);
              });
              expose({
                size: _size,
                validateMessage,
                validateState,
                validate,
                clearValidate,
                resetField
              });
              return (_ctx, _cache) => {
                var _a2;
                return openBlock(), createElementBlock("div", {
                  ref_key: "formItemRef",
                  ref: formItemRef,
                  class: normalizeClass(unref(formItemClasses)),
                  role: unref(isGroup) ? "group" : void 0,
                  "aria-labelledby": unref(isGroup) ? unref(labelId) : void 0
                }, [
                  createVNode(unref(FormLabelWrap), {
                    "is-auto-width": unref(labelStyle).width === "auto",
                    "update-all": ((_a2 = unref(formContext)) == null ? void 0 : _a2.labelWidth) === "auto"
                  }, {
                    default: withCtx(() => [
                      unref(hasLabel) ? (openBlock(), createBlock(resolveDynamicComponent(unref(labelFor) ? "label" : "div"), {
                        key: 0,
                        id: unref(labelId),
                        for: unref(labelFor),
                        class: normalizeClass(unref(ns).e("label")),
                        style: normalizeStyle(unref(labelStyle))
                      }, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "label", { label: unref(currentLabel) }, () => [
                            createTextVNode(toDisplayString(unref(currentLabel)), 1)
                          ])
                        ]),
                        _: 3
                      }, 8, ["id", "for", "class", "style"])) : createCommentVNode("v-if", true)
                    ]),
                    _: 3
                  }, 8, ["is-auto-width", "update-all"]),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(ns).e("content")),
                    style: normalizeStyle(unref(contentStyle))
                  }, [
                    renderSlot(_ctx.$slots, "default"),
                    createVNode(TransitionGroup, {
                      name: `${unref(ns).namespace.value}-zoom-in-top`
                    }, {
                      default: withCtx(() => [
                        unref(shouldShowError) ? renderSlot(_ctx.$slots, "error", {
                          key: 0,
                          error: validateMessage.value
                        }, () => [
                          createBaseVNode("div", {
                            class: normalizeClass(unref(validateClasses))
                          }, toDisplayString(validateMessage.value), 3)
                        ]) : createCommentVNode("v-if", true)
                      ]),
                      _: 3
                    }, 8, ["name"])
                  ], 6)
                ], 10, ["role", "aria-labelledby"]);
              };
            }
          });
          var FormItem = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__file", "form-item.vue"]]);
          const ElForm = withInstall(Form, {
            FormItem
          });
          const ElFormItem = withNoopInstall(FormItem);
          const inputNumberProps = buildProps({
            id: {
              type: String,
              default: void 0
            },
            step: {
              type: Number,
              default: 1
            },
            stepStrictly: Boolean,
            max: {
              type: Number,
              default: Number.POSITIVE_INFINITY
            },
            min: {
              type: Number,
              default: Number.NEGATIVE_INFINITY
            },
            modelValue: {
              type: [Number, null]
            },
            readonly: Boolean,
            disabled: Boolean,
            size: useSizeProp,
            controls: {
              type: Boolean,
              default: true
            },
            controlsPosition: {
              type: String,
              default: "",
              values: ["", "right"]
            },
            valueOnClear: {
              type: [String, Number, null],
              validator: (val) => val === null || isNumber(val) || ["min", "max"].includes(val),
              default: null
            },
            name: String,
            placeholder: String,
            precision: {
              type: Number,
              validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
            },
            validateEvent: {
              type: Boolean,
              default: true
            },
            ...useAriaProps(["ariaLabel"]),
            inputmode: {
              type: definePropType(String),
              default: void 0
            }
          });
          const inputNumberEmits = {
            [CHANGE_EVENT]: (cur, prev) => prev !== cur,
            blur: (e) => e instanceof FocusEvent,
            focus: (e) => e instanceof FocusEvent,
            [INPUT_EVENT]: (val) => isNumber(val) || isNil(val),
            [UPDATE_MODEL_EVENT]: (val) => isNumber(val) || isNil(val)
          };
          const __default__$4 = /* @__PURE__ */ defineComponent({
            name: "ElInputNumber"
          });
          const _sfc_main$a = /* @__PURE__ */ defineComponent({
            ...__default__$4,
            props: inputNumberProps,
            emits: inputNumberEmits,
            setup(__props, { expose, emit: emit2 }) {
              const props = __props;
              const { t } = useLocale();
              const ns = useNamespace("input-number");
              const input = ref();
              const data = reactive({
                currentValue: props.modelValue,
                userInput: null
              });
              const { formItem } = useFormItem();
              const minDisabled = computed(() => isNumber(props.modelValue) && props.modelValue <= props.min);
              const maxDisabled = computed(() => isNumber(props.modelValue) && props.modelValue >= props.max);
              const numPrecision = computed(() => {
                const stepPrecision = getPrecision(props.step);
                if (!isUndefined(props.precision)) {
                  if (stepPrecision > props.precision) ;
                  return props.precision;
                } else {
                  return Math.max(getPrecision(props.modelValue), stepPrecision);
                }
              });
              const controlsAtRight = computed(() => {
                return props.controls && props.controlsPosition === "right";
              });
              const inputNumberSize = useFormSize();
              const inputNumberDisabled = useFormDisabled();
              const displayValue = computed(() => {
                if (data.userInput !== null) {
                  return data.userInput;
                }
                let currentValue = data.currentValue;
                if (isNil(currentValue))
                  return "";
                if (isNumber(currentValue)) {
                  if (Number.isNaN(currentValue))
                    return "";
                  if (!isUndefined(props.precision)) {
                    currentValue = currentValue.toFixed(props.precision);
                  }
                }
                return currentValue;
              });
              const toPrecision = (num, pre) => {
                if (isUndefined(pre))
                  pre = numPrecision.value;
                if (pre === 0)
                  return Math.round(num);
                let snum = String(num);
                const pointPos = snum.indexOf(".");
                if (pointPos === -1)
                  return num;
                const nums = snum.replace(".", "").split("");
                const datum = nums[pointPos + pre];
                if (!datum)
                  return num;
                const length = snum.length;
                if (snum.charAt(length - 1) === "5") {
                  snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
                }
                return Number.parseFloat(Number(snum).toFixed(pre));
              };
              const getPrecision = (value) => {
                if (isNil(value))
                  return 0;
                const valueString = value.toString();
                const dotPosition = valueString.indexOf(".");
                let precision = 0;
                if (dotPosition !== -1) {
                  precision = valueString.length - dotPosition - 1;
                }
                return precision;
              };
              const ensurePrecision = (val, coefficient = 1) => {
                if (!isNumber(val))
                  return data.currentValue;
                return toPrecision(val + props.step * coefficient);
              };
              const increase = () => {
                if (props.readonly || inputNumberDisabled.value || maxDisabled.value)
                  return;
                const value = Number(displayValue.value) || 0;
                const newVal = ensurePrecision(value);
                setCurrentValue(newVal);
                emit2(INPUT_EVENT, data.currentValue);
                setCurrentValueToModelValue();
              };
              const decrease = () => {
                if (props.readonly || inputNumberDisabled.value || minDisabled.value)
                  return;
                const value = Number(displayValue.value) || 0;
                const newVal = ensurePrecision(value, -1);
                setCurrentValue(newVal);
                emit2(INPUT_EVENT, data.currentValue);
                setCurrentValueToModelValue();
              };
              const verifyValue = (value, update) => {
                const { max, min, step, precision, stepStrictly, valueOnClear } = props;
                if (max < min) {
                  throwError("InputNumber", "min should not be greater than max.");
                }
                let newVal = Number(value);
                if (isNil(value) || Number.isNaN(newVal)) {
                  return null;
                }
                if (value === "") {
                  if (valueOnClear === null) {
                    return null;
                  }
                  newVal = isString$1(valueOnClear) ? { min, max }[valueOnClear] : valueOnClear;
                }
                if (stepStrictly) {
                  newVal = toPrecision(Math.round(newVal / step) * step, precision);
                  if (newVal !== value) {
                    update && emit2(UPDATE_MODEL_EVENT, newVal);
                  }
                }
                if (!isUndefined(precision)) {
                  newVal = toPrecision(newVal, precision);
                }
                if (newVal > max || newVal < min) {
                  newVal = newVal > max ? max : min;
                  update && emit2(UPDATE_MODEL_EVENT, newVal);
                }
                return newVal;
              };
              const setCurrentValue = (value, emitChange = true) => {
                var _a2;
                const oldVal = data.currentValue;
                const newVal = verifyValue(value);
                if (!emitChange) {
                  emit2(UPDATE_MODEL_EVENT, newVal);
                  return;
                }
                if (oldVal === newVal && value)
                  return;
                data.userInput = null;
                emit2(UPDATE_MODEL_EVENT, newVal);
                if (oldVal !== newVal) {
                  emit2(CHANGE_EVENT, newVal, oldVal);
                }
                if (props.validateEvent) {
                  (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
                }
                data.currentValue = newVal;
              };
              const handleInput = (value) => {
                data.userInput = value;
                const newVal = value === "" ? null : Number(value);
                emit2(INPUT_EVENT, newVal);
                setCurrentValue(newVal, false);
              };
              const handleInputChange = (value) => {
                const newVal = value !== "" ? Number(value) : "";
                if (isNumber(newVal) && !Number.isNaN(newVal) || value === "") {
                  setCurrentValue(newVal);
                }
                setCurrentValueToModelValue();
                data.userInput = null;
              };
              const focus = () => {
                var _a2, _b;
                (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
              };
              const blur = () => {
                var _a2, _b;
                (_b = (_a2 = input.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b.call(_a2);
              };
              const handleFocus = (event) => {
                emit2("focus", event);
              };
              const handleBlur = (event) => {
                var _a2, _b;
                data.userInput = null;
                if (data.currentValue === null && ((_a2 = input.value) == null ? void 0 : _a2.input)) {
                  input.value.input.value = "";
                }
                emit2("blur", event);
                if (props.validateEvent) {
                  (_b = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _b.call(formItem, "blur").catch((err) => debugWarn());
                }
              };
              const setCurrentValueToModelValue = () => {
                if (data.currentValue !== props.modelValue) {
                  data.currentValue = props.modelValue;
                }
              };
              const handleWheel = (e) => {
                if (document.activeElement === e.target)
                  e.preventDefault();
              };
              watch(() => props.modelValue, (value, oldValue) => {
                const newValue = verifyValue(value, true);
                if (data.userInput === null && newValue !== oldValue) {
                  data.currentValue = newValue;
                }
              }, { immediate: true });
              onMounted(() => {
                var _a2;
                const { min, max, modelValue } = props;
                const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
                innerInput.setAttribute("role", "spinbutton");
                if (Number.isFinite(max)) {
                  innerInput.setAttribute("aria-valuemax", String(max));
                } else {
                  innerInput.removeAttribute("aria-valuemax");
                }
                if (Number.isFinite(min)) {
                  innerInput.setAttribute("aria-valuemin", String(min));
                } else {
                  innerInput.removeAttribute("aria-valuemin");
                }
                innerInput.setAttribute("aria-valuenow", data.currentValue || data.currentValue === 0 ? String(data.currentValue) : "");
                innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
                if (!isNumber(modelValue) && modelValue != null) {
                  let val = Number(modelValue);
                  if (Number.isNaN(val)) {
                    val = null;
                  }
                  emit2(UPDATE_MODEL_EVENT, val);
                }
                innerInput.addEventListener("wheel", handleWheel, { passive: false });
              });
              onUpdated(() => {
                var _a2, _b;
                const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
                innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${(_b = data.currentValue) != null ? _b : ""}`);
              });
              expose({
                focus,
                blur
              });
              return (_ctx, _cache) => {
                return openBlock(), createElementBlock("div", {
                  class: normalizeClass([
                    unref(ns).b(),
                    unref(ns).m(unref(inputNumberSize)),
                    unref(ns).is("disabled", unref(inputNumberDisabled)),
                    unref(ns).is("without-controls", !_ctx.controls),
                    unref(ns).is("controls-right", unref(controlsAtRight))
                  ]),
                  onDragstart: withModifiers(() => {
                  }, ["prevent"])
                }, [
                  _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                    key: 0,
                    role: "button",
                    "aria-label": unref(t)("el.inputNumber.decrease"),
                    class: normalizeClass([unref(ns).e("decrease"), unref(ns).is("disabled", unref(minDisabled))]),
                    onKeydown: withKeys(decrease, ["enter"])
                  }, [
                    renderSlot(_ctx.$slots, "decrease-icon", {}, () => [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_down_default), { key: 0 })) : (openBlock(), createBlock(unref(minus_default), { key: 1 }))
                        ]),
                        _: 1
                      })
                    ])
                  ], 42, ["aria-label", "onKeydown"])), [
                    [unref(vRepeatClick), decrease]
                  ]) : createCommentVNode("v-if", true),
                  _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                    key: 1,
                    role: "button",
                    "aria-label": unref(t)("el.inputNumber.increase"),
                    class: normalizeClass([unref(ns).e("increase"), unref(ns).is("disabled", unref(maxDisabled))]),
                    onKeydown: withKeys(increase, ["enter"])
                  }, [
                    renderSlot(_ctx.$slots, "increase-icon", {}, () => [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_up_default), { key: 0 })) : (openBlock(), createBlock(unref(plus_default), { key: 1 }))
                        ]),
                        _: 1
                      })
                    ])
                  ], 42, ["aria-label", "onKeydown"])), [
                    [unref(vRepeatClick), increase]
                  ]) : createCommentVNode("v-if", true),
                  createVNode(unref(ElInput), {
                    id: _ctx.id,
                    ref_key: "input",
                    ref: input,
                    type: "number",
                    step: _ctx.step,
                    "model-value": unref(displayValue),
                    placeholder: _ctx.placeholder,
                    readonly: _ctx.readonly,
                    disabled: unref(inputNumberDisabled),
                    size: unref(inputNumberSize),
                    max: _ctx.max,
                    min: _ctx.min,
                    name: _ctx.name,
                    "aria-label": _ctx.ariaLabel,
                    "validate-event": false,
                    inputmode: _ctx.inputmode,
                    onKeydown: [
                      withKeys(withModifiers(increase, ["prevent"]), ["up"]),
                      withKeys(withModifiers(decrease, ["prevent"]), ["down"])
                    ],
                    onBlur: handleBlur,
                    onFocus: handleFocus,
                    onInput: handleInput,
                    onChange: handleInputChange
                  }, createSlots({
                    _: 2
                  }, [
                    _ctx.$slots.prefix ? {
                      name: "prefix",
                      fn: withCtx(() => [
                        renderSlot(_ctx.$slots, "prefix")
                      ])
                    } : void 0,
                    _ctx.$slots.suffix ? {
                      name: "suffix",
                      fn: withCtx(() => [
                        renderSlot(_ctx.$slots, "suffix")
                      ])
                    } : void 0
                  ]), 1032, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "aria-label", "inputmode", "onKeydown"])
                ], 42, ["onDragstart"]);
              };
            }
          });
          var InputNumber = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__file", "input-number.vue"]]);
          const ElInputNumber = withInstall(InputNumber);
          const capitalize = (str) => capitalize$1(str);
          const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
          const switchProps = buildProps({
            modelValue: {
              type: [Boolean, String, Number],
              default: false
            },
            disabled: Boolean,
            loading: Boolean,
            size: {
              type: String,
              validator: isValidComponentSize
            },
            width: {
              type: [String, Number],
              default: ""
            },
            inlinePrompt: Boolean,
            inactiveActionIcon: {
              type: iconPropType
            },
            activeActionIcon: {
              type: iconPropType
            },
            activeIcon: {
              type: iconPropType
            },
            inactiveIcon: {
              type: iconPropType
            },
            activeText: {
              type: String,
              default: ""
            },
            inactiveText: {
              type: String,
              default: ""
            },
            activeValue: {
              type: [Boolean, String, Number],
              default: true
            },
            inactiveValue: {
              type: [Boolean, String, Number],
              default: false
            },
            name: {
              type: String,
              default: ""
            },
            validateEvent: {
              type: Boolean,
              default: true
            },
            beforeChange: {
              type: definePropType(Function)
            },
            id: String,
            tabindex: {
              type: [String, Number]
            },
            ...useAriaProps(["ariaLabel"])
          });
          const switchEmits = {
            [UPDATE_MODEL_EVENT]: (val) => isBoolean(val) || isString$1(val) || isNumber(val),
            [CHANGE_EVENT]: (val) => isBoolean(val) || isString$1(val) || isNumber(val),
            [INPUT_EVENT]: (val) => isBoolean(val) || isString$1(val) || isNumber(val)
          };
          const COMPONENT_NAME$3 = "ElSwitch";
          const __default__$3 = /* @__PURE__ */ defineComponent({
            name: COMPONENT_NAME$3
          });
          const _sfc_main$9 = /* @__PURE__ */ defineComponent({
            ...__default__$3,
            props: switchProps,
            emits: switchEmits,
            setup(__props, { expose, emit: emit2 }) {
              const props = __props;
              const { formItem } = useFormItem();
              const switchSize = useFormSize();
              const ns = useNamespace("switch");
              const { inputId } = useFormItemInputId(props, {
                formItemContext: formItem
              });
              const switchDisabled = useFormDisabled(computed(() => props.loading));
              const isControlled = ref(props.modelValue !== false);
              const input = ref();
              const core = ref();
              const switchKls = computed(() => [
                ns.b(),
                ns.m(switchSize.value),
                ns.is("disabled", switchDisabled.value),
                ns.is("checked", checked.value)
              ]);
              const labelLeftKls = computed(() => [
                ns.e("label"),
                ns.em("label", "left"),
                ns.is("active", !checked.value)
              ]);
              const labelRightKls = computed(() => [
                ns.e("label"),
                ns.em("label", "right"),
                ns.is("active", checked.value)
              ]);
              const coreStyle = computed(() => ({
                width: addUnit(props.width)
              }));
              watch(() => props.modelValue, () => {
                isControlled.value = true;
              });
              const actualValue = computed(() => {
                return isControlled.value ? props.modelValue : false;
              });
              const checked = computed(() => actualValue.value === props.activeValue);
              if (![props.activeValue, props.inactiveValue].includes(actualValue.value)) {
                emit2(UPDATE_MODEL_EVENT, props.inactiveValue);
                emit2(CHANGE_EVENT, props.inactiveValue);
                emit2(INPUT_EVENT, props.inactiveValue);
              }
              watch(checked, (val) => {
                var _a2;
                input.value.checked = val;
                if (props.validateEvent) {
                  (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
                }
              });
              const handleChange = () => {
                const val = checked.value ? props.inactiveValue : props.activeValue;
                emit2(UPDATE_MODEL_EVENT, val);
                emit2(CHANGE_EVENT, val);
                emit2(INPUT_EVENT, val);
                nextTick(() => {
                  input.value.checked = checked.value;
                });
              };
              const switchValue = () => {
                if (switchDisabled.value)
                  return;
                const { beforeChange } = props;
                if (!beforeChange) {
                  handleChange();
                  return;
                }
                const shouldChange = beforeChange();
                const isPromiseOrBool = [
                  isPromise(shouldChange),
                  isBoolean(shouldChange)
                ].includes(true);
                if (!isPromiseOrBool) {
                  throwError(COMPONENT_NAME$3, "beforeChange must return type `Promise<boolean>` or `boolean`");
                }
                if (isPromise(shouldChange)) {
                  shouldChange.then((result) => {
                    if (result) {
                      handleChange();
                    }
                  }).catch((e) => {
                  });
                } else if (shouldChange) {
                  handleChange();
                }
              };
              const focus = () => {
                var _a2, _b;
                (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
              };
              onMounted(() => {
                input.value.checked = checked.value;
              });
              expose({
                focus,
                checked
              });
              return (_ctx, _cache) => {
                return openBlock(), createElementBlock("div", {
                  class: normalizeClass(unref(switchKls)),
                  onClick: withModifiers(switchValue, ["prevent"])
                }, [
                  createBaseVNode("input", {
                    id: unref(inputId),
                    ref_key: "input",
                    ref: input,
                    class: normalizeClass(unref(ns).e("input")),
                    type: "checkbox",
                    role: "switch",
                    "aria-checked": unref(checked),
                    "aria-disabled": unref(switchDisabled),
                    "aria-label": _ctx.ariaLabel,
                    name: _ctx.name,
                    "true-value": _ctx.activeValue,
                    "false-value": _ctx.inactiveValue,
                    disabled: unref(switchDisabled),
                    tabindex: _ctx.tabindex,
                    onChange: handleChange,
                    onKeydown: withKeys(switchValue, ["enter"])
                  }, null, 42, ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"]),
                  !_ctx.inlinePrompt && (_ctx.inactiveIcon || _ctx.inactiveText) ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(labelLeftKls))
                  }, [
                    _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveIcon)))
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true),
                    !_ctx.inactiveIcon && _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                      key: 1,
                      "aria-hidden": unref(checked)
                    }, toDisplayString(_ctx.inactiveText), 9, ["aria-hidden"])) : createCommentVNode("v-if", true)
                  ], 2)) : createCommentVNode("v-if", true),
                  createBaseVNode("span", {
                    ref_key: "core",
                    ref: core,
                    class: normalizeClass(unref(ns).e("core")),
                    style: normalizeStyle(unref(coreStyle))
                  }, [
                    _ctx.inlinePrompt ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass(unref(ns).e("inner"))
                    }, [
                      _ctx.activeIcon || _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(ns).is("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(checked) ? _ctx.activeIcon : _ctx.inactiveIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : _ctx.activeText || _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                        key: 1,
                        class: normalizeClass(unref(ns).is("text")),
                        "aria-hidden": !unref(checked)
                      }, toDisplayString(unref(checked) ? _ctx.activeText : _ctx.inactiveText), 11, ["aria-hidden"])) : createCommentVNode("v-if", true)
                    ], 2)) : createCommentVNode("v-if", true),
                    createBaseVNode("div", {
                      class: normalizeClass(unref(ns).e("action"))
                    }, [
                      _ctx.loading ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(ns).is("loading"))
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(loading_default))
                        ]),
                        _: 1
                      }, 8, ["class"])) : unref(checked) ? renderSlot(_ctx.$slots, "active-action", { key: 1 }, () => [
                        _ctx.activeActionIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeActionIcon)))
                          ]),
                          _: 1
                        })) : createCommentVNode("v-if", true)
                      ]) : !unref(checked) ? renderSlot(_ctx.$slots, "inactive-action", { key: 2 }, () => [
                        _ctx.inactiveActionIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveActionIcon)))
                          ]),
                          _: 1
                        })) : createCommentVNode("v-if", true)
                      ]) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 6),
                  !_ctx.inlinePrompt && (_ctx.activeIcon || _ctx.activeText) ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(labelRightKls))
                  }, [
                    _ctx.activeIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeIcon)))
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true),
                    !_ctx.activeIcon && _ctx.activeText ? (openBlock(), createElementBlock("span", {
                      key: 1,
                      "aria-hidden": !unref(checked)
                    }, toDisplayString(_ctx.activeText), 9, ["aria-hidden"])) : createCommentVNode("v-if", true)
                  ], 2)) : createCommentVNode("v-if", true)
                ], 10, ["onClick"]);
              };
            }
          });
          var Switch = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__file", "switch.vue"]]);
          const ElSwitch = withInstall(Switch);
          const tabsRootContextKey = Symbol("tabsRootContextKey");
          const tabBarProps = buildProps({
            tabs: {
              type: definePropType(Array),
              default: () => mutable([])
            },
            tabRefs: {
              type: definePropType(Object),
              default: () => mutable({})
            }
          });
          const COMPONENT_NAME$2 = "ElTabBar";
          const __default__$2 = /* @__PURE__ */ defineComponent({
            name: COMPONENT_NAME$2
          });
          const _sfc_main$8 = /* @__PURE__ */ defineComponent({
            ...__default__$2,
            props: tabBarProps,
            setup(__props, { expose }) {
              const props = __props;
              const rootTabs = inject(tabsRootContextKey);
              if (!rootTabs)
                throwError(COMPONENT_NAME$2, "<el-tabs><el-tab-bar /></el-tabs>");
              const ns = useNamespace("tabs");
              const barRef = ref();
              const barStyle = ref();
              const getBarStyle = () => {
                let offset = 0;
                let tabSize = 0;
                const sizeName = ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
                const sizeDir = sizeName === "width" ? "x" : "y";
                const position = sizeDir === "x" ? "left" : "top";
                props.tabs.every((tab) => {
                  if (isUndefined(tab.paneName))
                    return false;
                  const $el = props.tabRefs[tab.paneName];
                  if (!$el)
                    return false;
                  if (!tab.active) {
                    return true;
                  }
                  offset = $el[`offset${capitalize(position)}`];
                  tabSize = $el[`client${capitalize(sizeName)}`];
                  const tabStyles = window.getComputedStyle($el);
                  if (sizeName === "width") {
                    tabSize -= Number.parseFloat(tabStyles.paddingLeft) + Number.parseFloat(tabStyles.paddingRight);
                    offset += Number.parseFloat(tabStyles.paddingLeft);
                  }
                  return false;
                });
                return {
                  [sizeName]: `${tabSize}px`,
                  transform: `translate${capitalize(sizeDir)}(${offset}px)`
                };
              };
              const update = () => barStyle.value = getBarStyle();
              const saveObserver = [];
              const observerTabs = () => {
                saveObserver.forEach((observer) => observer.stop());
                saveObserver.length = 0;
                Object.values(props.tabRefs).forEach((tab) => {
                  saveObserver.push(useResizeObserver(tab, update));
                });
              };
              watch(() => props.tabs, async () => {
                await nextTick();
                update();
                observerTabs();
              }, { immediate: true });
              const barObserever = useResizeObserver(barRef, () => update());
              onBeforeUnmount(() => {
                saveObserver.forEach((observer) => observer.stop());
                saveObserver.length = 0;
                barObserever.stop();
              });
              expose({
                ref: barRef,
                update
              });
              return (_ctx, _cache) => {
                return openBlock(), createElementBlock("div", {
                  ref_key: "barRef",
                  ref: barRef,
                  class: normalizeClass([unref(ns).e("active-bar"), unref(ns).is(unref(rootTabs).props.tabPosition)]),
                  style: normalizeStyle(barStyle.value)
                }, null, 6);
              };
            }
          });
          var TabBar = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__file", "tab-bar.vue"]]);
          const tabNavProps = buildProps({
            panes: {
              type: definePropType(Array),
              default: () => mutable([])
            },
            currentName: {
              type: [String, Number],
              default: ""
            },
            editable: Boolean,
            type: {
              type: String,
              values: ["card", "border-card", ""],
              default: ""
            },
            stretch: Boolean
          });
          const tabNavEmits = {
            tabClick: (tab, tabName, ev) => ev instanceof Event,
            tabRemove: (tab, ev) => ev instanceof Event
          };
          const COMPONENT_NAME$1 = "ElTabNav";
          const TabNav = /* @__PURE__ */ defineComponent({
            name: COMPONENT_NAME$1,
            props: tabNavProps,
            emits: tabNavEmits,
            setup(props, {
              expose,
              emit: emit2
            }) {
              const rootTabs = inject(tabsRootContextKey);
              if (!rootTabs)
                throwError(COMPONENT_NAME$1, `<el-tabs><tab-nav /></el-tabs>`);
              const ns = useNamespace("tabs");
              const visibility = useDocumentVisibility();
              const focused = useWindowFocus();
              const navScroll$ = ref();
              const nav$ = ref();
              const el$ = ref();
              const tabRefsMap = ref({});
              const tabBarRef = ref();
              const scrollable = ref(false);
              const navOffset = ref(0);
              const isFocus = ref(false);
              const focusable = ref(true);
              const tracker = shallowRef();
              const sizeName = computed(() => ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height");
              const navStyle = computed(() => {
                const dir = sizeName.value === "width" ? "X" : "Y";
                return {
                  transform: `translate${dir}(-${navOffset.value}px)`
                };
              });
              const scrollPrev = () => {
                if (!navScroll$.value)
                  return;
                const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
                const currentOffset = navOffset.value;
                if (!currentOffset)
                  return;
                const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;
                navOffset.value = newOffset;
              };
              const scrollNext = () => {
                if (!navScroll$.value || !nav$.value)
                  return;
                const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
                const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
                const currentOffset = navOffset.value;
                if (navSize - currentOffset <= containerSize)
                  return;
                const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
                navOffset.value = newOffset;
              };
              const scrollToActiveTab = async () => {
                const nav = nav$.value;
                if (!scrollable.value || !el$.value || !navScroll$.value || !nav)
                  return;
                await nextTick();
                const activeTab = tabRefsMap.value[props.currentName];
                if (!activeTab)
                  return;
                const navScroll = navScroll$.value;
                const isHorizontal = ["top", "bottom"].includes(rootTabs.props.tabPosition);
                const activeTabBounding = activeTab.getBoundingClientRect();
                const navScrollBounding = navScroll.getBoundingClientRect();
                const maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
                const currentOffset = navOffset.value;
                let newOffset = currentOffset;
                if (isHorizontal) {
                  if (activeTabBounding.left < navScrollBounding.left) {
                    newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
                  }
                  if (activeTabBounding.right > navScrollBounding.right) {
                    newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
                  }
                } else {
                  if (activeTabBounding.top < navScrollBounding.top) {
                    newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
                  }
                  if (activeTabBounding.bottom > navScrollBounding.bottom) {
                    newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
                  }
                }
                newOffset = Math.max(newOffset, 0);
                navOffset.value = Math.min(newOffset, maxOffset);
              };
              const update = () => {
                var _a2;
                if (!nav$.value || !navScroll$.value)
                  return;
                props.stretch && ((_a2 = tabBarRef.value) == null ? void 0 : _a2.update());
                const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
                const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
                const currentOffset = navOffset.value;
                if (containerSize < navSize) {
                  scrollable.value = scrollable.value || {};
                  scrollable.value.prev = currentOffset;
                  scrollable.value.next = currentOffset + containerSize < navSize;
                  if (navSize - currentOffset < containerSize) {
                    navOffset.value = navSize - containerSize;
                  }
                } else {
                  scrollable.value = false;
                  if (currentOffset > 0) {
                    navOffset.value = 0;
                  }
                }
              };
              const changeTab = (event) => {
                let step = 0;
                switch (event.code) {
                  case EVENT_CODE.left:
                  case EVENT_CODE.up:
                    step = -1;
                    break;
                  case EVENT_CODE.right:
                  case EVENT_CODE.down:
                    step = 1;
                    break;
                  default:
                    return;
                }
                const tabList = Array.from(event.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)"));
                const currentIndex = tabList.indexOf(event.target);
                let nextIndex = currentIndex + step;
                if (nextIndex < 0) {
                  nextIndex = tabList.length - 1;
                } else if (nextIndex >= tabList.length) {
                  nextIndex = 0;
                }
                tabList[nextIndex].focus({
                  preventScroll: true
                });
                tabList[nextIndex].click();
                setFocus();
              };
              const setFocus = () => {
                if (focusable.value)
                  isFocus.value = true;
              };
              const removeFocus = () => isFocus.value = false;
              const setRefs = (el, key) => {
                tabRefsMap.value[key] = el;
              };
              const focusActiveTab = async () => {
                await nextTick();
                const activeTab = tabRefsMap.value[props.currentName];
                activeTab == null ? void 0 : activeTab.focus({
                  preventScroll: true
                });
              };
              watch(visibility, (visibility2) => {
                if (visibility2 === "hidden") {
                  focusable.value = false;
                } else if (visibility2 === "visible") {
                  setTimeout(() => focusable.value = true, 50);
                }
              });
              watch(focused, (focused2) => {
                if (focused2) {
                  setTimeout(() => focusable.value = true, 50);
                } else {
                  focusable.value = false;
                }
              });
              useResizeObserver(el$, update);
              onMounted(() => setTimeout(() => scrollToActiveTab(), 0));
              onUpdated(() => update());
              expose({
                scrollToActiveTab,
                removeFocus,
                focusActiveTab,
                tabListRef: nav$,
                tabBarRef,
                scheduleRender: () => triggerRef(tracker)
              });
              return () => {
                const scrollBtn = scrollable.value ? [createVNode("span", {
                  "class": [ns.e("nav-prev"), ns.is("disabled", !scrollable.value.prev)],
                  "onClick": scrollPrev
                }, [createVNode(ElIcon, null, {
                  default: () => [createVNode(arrow_left_default, null, null)]
                })]), createVNode("span", {
                  "class": [ns.e("nav-next"), ns.is("disabled", !scrollable.value.next)],
                  "onClick": scrollNext
                }, [createVNode(ElIcon, null, {
                  default: () => [createVNode(arrow_right_default, null, null)]
                })])] : null;
                const tabs = props.panes.map((pane, index) => {
                  var _a2, _b, _c, _d;
                  const uid2 = pane.uid;
                  const disabled = pane.props.disabled;
                  const tabName = (_b = (_a2 = pane.props.name) != null ? _a2 : pane.index) != null ? _b : `${index}`;
                  const closable = !disabled && (pane.isClosable || props.editable);
                  pane.index = `${index}`;
                  const btnClose = closable ? createVNode(ElIcon, {
                    "class": "is-icon-close",
                    "onClick": (ev) => emit2("tabRemove", pane, ev)
                  }, {
                    default: () => [createVNode(close_default, null, null)]
                  }) : null;
                  const tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;
                  const tabindex = !disabled && pane.active ? 0 : -1;
                  return createVNode("div", {
                    "ref": (el) => setRefs(el, tabName),
                    "class": [ns.e("item"), ns.is(rootTabs.props.tabPosition), ns.is("active", pane.active), ns.is("disabled", disabled), ns.is("closable", closable), ns.is("focus", isFocus.value)],
                    "id": `tab-${tabName}`,
                    "key": `tab-${uid2}`,
                    "aria-controls": `pane-${tabName}`,
                    "role": "tab",
                    "aria-selected": pane.active,
                    "tabindex": tabindex,
                    "onFocus": () => setFocus(),
                    "onBlur": () => removeFocus(),
                    "onClick": (ev) => {
                      removeFocus();
                      emit2("tabClick", pane, tabName, ev);
                    },
                    "onKeydown": (ev) => {
                      if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) {
                        emit2("tabRemove", pane, ev);
                      }
                    }
                  }, [...[tabLabelContent, btnClose]]);
                });
                tracker.value;
                return createVNode("div", {
                  "ref": el$,
                  "class": [ns.e("nav-wrap"), ns.is("scrollable", !!scrollable.value), ns.is(rootTabs.props.tabPosition)]
                }, [scrollBtn, createVNode("div", {
                  "class": ns.e("nav-scroll"),
                  "ref": navScroll$
                }, [props.panes.length > 0 ? createVNode("div", {
                  "class": [ns.e("nav"), ns.is(rootTabs.props.tabPosition), ns.is("stretch", props.stretch && ["top", "bottom"].includes(rootTabs.props.tabPosition))],
                  "ref": nav$,
                  "style": navStyle.value,
                  "role": "tablist",
                  "onKeydown": changeTab
                }, [...[!props.type ? createVNode(TabBar, {
                  "ref": tabBarRef,
                  "tabs": [...props.panes],
                  "tabRefs": tabRefsMap.value
                }, null) : null, tabs]]) : null])]);
              };
            }
          });
          const tabsProps = buildProps({
            type: {
              type: String,
              values: ["card", "border-card", ""],
              default: ""
            },
            closable: Boolean,
            addable: Boolean,
            modelValue: {
              type: [String, Number]
            },
            editable: Boolean,
            tabPosition: {
              type: String,
              values: ["top", "right", "bottom", "left"],
              default: "top"
            },
            beforeLeave: {
              type: definePropType(Function),
              default: () => true
            },
            stretch: Boolean
          });
          const isPaneName = (value) => isString$1(value) || isNumber(value);
          const tabsEmits = {
            [UPDATE_MODEL_EVENT]: (name) => isPaneName(name),
            tabClick: (pane, ev) => ev instanceof Event,
            tabChange: (name) => isPaneName(name),
            edit: (paneName, action) => ["remove", "add"].includes(action),
            tabRemove: (name) => isPaneName(name),
            tabAdd: () => true
          };
          const Tabs = /* @__PURE__ */ defineComponent({
            name: "ElTabs",
            props: tabsProps,
            emits: tabsEmits,
            setup(props, {
              emit: emit2,
              slots,
              expose
            }) {
              var _a2;
              const ns = useNamespace("tabs");
              const isVertical = computed(() => ["left", "right"].includes(props.tabPosition));
              const {
                children: panes,
                addChild: registerPane,
                removeChild: unregisterPane,
                ChildrenSorter: PanesSorter
              } = useOrderedChildren(getCurrentInstance(), "ElTabPane");
              const nav$ = ref();
              const currentName = ref((_a2 = props.modelValue) != null ? _a2 : "0");
              const setCurrentName = async (value, trigger2 = false) => {
                var _a22, _b, _c, _d;
                if (currentName.value === value || isUndefined(value))
                  return;
                try {
                  let canLeave;
                  if (props.beforeLeave) {
                    const result = props.beforeLeave(value, currentName.value);
                    canLeave = result instanceof Promise ? await result : result;
                  } else {
                    canLeave = true;
                  }
                  if (canLeave !== false) {
                    const isFocusInsidePane = (_a22 = panes.value.find((item) => item.paneName === currentName.value)) == null ? void 0 : _a22.isFocusInsidePane();
                    currentName.value = value;
                    if (trigger2) {
                      emit2(UPDATE_MODEL_EVENT, value);
                      emit2("tabChange", value);
                    }
                    (_c = (_b = nav$.value) == null ? void 0 : _b.removeFocus) == null ? void 0 : _c.call(_b);
                    if (isFocusInsidePane) {
                      (_d = nav$.value) == null ? void 0 : _d.focusActiveTab();
                    }
                  }
                } catch (e) {
                }
              };
              const handleTabClick = (tab, tabName, event) => {
                if (tab.props.disabled)
                  return;
                emit2("tabClick", tab, event);
                setCurrentName(tabName, true);
              };
              const handleTabRemove = (pane, ev) => {
                if (pane.props.disabled || isUndefined(pane.props.name))
                  return;
                ev.stopPropagation();
                emit2("edit", pane.props.name, "remove");
                emit2("tabRemove", pane.props.name);
              };
              const handleTabAdd = () => {
                emit2("edit", void 0, "add");
                emit2("tabAdd");
              };
              const swapChildren = (vnode) => {
                const actualFirstChild = vnode.el.firstChild;
                const firstChild = ["bottom", "right"].includes(props.tabPosition) ? vnode.children[0].el : vnode.children[1].el;
                if (actualFirstChild !== firstChild) {
                  actualFirstChild.before(firstChild);
                }
              };
              watch(() => props.modelValue, (modelValue) => setCurrentName(modelValue));
              watch(currentName, async () => {
                var _a22;
                await nextTick();
                (_a22 = nav$.value) == null ? void 0 : _a22.scrollToActiveTab();
              });
              provide(tabsRootContextKey, {
                props,
                currentName,
                registerPane,
                unregisterPane,
                nav$
              });
              expose({
                currentName,
                get tabNavRef() {
                  return omit(nav$.value, ["scheduleRender"]);
                }
              });
              return () => {
                const addSlot = slots["add-icon"];
                const newButton = props.editable || props.addable ? createVNode("div", {
                  "class": [ns.e("new-tab"), isVertical.value && ns.e("new-tab-vertical")],
                  "tabindex": "0",
                  "onClick": handleTabAdd,
                  "onKeydown": (ev) => {
                    if ([EVENT_CODE.enter, EVENT_CODE.numpadEnter].includes(ev.code))
                      handleTabAdd();
                  }
                }, [addSlot ? renderSlot(slots, "add-icon") : createVNode(ElIcon, {
                  "class": ns.is("icon-plus")
                }, {
                  default: () => [createVNode(plus_default, null, null)]
                })]) : null;
                const tabNav = () => createVNode(TabNav, {
                  "ref": nav$,
                  "currentName": currentName.value,
                  "editable": props.editable,
                  "type": props.type,
                  "panes": panes.value,
                  "stretch": props.stretch,
                  "onTabClick": handleTabClick,
                  "onTabRemove": handleTabRemove
                }, null);
                const header = createVNode("div", {
                  "class": [ns.e("header"), isVertical.value && ns.e("header-vertical"), ns.is(props.tabPosition)]
                }, [createVNode(PanesSorter, null, {
                  default: tabNav,
                  $stable: true
                }), newButton]);
                const panels = createVNode("div", {
                  "class": ns.e("content")
                }, [renderSlot(slots, "default")]);
                return createVNode("div", {
                  "class": [ns.b(), ns.m(props.tabPosition), {
                    [ns.m("card")]: props.type === "card",
                    [ns.m("border-card")]: props.type === "border-card"
                  }],
                  "onVnodeMounted": swapChildren,
                  "onVnodeUpdated": swapChildren
                }, [panels, header]);
              };
            }
          });
          var Tabs$1 = Tabs;
          const tabPaneProps = buildProps({
            label: {
              type: String,
              default: ""
            },
            name: {
              type: [String, Number]
            },
            closable: Boolean,
            disabled: Boolean,
            lazy: Boolean
          });
          const COMPONENT_NAME = "ElTabPane";
          const __default__$1 = /* @__PURE__ */ defineComponent({
            name: COMPONENT_NAME
          });
          const _sfc_main$7 = /* @__PURE__ */ defineComponent({
            ...__default__$1,
            props: tabPaneProps,
            setup(__props) {
              const props = __props;
              const instance = getCurrentInstance();
              const slots = useSlots();
              const tabsRoot = inject(tabsRootContextKey);
              if (!tabsRoot)
                throwError(COMPONENT_NAME, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
              const ns = useNamespace("tab-pane");
              const paneRef = ref();
              const index = ref();
              const isClosable = computed(() => props.closable || tabsRoot.props.closable);
              const active = computedEager(() => {
                var _a2;
                return tabsRoot.currentName.value === ((_a2 = props.name) != null ? _a2 : index.value);
              });
              const loaded = ref(active.value);
              const paneName = computed(() => {
                var _a2;
                return (_a2 = props.name) != null ? _a2 : index.value;
              });
              const shouldBeRender = computedEager(() => !props.lazy || loaded.value || active.value);
              const isFocusInsidePane = () => {
                var _a2;
                return (_a2 = paneRef.value) == null ? void 0 : _a2.contains(document.activeElement);
              };
              watch(active, (val) => {
                if (val)
                  loaded.value = true;
              });
              const pane = reactive({
                uid: instance.uid,
                getVnode: () => instance.vnode,
                slots,
                props,
                paneName,
                active,
                index,
                isClosable,
                isFocusInsidePane
              });
              tabsRoot.registerPane(pane);
              onBeforeUnmount(() => {
                tabsRoot.unregisterPane(pane);
              });
              onBeforeUpdate(() => {
                if (slots.label)
                  tabsRoot.nav$.value.scheduleRender();
              });
              return (_ctx, _cache) => {
                return unref(shouldBeRender) ? withDirectives((openBlock(), createElementBlock("div", {
                  key: 0,
                  id: `pane-${unref(paneName)}`,
                  ref_key: "paneRef",
                  ref: paneRef,
                  class: normalizeClass(unref(ns).b()),
                  role: "tabpanel",
                  "aria-hidden": !unref(active),
                  "aria-labelledby": `tab-${unref(paneName)}`
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 10, ["id", "aria-hidden", "aria-labelledby"])), [
                  [vShow, unref(active)]
                ]) : createCommentVNode("v-if", true);
              };
            }
          });
          var TabPane = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__file", "tab-pane.vue"]]);
          const ElTabs = withInstall(Tabs$1, {
            TabPane
          });
          const ElTabPane = withNoopInstall(TabPane);
          const messageTypes = [
            "primary",
            "success",
            "info",
            "warning",
            "error"
          ];
          const messageDefaults = mutable({
            customClass: "",
            dangerouslyUseHTMLString: false,
            duration: 3e3,
            icon: void 0,
            id: "",
            message: "",
            onClose: void 0,
            showClose: false,
            type: "info",
            plain: false,
            offset: 16,
            zIndex: 0,
            grouping: false,
            repeatNum: 1,
            appendTo: isClient ? document.body : void 0
          });
          const messageProps = buildProps({
            customClass: {
              type: String,
              default: messageDefaults.customClass
            },
            dangerouslyUseHTMLString: {
              type: Boolean,
              default: messageDefaults.dangerouslyUseHTMLString
            },
            duration: {
              type: Number,
              default: messageDefaults.duration
            },
            icon: {
              type: iconPropType,
              default: messageDefaults.icon
            },
            id: {
              type: String,
              default: messageDefaults.id
            },
            message: {
              type: definePropType([
                String,
                Object,
                Function
              ]),
              default: messageDefaults.message
            },
            onClose: {
              type: definePropType(Function),
              default: messageDefaults.onClose
            },
            showClose: {
              type: Boolean,
              default: messageDefaults.showClose
            },
            type: {
              type: String,
              values: messageTypes,
              default: messageDefaults.type
            },
            plain: {
              type: Boolean,
              default: messageDefaults.plain
            },
            offset: {
              type: Number,
              default: messageDefaults.offset
            },
            zIndex: {
              type: Number,
              default: messageDefaults.zIndex
            },
            grouping: {
              type: Boolean,
              default: messageDefaults.grouping
            },
            repeatNum: {
              type: Number,
              default: messageDefaults.repeatNum
            }
          });
          const messageEmits = {
            destroy: () => true
          };
          const instances = shallowReactive([]);
          const getInstance = (id) => {
            const idx = instances.findIndex((instance) => instance.id === id);
            const current = instances[idx];
            let prev;
            if (idx > 0) {
              prev = instances[idx - 1];
            }
            return { current, prev };
          };
          const getLastOffset = (id) => {
            const { prev } = getInstance(id);
            if (!prev)
              return 0;
            return prev.vm.exposed.bottom.value;
          };
          const getOffsetOrSpace = (id, offset) => {
            const idx = instances.findIndex((instance) => instance.id === id);
            return idx > 0 ? 16 : offset;
          };
          const __default__ = /* @__PURE__ */ defineComponent({
            name: "ElMessage"
          });
          const _sfc_main$6 = /* @__PURE__ */ defineComponent({
            ...__default__,
            props: messageProps,
            emits: messageEmits,
            setup(__props, { expose, emit: emit2 }) {
              const props = __props;
              const { Close } = TypeComponents;
              const isStartTransition = ref(false);
              const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("message");
              const { currentZIndex, nextZIndex } = zIndex2;
              const messageRef = ref();
              const visible = ref(false);
              const height = ref(0);
              let stopTimer = void 0;
              const badgeType = computed(() => props.type ? props.type === "error" ? "danger" : props.type : "info");
              const typeClass = computed(() => {
                const type = props.type;
                return { [ns.bm("icon", type)]: type && TypeComponentsMap[type] };
              });
              const iconComponent = computed(() => props.icon || TypeComponentsMap[props.type] || "");
              const lastOffset = computed(() => getLastOffset(props.id));
              const offset = computed(() => getOffsetOrSpace(props.id, props.offset) + lastOffset.value);
              const bottom = computed(() => height.value + offset.value);
              const customStyle = computed(() => ({
                top: `${offset.value}px`,
                zIndex: currentZIndex.value
              }));
              function startTimer() {
                if (props.duration === 0)
                  return;
                ({ stop: stopTimer } = useTimeoutFn(() => {
                  close();
                }, props.duration));
              }
              function clearTimer() {
                stopTimer == null ? void 0 : stopTimer();
              }
              function close() {
                visible.value = false;
                nextTick(() => {
                  var _a2;
                  if (!isStartTransition.value) {
                    (_a2 = props.onClose) == null ? void 0 : _a2.call(props);
                    emit2("destroy");
                  }
                });
              }
              function keydown({ code }) {
                if (code === EVENT_CODE.esc) {
                  close();
                }
              }
              onMounted(() => {
                startTimer();
                nextZIndex();
                visible.value = true;
              });
              watch(() => props.repeatNum, () => {
                clearTimer();
                startTimer();
              });
              useEventListener(document, "keydown", keydown);
              useResizeObserver(messageRef, () => {
                height.value = messageRef.value.getBoundingClientRect().height;
              });
              expose({
                visible,
                bottom,
                close
              });
              return (_ctx, _cache) => {
                return openBlock(), createBlock(Transition, {
                  name: unref(ns).b("fade"),
                  onBeforeEnter: ($event) => isStartTransition.value = true,
                  onBeforeLeave: _ctx.onClose,
                  onAfterLeave: ($event) => _ctx.$emit("destroy"),
                  persisted: ""
                }, {
                  default: withCtx(() => [
                    withDirectives(createBaseVNode("div", {
                      id: _ctx.id,
                      ref_key: "messageRef",
                      ref: messageRef,
                      class: normalizeClass([
                        unref(ns).b(),
                        { [unref(ns).m(_ctx.type)]: _ctx.type },
                        unref(ns).is("closable", _ctx.showClose),
                        unref(ns).is("plain", _ctx.plain),
                        _ctx.customClass
                      ]),
                      style: normalizeStyle(unref(customStyle)),
                      role: "alert",
                      onMouseenter: clearTimer,
                      onMouseleave: startTimer
                    }, [
                      _ctx.repeatNum > 1 ? (openBlock(), createBlock(unref(ElBadge), {
                        key: 0,
                        value: _ctx.repeatNum,
                        type: unref(badgeType),
                        class: normalizeClass(unref(ns).e("badge"))
                      }, null, 8, ["value", "type", "class"])) : createCommentVNode("v-if", true),
                      unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass([unref(ns).e("icon"), unref(typeClass)])
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true),
                      renderSlot(_ctx.$slots, "default", {}, () => [
                        !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", {
                          key: 0,
                          class: normalizeClass(unref(ns).e("content"))
                        }, toDisplayString(_ctx.message), 3)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                          createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                          createBaseVNode("p", {
                            class: normalizeClass(unref(ns).e("content")),
                            innerHTML: _ctx.message
                          }, null, 10, ["innerHTML"])
                        ], 2112))
                      ]),
                      _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 2,
                        class: normalizeClass(unref(ns).e("closeBtn")),
                        onClick: withModifiers(close, ["stop"])
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(Close))
                        ]),
                        _: 1
                      }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                    ], 46, ["id"]), [
                      [vShow, visible.value]
                    ])
                  ]),
                  _: 3
                }, 8, ["name", "onBeforeEnter", "onBeforeLeave", "onAfterLeave"]);
              };
            }
          });
          var MessageConstructor = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__file", "message.vue"]]);
          let seed = 1;
          const normalizeOptions = (params) => {
            const options = !params || isString$1(params) || isVNode(params) || isFunction$1(params) ? { message: params } : params;
            const normalized = {
              ...messageDefaults,
              ...options
            };
            if (!normalized.appendTo) {
              normalized.appendTo = document.body;
            } else if (isString$1(normalized.appendTo)) {
              let appendTo = document.querySelector(normalized.appendTo);
              if (!isElement(appendTo)) {
                appendTo = document.body;
              }
              normalized.appendTo = appendTo;
            }
            if (isBoolean(messageConfig.grouping) && !normalized.grouping) {
              normalized.grouping = messageConfig.grouping;
            }
            if (isNumber(messageConfig.duration) && normalized.duration === 3e3) {
              normalized.duration = messageConfig.duration;
            }
            if (isNumber(messageConfig.offset) && normalized.offset === 16) {
              normalized.offset = messageConfig.offset;
            }
            if (isBoolean(messageConfig.showClose) && !normalized.showClose) {
              normalized.showClose = messageConfig.showClose;
            }
            if (isBoolean(messageConfig.plain) && !normalized.plain) {
              normalized.plain = messageConfig.plain;
            }
            return normalized;
          };
          const closeMessage = (instance) => {
            const idx = instances.indexOf(instance);
            if (idx === -1)
              return;
            instances.splice(idx, 1);
            const { handler } = instance;
            handler.close();
          };
          const createMessage = ({ appendTo, ...options }, context) => {
            const id = `message_${seed++}`;
            const userOnClose = options.onClose;
            const container = document.createElement("div");
            const props = {
              ...options,
              id,
              onClose: () => {
                userOnClose == null ? void 0 : userOnClose();
                closeMessage(instance);
              },
              onDestroy: () => {
                render(null, container);
              }
            };
            const vnode = createVNode(MessageConstructor, props, isFunction$1(props.message) || isVNode(props.message) ? {
              default: isFunction$1(props.message) ? props.message : () => props.message
            } : null);
            vnode.appContext = context || message._context;
            render(vnode, container);
            appendTo.appendChild(container.firstElementChild);
            const vm = vnode.component;
            const handler = {
              close: () => {
                vm.exposed.close();
              }
            };
            const instance = {
              id,
              vnode,
              vm,
              handler,
              props: vnode.component.props
            };
            return instance;
          };
          const message = (options = {}, context) => {
            if (!isClient)
              return { close: () => void 0 };
            const normalized = normalizeOptions(options);
            if (normalized.grouping && instances.length) {
              const instance2 = instances.find(({ vnode: vm }) => {
                var _a2;
                return ((_a2 = vm.props) == null ? void 0 : _a2.message) === normalized.message;
              });
              if (instance2) {
                instance2.props.repeatNum += 1;
                instance2.props.type = normalized.type;
                return instance2.handler;
              }
            }
            if (isNumber(messageConfig.max) && instances.length >= messageConfig.max) {
              return { close: () => void 0 };
            }
            const instance = createMessage(normalized, context);
            instances.push(instance);
            return instance.handler;
          };
          messageTypes.forEach((type) => {
            message[type] = (options = {}, appContext) => {
              const normalized = normalizeOptions(options);
              return message({ ...normalized, type }, appContext);
            };
          });
          function closeAll(type) {
            const instancesToClose = [...instances];
            for (const instance of instancesToClose) {
              if (!type || type === instance.props.type) {
                instance.handler.close();
              }
            }
          }
          message.closeAll = closeAll;
          message._context = null;
          const ElMessage = withInstallFunction(message, "$message");
          let config = {
            color: "rgba(0,0,0,0)",
            // 链接颜色，默认为透明色以适配暗色模式
            presets: "all",
            // 使用的预设规则
            debug: false,
            // 是否开启调试模式
            expirationTime: 1e3 * 60 * 60 * 24 * 365
            // 链接染色的过期时间，毫秒为单位，默认为一年
          };
          const PRESET_RULES = {
            "36kr": {
              pages: [
                /https:\/\/36kr\.com\/$/,
                // 首页
                /https:\/\/36kr\.com\/motif\/\d+$/,
                // 主题页
                /https:\/\/36kr\.com\/newsflashes\/$/,
                // 快讯页
                /https:\/\/36kr\.com\/information\/.*/,
                // 资讯页
                /https:\/\/36kr\.com\/topics\/\d+$/
                // 专题页
              ],
              patterns: [
                /36kr\.com\/p\/\d+$/,
                // 文章页
                /36kr\.com\/newsflashes\/\d+$/
                // 快讯详情页
              ]
            },
            "bahamut": {
              pages: [
                /https:\/\/forum\.gamer\.com\.tw\/(A|B|G1)\.php\?bsn=.*/
                // 各个板块首页
              ],
              patterns: [
                /forum\.gamer\.com\.tw\/C\.php\?bsn=.*/
                // 帖子
              ]
            },
            "bilibili": {
              pages: [
                // TODO: 动态页挂载不上，以后再研究研究
                // /https:\/\/t\.bilibili\.com.*/,
                /https:\/\/space\.bilibili\.com\/\d+(\?.*)?$/,
                // 个人空间首页
                /https:\/\/space\.bilibili\.com\/\d+\/video/,
                // 个人空间投稿（疑似已失效）
                /https:\/\/space\.bilibili\.com\/\d+\/upload.*/,
                // 个人空间投稿
                /https:\/\/www\.bilibili\.com\/video\/BV.*/,
                // 视频详情页
                /https:\/\/www\.bilibili\.com\/list\/watchlater\?.*/
                // 稍后再看中的视频详情页
              ],
              patterns: [
                /www\.bilibili\.com\/video\/BV.*/
                // 视频详情页
              ]
            },
            "chiphell": {
              pages: [
                /https:\/\/www\.chiphell\.com\/forum-.*/
              ],
              patterns: [
                /chiphell\.com\/thread-.*/
              ]
            },
            "douban": {
              pages: [
                /https:\/\/www\.douban\.com\/group\/.*/
                // 小组首页
              ],
              patterns: [
                /douban\.com\/group\/topic\/\d+\//
                // 小组帖子
              ]
            },
            "e-hentai-forums": {
              pages: [
                /https:\/\/forums\.e-hentai\.org\/index\.php\?showforum=\d+/
                // 论坛版块页面
              ],
              patterns: [
                /https:\/\/forums\.e-hentai\.org\/index\.php\?showtopic=\d+/
                // 帖子页面
              ]
            },
            "ehentai": {
              pages: [
                /https:\/\/e-hentai\.org\/?$/,
                // 首页
                /https:\/\/exhentai\.org\/?$/,
                // 首页
                /https:\/\/e-hentai\.org\/toplist\.php\?tl=\d+/,
                // 排行榜
                /https:\/\/exhentai\.org\/toplist\.php\?tl=\d+/,
                // 排行榜
                /https:\/\/e-hentai\.org\/\?f_search=.*/,
                // 首页搜索页
                /https:\/\/exhentai\.org\/\?f_search=.*/,
                // 首页搜索页
                /https:\/\/e-hentai\.org\/popular/,
                // 热门页面
                /https:\/\/exhentai\.org\/popular/
                // 热门页面
              ],
              patterns: [
                /https:\/\/e-hentai\.org\/g\/\d+\/\w+\//,
                // 画廊页面
                /https:\/\/exhentai\.org\/g\/\d+\/\w+\//
                // 画廊页面
              ]
            },
            // TODO: 很纯粹的网站，纯静态资源，暂时无能为力，后续研究一下
            "hacg": {
              pages: [
                /https:\/\/www\.hacg\.me\/wp\/$/,
                // 首页
                /https:\/\/www\.hacg\.me\/wp\/[a-zA-Z].*/
                // 分类目录页
              ],
              patterns: [
                /hacg\.me\/wp\/\d+\.html/
                // 文章页
              ]
            },
            "Hacker News": {
              pages: [
                /https:\/\/news\.ycombinator\.com\/.*/,
                // 任意内容
                /https:\/\/news\.ycombinator\.com\/newest.*/,
                // newest任意内容
                /https:\/\/news\.ycombinator\.com\/front.*/,
                // front任意内容
                /https:\/\/news\.ycombinator\.com\/show.*/
                // show任意内容
              ],
              patterns: [
                /.*/
                // 任意链接
              ]
            },
            "hostloc": {
              pages: [
                /https:\/\/hostloc\.com\/forum-.*/
                // 板块首页
              ],
              patterns: [
                /hostloc\.com\/thread.*/
                // 帖子
              ]
            },
            "hupu": {
              pages: [
                /https:\/\/bbs\.hupu\.com\/[a-zA-Z].*/
                // 各个板块首页
              ],
              patterns: [
                /bbs\.hupu\.com\/\d+\.html/
                // 帖子
              ]
            },
            "linuxdo": {
              pages: [
                /https:\/\/linux\.do\/?$/,
                // 首页
                /https:\/\/linux\.do\/(latest|new|top|hot|categories)/,
                // 首页的几个页签
                /https:\/\/linux\.do\/c\/.*/
              ],
              patterns: [
                /linux\.do\/t\/topic\/.*/
              ]
            },
            "nga": {
              pages: [
                /https:\/\/bbs\.nga\.cn\/thread\.php\?(fid|stid).*/,
                /https:\/\/ngabbs\.com\/thread\.php\?(fid|stid).*/,
                /https:\/\/nga\.178\.com\/thread\.php\?(fid|stid).*/
              ],
              patterns: [
                /bbs\.nga\.cn\/read\.php\?tid.*/,
                /ngabbs\.com\/read\.php\?tid.*/,
                /nga\.178\.com\/read\.php\?tid.*/
              ]
            },
            "nodeseek": {
              pages: [
                /https:\/\/www\.nodeseek\.com\/?$/,
                // 首页
                /https:\/\/www\.nodeseek\.com\/categories\/.*/,
                // 各个板块
                /https:\/\/www\.nodeseek\.com\/page-\d+/
                // 分页
              ],
              patterns: [
                /https:\/\/www\.nodeseek\.com\/post-.*/
                // 帖子
              ]
            },
            "reddit": {
              pages: [
                /https:\/\/www\.reddit\.com\/r\/[^\/]+\/?$/
                // 板块首页
              ],
              patterns: [
                /reddit\.com\/r\/[^\/]+\/comments\/.*/
                // 帖子
              ]
            },
            "Seeking Alpha": {
              pages: [
                /https:\/\/seekingalpha\.com\/$/,
                // 首页
                /https:\/\/seekingalpha\.com\/symbol\/.*/
                // 股票符号页面
              ],
              patterns: [
                /https:\/\/seekingalpha\.com\/article\/.*/,
                // 文章页面
                /https:\/\/seekingalpha\.com\/news\/.*/
                // 新闻页面
              ]
            },
            "south-plus": {
              pages: [
                /https:\/\/www\.(south|north|blue|white|level|snow|spring|summer)-plus\.net\/thread\.php\?fid.*/,
                // 板块首页
                /https:\/\/bbs\.imoutolove\.me\/thread\.php\?fid.*/,
                // 板块首页
                /https:\/\/www\.(south|north|blue|white|level|snow|spring|summer)-plus\.net\/u\.php\?action-topic-uid-.*/
                // 个人主页
              ],
              patterns: [
                /(south|north|blue|white|level|snow|spring|summer)-plus\.net\/read\.php\?tid-.*/,
                // 帖子
                /bbs\.imoutolove\.me\/read\.php\?tid-.*/
                // 帖子
              ]
            },
            "techflow": {
              pages: [
                /https:\/\/www\.techflowpost\.com\/$/
                // 首页
              ],
              patterns: [
                /techflowpost\.com\/article\/.*/
                // 文章页
              ]
            },
            "tieba": {
              pages: [
                /https:\/\/tieba\.baidu\.com\/f\?kw=.*/,
                // 某个吧首页
                /https:\/\/tieba\.baidu\.com\/hottopic.*/
                // 热榜
              ],
              patterns: [
                /tieba\.baidu\.com\/p\/\d+/
                // 帖子
              ]
            },
            "v2ex": {
              pages: [
                /https:\/\/www\.v2ex\.com\/$/,
                /https:\/\/www\.v2ex\.com\/\?tab.*/,
                /https:\/\/www\.v2ex\.com\/go\/.*/
              ],
              patterns: [
                /v2ex\.com\/t\/.*/
              ]
            },
            "zhihu": {
              pages: [
                /https:\/\/www\.zhihu\.com\/$/,
                // 首页
                /https:\/\/www\.zhihu\.com\/hot$/,
                // 热榜
                /https:\/\/www\.zhihu\.com\/people\/.*/
                // 个人
              ],
              patterns: [
                /zhihu\.com\/question\/\d+\/answer\/\d+$/,
                // 具体的回答页
                /zhihu\.com\/question\/\d+$/,
                // 问题页
                /zhuanlan\.zhihu\.com\/p\/\d+/
                // 专栏文章
              ]
            }
            // resources: https://rebang.today/
            // TODO: enshan 油猴脚本都加载不进去，之后再试试
            // TODO: reddit 第一次点击的时候不会变色，刷新后才会
            // TODO: 优化一下多次获取 patterns 的逻辑
            // TODO: 让 o1 优化一下
          };
          function mitt(n) {
            return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
              var i = n.get(t);
              i ? i.push(e) : n.set(t, [e]);
            }, off: function(t, e) {
              var i = n.get(t);
              i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
            }, emit: function(t, e) {
              var i = n.get(t);
              i && i.slice().map(function(n2) {
                n2(e);
              }), (i = n.get("*")) && i.slice().map(function(n2) {
                n2(t, e);
              });
            } };
          }
          const emitter = mitt();
          const eventBus = emitter;
          function showNotification(message2, type) {
            const messageType = type || (/失败|错误|error/i.test(message2) ? "error" : "success");
            const container = document.querySelector("#color-visited-root");
            const appendTarget = container && container.shadowRoot || document.body;
            ElMessage({
              message: message2,
              type: messageType,
              duration: 2e3,
              showClose: true,
              grouping: true,
              offset: 20,
              // 将 Message 组件挂载到 Shadow DOM 中
              appendTo: appendTarget
            });
          }
          function injectCustomStyles() {
            if (document.querySelector("#color-visited-style")) return;
            const style = document.createElement("style");
            style.id = "color-visited-style";
            style.innerHTML = `
    a.visited-link,
    a.visited-link *,
    a.visited-link *::before,
    a.visited-link *::after {
      color: ${config.color} !important;
    }
  `;
            document.head.appendChild(style);
          }
          function removeCustomStyles() {
            const styleElement = document.querySelector("#color-visited-style");
            if (styleElement) {
              styleElement.remove();
            }
          }
          function showSettingsDialog(currentSettings, defaultSettings, currentGeneralSettings, defaultGeneralSettings, currentPresetStates, currentSyncSettings, isMac2, onSave, onReset, onGeneralSave, onGeneralReset, onPresetSave, onPresetReset, onSyncSave, onSyncReset) {
            eventBus.emit("dialog:show-settings", {
              type: "settings",
              payload: {
                currentSettings,
                defaultSettings,
                currentGeneralSettings,
                defaultGeneralSettings,
                currentPresetStates,
                currentSyncSettings,
                isMac: isMac2
              }
            });
            const handleSettingsSave = (event) => {
              if (event.type === "batch-key" && event.settings) {
                onSave(event.settings);
              } else if (event.type === "general" && event.settings) {
                onGeneralSave(event.settings);
              } else if (event.type === "preset" && event.states) {
                onPresetSave(event.states);
              } else if (event.type === "sync" && event.settings) {
                onSyncSave(event.settings);
              }
            };
            const handleSettingsReset = (event) => {
              if (event.type === "batch-key") {
                onReset();
              } else if (event.type === "general") {
                onGeneralReset();
              } else if (event.type === "preset") {
                onPresetReset();
              } else if (event.type === "sync") {
                onSyncReset();
              }
            };
            eventBus.on("settings:save", handleSettingsSave);
            eventBus.on("settings:reset", handleSettingsReset);
            const cleanup = () => {
              eventBus.off("settings:save", handleSettingsSave);
              eventBus.off("settings:reset", handleSettingsReset);
            };
            return cleanup;
          }
          const _hoisted_1$4 = { class: "space-y-6" };
          const _hoisted_2$3 = { class: "flex items-center gap-3" };
          const _hoisted_3$3 = { class: "space-y-2" };
          const _hoisted_4$3 = { class: "flex items-center gap-2" };
          const _hoisted_5$3 = { class: "space-y-2" };
          const _sfc_main$5 = /* @__PURE__ */ defineComponent({
            __name: "GeneralSettings",
            props: {
              currentSettings: {},
              defaultSettings: {}
            },
            emits: ["save", "reset"],
            setup(__props, { expose: __expose, emit: __emit }) {
              const props = __props;
              const emit2 = __emit;
              const formData = ref({ ...props.currentSettings });
              const hasChanges = computed(() => {
                return JSON.stringify(formData.value) !== JSON.stringify(props.currentSettings);
              });
              const colorPresets = [
                "rgba(0,0,0,0)",
                // 透明色，适配暗色模式
                "#f1f5f9",
                // slate-100
                "#e2e8f0",
                // slate-200
                "#cbd5e1",
                // slate-300
                "#94a3b8",
                // slate-400
                "#64748b",
                // slate-500
                "#475569",
                // slate-600
                "#334155",
                // slate-700
                "#1e293b",
                // slate-800
                "#0f172a"
                // slate-900
              ];
              const expirationDays = computed({
                get: () => Math.round(formData.value.expirationTime / (1e3 * 60 * 60 * 24)),
                set: (days) => {
                  formData.value.expirationTime = days * 1e3 * 60 * 60 * 24;
                }
              });
              const handleSave = () => {
                emit2("save", { ...formData.value });
                showNotification("常规设置已保存！");
              };
              const handleReset = () => {
                formData.value = { ...props.defaultSettings };
                showNotification("常规设置已重置为默认！");
              };
              watch(() => props.currentSettings, (newSettings) => {
                formData.value = { ...newSettings };
              }, { immediate: true, deep: true });
              __expose({
                save: handleSave,
                reset: handleReset,
                getFormData: () => ({ ...formData.value }),
                hasChanges
              });
              return (_ctx, _cache) => {
                const _component_el_color_picker = ElColorPicker;
                const _component_el_input = ElInput;
                const _component_el_form_item = ElFormItem;
                const _component_el_input_number = ElInputNumber;
                const _component_el_switch = ElSwitch;
                const _component_el_form = ElForm;
                return openBlock(), createElementBlock("div", _hoisted_1$4, [
                  _cache[7] || (_cache[7] = createBaseVNode("div", { class: "border-b pb-4" }, [
                    createBaseVNode("h3", { class: "text-lg font-semibold text-gray-900 mb-2" }, "常规设置"),
                    createBaseVNode("p", { class: "text-sm text-gray-600" }, "自定义链接颜色和行为设置")
                  ], -1)),
                  createVNode(_component_el_form, {
                    model: formData.value,
                    "label-width": "120px",
                    class: "space-y-6"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_form_item, { label: "链接颜色" }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_2$3, [
                            createVNode(_component_el_color_picker, {
                              modelValue: formData.value.color,
                              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => formData.value.color = $event),
                              "show-alpha": "",
                              predefine: colorPresets,
                              size: "large"
                            }, null, 8, ["modelValue"]),
                            createVNode(_component_el_input, {
                              modelValue: formData.value.color,
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => formData.value.color = $event),
                              class: "flex-1",
                              placeholder: "请输入颜色值",
                              clearable: ""
                            }, null, 8, ["modelValue"])
                          ])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_form_item, { label: "过期时间" }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_3$3, [
                            createBaseVNode("div", _hoisted_4$3, [
                              createVNode(_component_el_input_number, {
                                modelValue: expirationDays.value,
                                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => expirationDays.value = $event),
                                min: 1,
                                max: 3650,
                                "controls-position": "right",
                                size: "large",
                                class: "w-32"
                              }, null, 8, ["modelValue"]),
                              _cache[4] || (_cache[4] = createBaseVNode("span", { class: "text-sm text-gray-600" }, "天", -1))
                            ]),
                            _cache[5] || (_cache[5] = createBaseVNode("div", { class: "text-xs text-gray-500" }, "设置已访问链接的记录保留时间", -1))
                          ])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_form_item, { label: "调试模式" }, {
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_5$3, [
                            createVNode(_component_el_switch, {
                              modelValue: formData.value.debug,
                              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => formData.value.debug = $event),
                              size: "large",
                              "inline-prompt": ""
                            }, null, 8, ["modelValue"]),
                            _cache[6] || (_cache[6] = createBaseVNode("div", { class: "text-xs text-gray-500" }, "开启后将在控制台显示详细调试信息", -1))
                          ])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["model"])
                ]);
              };
            }
          });
          var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
          var _GM_registerMenuCommand = /* @__PURE__ */ (() => typeof GM_registerMenuCommand != "undefined" ? GM_registerMenuCommand : void 0)();
          var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
          const _hoisted_1$3 = { class: "space-y-4 h-full overflow-y-auto" };
          const _hoisted_2$2 = { class: "border-b pb-3" };
          const _hoisted_3$2 = { class: "flex items-start justify-between" };
          const _hoisted_4$2 = { class: "bg-gradient-to-r from-blue-50 to-purple-50 border border-blue-200 rounded-xl p-4 ml-6" };
          const _hoisted_5$2 = { class: "flex items-center justify-between" };
          const _hoisted_6$2 = { class: "text-right" };
          const _hoisted_7$1 = { class: "text-lg font-bold text-green-600" };
          const _hoisted_8$1 = { class: "flex space-x-2 ml-4" };
          const _hoisted_9$1 = { class: "space-y-2" };
          const _hoisted_10 = { class: "p-5" };
          const _hoisted_11 = { class: "flex items-center justify-between" };
          const _hoisted_12 = ["onClick"];
          const _hoisted_13 = { class: "flex-1" };
          const _hoisted_14 = { class: "flex items-center space-x-3" };
          const _hoisted_15 = { class: "font-semibold text-gray-900 capitalize text-lg" };
          const _hoisted_16 = { class: "text-sm text-gray-500 mt-1" };
          const _hoisted_17 = {
            key: 0,
            class: "text-xs text-gray-400 mt-1"
          };
          const _hoisted_18 = { class: "border-t border-gray-100" };
          const _hoisted_19 = { class: "px-5 py-3 bg-gray-50/50 rounded-b-xl space-y-3" };
          const _hoisted_20 = {
            key: 0,
            class: "bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4"
          };
          const _hoisted_21 = { class: "flex items-start space-x-2" };
          const _hoisted_22 = { class: "text-sm text-blue-800" };
          const _hoisted_23 = {
            key: 1,
            class: "bg-white rounded-lg border border-gray-200 p-4 mb-3"
          };
          const _hoisted_24 = { class: "flex items-center space-x-2 mb-3" };
          const _hoisted_25 = { class: "bg-green-100 text-green-800 text-xs px-2 py-1 rounded-full" };
          const _hoisted_26 = { class: "space-y-2 max-h-32 overflow-y-auto" };
          const _hoisted_27 = {
            key: 2,
            class: "bg-white rounded-lg border border-gray-200 p-4"
          };
          const _hoisted_28 = { class: "flex items-center space-x-2 mb-3" };
          const _hoisted_29 = { class: "bg-purple-100 text-purple-800 text-xs px-2 py-1 rounded-full" };
          const _hoisted_30 = { class: "space-y-2 max-h-32 overflow-y-auto" };
          const _sfc_main$4 = /* @__PURE__ */ defineComponent({
            __name: "PresetSettings",
            props: {
              currentPresetStates: {}
            },
            emits: ["save", "reset"],
            setup(__props, { expose: __expose, emit: __emit }) {
              const props = __props;
              const emit2 = __emit;
              const presetRules = PRESET_RULES;
              const expandedSites = ref(/* @__PURE__ */ new Set());
              const presetStates = ref({});
              const savedPresetStates = ref({});
              const hasChanges = computed(() => {
                return JSON.stringify(presetStates.value) !== JSON.stringify(savedPresetStates.value);
              });
              const initializePresetStates = () => {
                const states = {};
                Object.keys(presetRules).forEach((siteName) => {
                  states[siteName] = true;
                });
                if (typeof _GM_getValue !== "undefined") {
                  const savedStates = _GM_getValue("preset_states", {});
                  Object.keys(states).forEach((siteName) => {
                    if (savedStates.hasOwnProperty(siteName)) {
                      states[siteName] = savedStates[siteName];
                    }
                  });
                }
                if (props.currentPresetStates) {
                  Object.keys(states).forEach((siteName) => {
                    if (props.currentPresetStates.hasOwnProperty(siteName)) {
                      states[siteName] = props.currentPresetStates[siteName];
                    }
                  });
                }
                presetStates.value = { ...states };
                savedPresetStates.value = { ...states };
              };
              const updatePresetState = (siteName, enabled) => {
                const isEnabled = Boolean(enabled);
                presetStates.value[siteName] = isEnabled;
              };
              const toggleAllPresets = (enabled) => {
                Object.keys(presetStates.value).forEach((siteName) => {
                  presetStates.value[siteName] = enabled;
                });
              };
              const handleSave = () => {
                if (typeof _GM_setValue !== "undefined") {
                  _GM_setValue("preset_states", presetStates.value);
                }
                if (typeof window !== "undefined" && window.dispatchEvent) {
                  window.dispatchEvent(new CustomEvent("preset-states-updated", {
                    detail: { presetStates: presetStates.value }
                  }));
                }
                savedPresetStates.value = { ...presetStates.value };
                emit2("save", { ...presetStates.value });
                showNotification("预设网站设置已保存！");
              };
              const handleReset = () => {
                const defaultStates = {};
                Object.keys(presetRules).forEach((siteName) => {
                  defaultStates[siteName] = true;
                });
                presetStates.value = { ...defaultStates };
                emit2("reset");
                showNotification("预设网站设置已重置为默认！");
              };
              const toggleExpanded = (siteName) => {
                if (expandedSites.value.has(siteName)) {
                  expandedSites.value.delete(siteName);
                } else {
                  expandedSites.value.add(siteName);
                }
              };
              const formatRegex = (regex) => {
                if (regex instanceof RegExp) {
                  return regex.source;
                }
                return regex;
              };
              watch(() => props.currentPresetStates, (newStates) => {
                if (newStates) {
                  presetStates.value = { ...newStates };
                  savedPresetStates.value = { ...newStates };
                }
              }, { immediate: true, deep: true });
              onMounted(() => {
                initializePresetStates();
              });
              __expose({
                save: handleSave,
                reset: handleReset,
                getFormData: () => ({ ...presetStates.value }),
                hasChanges
              });
              return (_ctx, _cache) => {
                const _component_ArrowRight = resolveComponent("ArrowRight");
                const _component_el_icon = ElIcon;
                const _component_el_switch = ElSwitch;
                const _component_el_collapse_transition = ElCollapseTransition;
                return openBlock(), createElementBlock("div", _hoisted_1$3, [
                  createBaseVNode("div", _hoisted_2$2, [
                    createBaseVNode("div", _hoisted_3$2, [
                      _cache[4] || (_cache[4] = createBaseVNode("div", null, [
                        createBaseVNode("h3", { class: "text-lg font-semibold text-gray-900 mb-2" }, "预设网站管理"),
                        createBaseVNode("p", { class: "text-sm text-gray-600" }, "控制脚本在哪些网站生效，点击网站名称展开查看详情")
                      ], -1)),
                      createBaseVNode("div", _hoisted_4$2, [
                        createBaseVNode("div", _hoisted_5$2, [
                          createBaseVNode("div", _hoisted_6$2, [
                            _cache[3] || (_cache[3] = createBaseVNode("div", { class: "text-sm text-gray-500" }, "已启用", -1)),
                            createBaseVNode("div", _hoisted_7$1, toDisplayString(Object.values(presetStates.value).filter(Boolean).length) + " / " + toDisplayString(Object.keys(presetStates.value).length), 1)
                          ]),
                          createBaseVNode("div", _hoisted_8$1, [
                            createBaseVNode("button", {
                              onClick: _cache[0] || (_cache[0] = ($event) => toggleAllPresets(true)),
                              class: "px-3 py-1.5 text-xs font-medium text-green-700 bg-green-100 hover:bg-green-200 rounded-lg transition-colors"
                            }, " 全部启用 "),
                            createBaseVNode("button", {
                              onClick: _cache[1] || (_cache[1] = ($event) => toggleAllPresets(false)),
                              class: "px-3 py-1.5 text-xs font-medium text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors"
                            }, " 全部禁用 ")
                          ])
                        ])
                      ])
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_9$1, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(presetRules), (rule, siteName) => {
                      return openBlock(), createElementBlock("div", {
                        key: siteName,
                        class: "bg-white rounded-xl border border-gray-200 shadow-sm hover:shadow-md transition-all duration-300"
                      }, [
                        createBaseVNode("div", _hoisted_10, [
                          createBaseVNode("div", _hoisted_11, [
                            createBaseVNode("div", {
                              class: "flex items-center flex-1 cursor-pointer",
                              onClick: ($event) => toggleExpanded(siteName)
                            }, [
                              createBaseVNode("div", _hoisted_13, [
                                createBaseVNode("div", _hoisted_14, [
                                  createBaseVNode("h4", _hoisted_15, toDisplayString(siteName), 1),
                                  createVNode(_component_el_icon, {
                                    class: normalizeClass(["text-gray-400 transition-all duration-200", { "rotate-90 text-blue-500": expandedSites.value.has(siteName) }])
                                  }, {
                                    default: withCtx(() => [
                                      createVNode(_component_ArrowRight)
                                    ]),
                                    _: 2
                                  }, 1032, ["class"])
                                ]),
                                createBaseVNode("p", _hoisted_16, toDisplayString(rule.pages.length) + " 种生效范围 · " + toDisplayString(rule.patterns.length) + " 种可染色链接 ", 1),
                                rule.description ? (openBlock(), createElementBlock("div", _hoisted_17, toDisplayString(rule.description), 1)) : createCommentVNode("", true)
                              ])
                            ], 8, _hoisted_12),
                            createBaseVNode("div", {
                              class: "flex items-center ml-4",
                              onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                              }, ["stop"]))
                            }, [
                              createVNode(_component_el_switch, {
                                modelValue: presetStates.value[siteName],
                                "onUpdate:modelValue": ($event) => presetStates.value[siteName] = $event,
                                onChange: ($event) => updatePresetState(siteName, $event),
                                size: "default",
                                "active-color": "#10b981",
                                "inactive-color": "#d1d5db"
                              }, null, 8, ["modelValue", "onUpdate:modelValue", "onChange"])
                            ])
                          ])
                        ]),
                        createVNode(_component_el_collapse_transition, null, {
                          default: withCtx(() => [
                            withDirectives(createBaseVNode("div", _hoisted_18, [
                              createBaseVNode("div", _hoisted_19, [
                                createBaseVNode("div", null, [
                                  rule.description ? (openBlock(), createElementBlock("div", _hoisted_20, [
                                    createBaseVNode("div", _hoisted_21, [
                                      _cache[5] || (_cache[5] = createBaseVNode("div", { class: "w-1.5 h-1.5 rounded-full bg-blue-400 mt-2 flex-shrink-0" }, null, -1)),
                                      createBaseVNode("p", _hoisted_22, toDisplayString(rule.description), 1)
                                    ])
                                  ])) : createCommentVNode("", true),
                                  rule.pages.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_23, [
                                    createBaseVNode("div", _hoisted_24, [
                                      _cache[6] || (_cache[6] = createBaseVNode("div", { class: "w-2 h-2 rounded-full bg-green-500" }, null, -1)),
                                      _cache[7] || (_cache[7] = createBaseVNode("span", { class: "font-medium text-gray-900 text-sm" }, "在下面这些页面中生效", -1)),
                                      createBaseVNode("span", _hoisted_25, toDisplayString(rule.pages.length) + " 个 ", 1)
                                    ]),
                                    createBaseVNode("div", _hoisted_26, [
                                      (openBlock(true), createElementBlock(Fragment, null, renderList(rule.pages, (page, index) => {
                                        return openBlock(), createElementBlock("div", {
                                          key: index,
                                          class: "text-xs text-gray-700 font-mono bg-gray-50 px-3 py-2 rounded-md border border-gray-200 break-all hover:bg-gray-100 transition-colors"
                                        }, toDisplayString(formatRegex(page)), 1);
                                      }), 128))
                                    ])
                                  ])) : createCommentVNode("", true),
                                  rule.patterns.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_27, [
                                    createBaseVNode("div", _hoisted_28, [
                                      _cache[8] || (_cache[8] = createBaseVNode("div", { class: "w-2 h-2 rounded-full bg-purple-500" }, null, -1)),
                                      _cache[9] || (_cache[9] = createBaseVNode("span", { class: "font-medium text-gray-900 text-sm" }, "对下面这些链接染色", -1)),
                                      createBaseVNode("span", _hoisted_29, toDisplayString(rule.patterns.length) + " 个 ", 1)
                                    ]),
                                    createBaseVNode("div", _hoisted_30, [
                                      (openBlock(true), createElementBlock(Fragment, null, renderList(rule.patterns, (pattern, index) => {
                                        return openBlock(), createElementBlock("div", {
                                          key: index,
                                          class: "text-xs text-gray-700 font-mono bg-gray-50 px-3 py-2 rounded-md border border-gray-200 break-all hover:bg-gray-100 transition-colors"
                                        }, toDisplayString(formatRegex(pattern)), 1);
                                      }), 128))
                                    ])
                                  ])) : createCommentVNode("", true)
                                ])
                              ])
                            ], 512), [
                              [vShow, expandedSites.value.has(siteName)]
                            ])
                          ]),
                          _: 2
                        }, 1024)
                      ]);
                    }), 128))
                  ])
                ]);
              };
            }
          });
          const _hoisted_1$2 = { class: "space-y-6" };
          const _sfc_main$3 = /* @__PURE__ */ defineComponent({
            __name: "ShortcutSettings",
            props: {
              currentSettings: {},
              defaultSettings: {},
              isMac: { type: Boolean },
              visible: { type: Boolean },
              isActive: { type: Boolean }
            },
            emits: ["save", "reset"],
            setup(__props, { expose: __expose, emit: __emit }) {
              const props = __props;
              const emit2 = __emit;
              const formData = ref({ ...props.currentSettings });
              const newSettings = ref({ ...props.currentSettings });
              const hasNewKeyPress = ref(false);
              const isResetMode = ref(false);
              const hintText = computed(() => {
                if (hasNewKeyPress.value) {
                  return isResetMode.value ? "已设置为默认快捷键，点击保存应用设置" : "已记录新快捷键，点击保存应用设置";
                }
                return "请按下您想要使用的快捷键组合...";
              });
              const currentShortcutDisplay = computed(() => {
                const settings = hasNewKeyPress.value ? newSettings.value : formData.value;
                const shortcutText = [];
                if (settings.metaKey) shortcutText.push(props.isMac ? "⌘ Command" : "Win");
                if (settings.ctrlKey) shortcutText.push(props.isMac ? "⌃ Control" : "Ctrl");
                if (settings.altKey) shortcutText.push(props.isMac ? "⌥ Option" : "Alt");
                if (settings.shiftKey) shortcutText.push(props.isMac ? "⇧ Shift" : "Shift");
                let keyDisplay = settings.key;
                if (settings.key) {
                  const keyMap = {
                    "ArrowUp": "↑",
                    "ArrowDown": "↓",
                    "ArrowLeft": "←",
                    "ArrowRight": "→",
                    "Enter": "⏎",
                    "Backspace": "⌫",
                    "Delete": "⌦",
                    "Escape": "Esc",
                    " ": "Space"
                  };
                  keyDisplay = keyMap[settings.key] || settings.key;
                }
                if (keyDisplay) {
                  shortcutText.push(keyDisplay);
                }
                return shortcutText.length > 0 ? shortcutText.join(" + ") : "未设置";
              });
              const handleKeyDown = (e) => {
                if (e.key === "Control" || e.key === "Shift" || e.key === "Alt" || e.key === "Meta") {
                  return;
                }
                const ignoredKeys = ["Tab", "CapsLock", "NumLock", "ScrollLock", "Insert", "PrintScreen", "Pause"];
                if (ignoredKeys.includes(e.key)) {
                  return;
                }
                e.preventDefault();
                e.stopPropagation();
                let keyName = e.key;
                if (e.key.length === 1) {
                  keyName = e.key.toUpperCase();
                } else {
                  keyName = e.key;
                }
                console.log("快捷键记录:", {
                  key: keyName,
                  ctrlKey: e.ctrlKey,
                  shiftKey: e.shiftKey,
                  altKey: e.altKey,
                  metaKey: e.metaKey,
                  code: e.code
                });
                newSettings.value = {
                  ctrlKey: e.ctrlKey,
                  shiftKey: e.shiftKey,
                  altKey: e.altKey,
                  metaKey: e.metaKey,
                  key: keyName
                };
                hasNewKeyPress.value = true;
                isResetMode.value = false;
              };
              const handleSave = () => {
                if (hasNewKeyPress.value) {
                  if (isResetMode.value) {
                    emit2("reset");
                    showNotification("批量染色快捷键已重置为默认！");
                  } else {
                    emit2("save", newSettings.value);
                    showNotification("批量染色快捷键设置已保存！");
                  }
                  formData.value = { ...newSettings.value };
                  hasNewKeyPress.value = false;
                  isResetMode.value = false;
                }
              };
              const handleReset = () => {
                newSettings.value = { ...props.defaultSettings };
                hasNewKeyPress.value = true;
                isResetMode.value = true;
                showNotification("已重置为默认快捷键，点击保存应用设置！");
              };
              watch(() => props.currentSettings, (currentSettings) => {
                formData.value = { ...currentSettings };
                if (!hasNewKeyPress.value) {
                  newSettings.value = { ...currentSettings };
                }
                isResetMode.value = false;
              }, { immediate: true, deep: true });
              watch([() => props.visible, () => props.isActive], ([isVisible, isActive]) => {
                console.log("对话框状态变化:", { isVisible, isActive });
                if (isVisible && isActive) {
                  console.log("添加键盘监听器");
                  document.addEventListener("keydown", handleKeyDown, true);
                } else {
                  console.log("移除键盘监听器");
                  document.removeEventListener("keydown", handleKeyDown, true);
                  if (!isVisible) {
                    hasNewKeyPress.value = false;
                    isResetMode.value = false;
                  }
                }
              }, { immediate: true });
              onUnmounted(() => {
                document.removeEventListener("keydown", handleKeyDown, true);
              });
              __expose({
                save: handleSave,
                reset: handleReset,
                hasNewKeyPress,
                getFormData: () => hasNewKeyPress.value ? { ...newSettings.value } : { ...formData.value }
              });
              return (_ctx, _cache) => {
                const _component_el_input = ElInput;
                const _component_el_form_item = ElFormItem;
                const _component_el_alert = ElAlert;
                const _component_el_form = ElForm;
                return openBlock(), createElementBlock("div", _hoisted_1$2, [
                  _cache[1] || (_cache[1] = createBaseVNode("div", { class: "border-b pb-4" }, [
                    createBaseVNode("h3", { class: "text-lg font-semibold text-gray-900 mb-2" }, "批量染色快捷键设置"),
                    createBaseVNode("p", { class: "text-sm text-gray-600" }, "按下快捷键，对当前页面上所有符合规则的链接进行染色")
                  ], -1)),
                  createVNode(_component_el_form, {
                    model: formData.value,
                    "label-width": "120px",
                    class: "space-y-6"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_form_item, { label: "当前快捷键" }, {
                        default: withCtx(() => [
                          createVNode(_component_el_input, {
                            modelValue: currentShortcutDisplay.value,
                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => currentShortcutDisplay.value = $event),
                            readonly: "",
                            size: "large",
                            class: "font-mono"
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_form_item, null, {
                        default: withCtx(() => [
                          createVNode(_component_el_alert, {
                            title: hintText.value,
                            type: hasNewKeyPress.value ? "success" : "info",
                            "show-icon": "",
                            closable: false
                          }, null, 8, ["title", "type"])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["model"])
                ]);
              };
            }
          });
          const defaultSyncSettings = {
            enabled: false,
            githubToken: "",
            gistId: "",
            lastSyncTime: 0
          };
          function getSyncSettings() {
            const storedSettings = GM_getValue("sync_settings", {});
            return {
              ...defaultSyncSettings,
              ...storedSettings,
              // 确保关键参数不为空，如果存储中为空则使用默认值
              githubToken: storedSettings.githubToken || defaultSyncSettings.githubToken,
              gistId: storedSettings.gistId || defaultSyncSettings.gistId
            };
          }
          function saveSyncSettings(settings) {
            GM_setValue("sync_settings", settings);
          }
          async function validateGitHubToken(token) {
            try {
              const response = await fetch("https://api.github.com/user", {
                headers: {
                  Authorization: `token ${token}`,
                  Accept: "application/vnd.github.v3+json"
                }
              });
              return response.ok;
            } catch (error) {
              console.warn("验证 GitHub 令牌失败:", error);
              return false;
            }
          }
          async function updateGist(token, gistId, data) {
            try {
              const gistInfo = await fetch(`https://api.github.com/gists/${gistId}`, {
                headers: {
                  Authorization: `token ${token}`,
                  Accept: "application/vnd.github.v3+json"
                }
              });
              if (!gistInfo.ok) {
                throw new Error(`获取 Gist 信息失败: ${gistInfo.status}`);
              }
              const gistData = await gistInfo.json();
              const fileName = Object.keys(gistData.files)[0];
              const response = await fetch(`https://api.github.com/gists/${gistId}`, {
                method: "PATCH",
                headers: {
                  "Authorization": `token ${token}`,
                  "Content-Type": "application/json",
                  "Accept": "application/vnd.github.v3+json"
                },
                body: JSON.stringify({
                  files: {
                    [fileName]: {
                      content: JSON.stringify(data, null, 2)
                    }
                  }
                })
              });
              if (!response.ok) {
                throw new Error(`更新 Gist 失败: ${response.status}`);
              }
            } catch (error) {
              console.warn("更新 Gist 失败:", error);
              throw error;
            }
          }
          async function getGist(token, gistId) {
            try {
              const response = await fetch(`https://api.github.com/gists/${gistId}`, {
                headers: {
                  Authorization: `token ${token}`,
                  Accept: "application/vnd.github.v3+json"
                }
              });
              if (response.ok) {
                const result = await response.json();
                const fileName = Object.keys(result.files)[0];
                const file = result.files[fileName];
                let contentText = "";
                if (file.truncated) {
                  const rawResp = await fetch(file.raw_url);
                  if (!rawResp.ok) {
                    throw new Error(`获取 Gist 原始内容失败: ${rawResp.status}`);
                  }
                  contentText = await rawResp.text();
                } else {
                  contentText = file.content;
                }
                try {
                  return contentText ? JSON.parse(contentText) : {};
                } catch (e) {
                  console.warn("解析 Gist 内容失败:", e);
                  return {};
                }
              } else {
                throw new Error(`获取 Gist 失败: ${response.status}`);
              }
            } catch (error) {
              console.warn("获取 Gist 失败:", error);
              throw error;
            }
          }
          async function uploadToCloud(data) {
            const syncSettings = getSyncSettings();
            const { githubToken, gistId } = syncSettings;
            if (!githubToken) {
              throw new Error("GitHub 令牌未设置");
            }
            if (!gistId) {
              throw new Error("Gist ID 未设置，请先创建 Gist 并在设置中填入 ID");
            }
            await updateGist(githubToken, gistId, data);
          }
          async function downloadFromCloud() {
            const syncSettings = getSyncSettings();
            const { githubToken, gistId } = syncSettings;
            if (!githubToken || !gistId) {
              return {};
            }
            return await getGist(githubToken, gistId);
          }
          function mergeVisitedLinks(localLinks, cloudLinks) {
            const merged = { ...localLinks };
            Object.keys(cloudLinks).forEach((url) => {
              if (!merged[url] || cloudLinks[url] > merged[url]) {
                merged[url] = cloudLinks[url];
              }
            });
            return merged;
          }
          function hasDataChanged(oldData, newData) {
            return JSON.stringify(oldData) !== JSON.stringify(newData);
          }
          async function syncOnStartup() {
            try {
              console.log("开始同步数据...");
              const localLinks = GM_getValue("visitedLinks", {});
              const cloudLinks = await downloadFromCloud();
              const mergedLinks = mergeVisitedLinks(localLinks, cloudLinks);
              GM_setValue("visitedLinks", mergedLinks);
              const localChanged = hasDataChanged(localLinks, mergedLinks);
              const cloudChanged = hasDataChanged(cloudLinks, mergedLinks);
              if (localChanged || cloudChanged) {
                await uploadToCloud(mergedLinks);
                console.log("数据已同步并上传到云端");
              } else {
                console.log("数据已同步，无需上传");
              }
              const syncSettings = getSyncSettings();
              syncSettings.lastSyncTime = Date.now();
              saveSyncSettings(syncSettings);
            } catch (error) {
              console.warn("同步失败，使用本地数据:", error.message);
              throw error;
            }
          }
          const _hoisted_1$1 = { class: "space-y-6" };
          const _hoisted_2$1 = { class: "space-y-4" };
          const _hoisted_3$1 = { class: "flex items-center justify-between" };
          const _hoisted_4$1 = { class: "text-sm space-y-2" };
          const _hoisted_5$1 = { class: "flex justify-between" };
          const _hoisted_6$1 = { class: "text-gray-900" };
          const _hoisted_7 = { class: "flex justify-between" };
          const _hoisted_8 = { class: "text-gray-900" };
          const _hoisted_9 = { class: "flex justify-center" };
          const _sfc_main$2 = /* @__PURE__ */ defineComponent({
            __name: "SyncSettings",
            props: {
              currentSettings: {}
            },
            emits: ["change"],
            setup(__props, { expose: __expose, emit: __emit }) {
              const props = __props;
              const emit2 = __emit;
              const formData = ref({
                enabled: props.currentSettings.enabled,
                githubToken: props.currentSettings.githubToken,
                gistId: props.currentSettings.gistId,
                lastSyncTime: props.currentSettings.lastSyncTime
              });
              const testingConnection = ref(false);
              const lastSyncTimeFormatted = computed(() => {
                if (!formData.value.lastSyncTime) {
                  return "从未同步";
                }
                return new Date(formData.value.lastSyncTime).toLocaleString();
              });
              const hasChanges = computed(() => {
                return formData.value.enabled !== props.currentSettings.enabled || formData.value.githubToken !== props.currentSettings.githubToken || formData.value.gistId !== props.currentSettings.gistId;
              });
              const handleEnabledChange = () => {
                emit2("change");
              };
              const handleTokenChange = () => {
                emit2("change");
              };
              const handleGistIdChange = () => {
                emit2("change");
              };
              const testConnection = async () => {
                if (!formData.value.githubToken) {
                  showNotification("请输入 GitHub 令牌");
                  return;
                }
                testingConnection.value = true;
                try {
                  const isValid = await validateGitHubToken(formData.value.githubToken);
                  if (isValid) {
                    showNotification("连接成功！", "success");
                  } else {
                    showNotification("连接失败，请检查令牌是否正确", "error");
                  }
                } catch (error) {
                  showNotification("连接失败: " + error.message, "error");
                } finally {
                  testingConnection.value = false;
                }
              };
              const getFormData = () => {
                return { ...formData.value };
              };
              const reset = () => {
                const defaultSettings = getSyncSettings();
                formData.value = {
                  enabled: defaultSettings.enabled,
                  githubToken: defaultSettings.githubToken,
                  gistId: defaultSettings.gistId,
                  lastSyncTime: defaultSettings.lastSyncTime
                };
                emit2("change");
              };
              __expose({
                hasChanges,
                getFormData,
                reset
              });
              watch(
                () => props.currentSettings,
                (newSettings) => {
                  formData.value = {
                    enabled: newSettings.enabled,
                    githubToken: newSettings.githubToken,
                    gistId: newSettings.gistId,
                    lastSyncTime: newSettings.lastSyncTime
                  };
                },
                { deep: true }
              );
              return (_ctx, _cache) => {
                const _component_el_switch = ElSwitch;
                const _component_el_input = ElInput;
                const _component_el_card = ElCard;
                const _component_el_button = ElButton;
                return openBlock(), createElementBlock("div", _hoisted_1$1, [
                  _cache[13] || (_cache[13] = createBaseVNode("div", { class: "border-b pb-4" }, [
                    createBaseVNode("h3", { class: "text-lg font-semibold text-gray-900 mb-2" }, "数据同步设置"),
                    createBaseVNode("p", { class: "text-sm text-gray-600" }, "通过 GitHub Gist 同步已访问链接数据，实现多设备同步")
                  ], -1)),
                  createBaseVNode("div", _hoisted_2$1, [
                    createBaseVNode("div", _hoisted_3$1, [
                      _cache[3] || (_cache[3] = createBaseVNode("div", null, [
                        createBaseVNode("label", { class: "text-sm font-medium text-gray-900" }, "启用数据同步"),
                        createBaseVNode("p", { class: "text-sm text-gray-500" }, "开启后将通过 GitHub Gist 同步数据")
                      ], -1)),
                      createVNode(_component_el_switch, {
                        modelValue: formData.value.enabled,
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => formData.value.enabled = $event),
                        onChange: handleEnabledChange
                      }, null, 8, ["modelValue"])
                    ]),
                    createBaseVNode("div", null, [
                      _cache[4] || (_cache[4] = createBaseVNode("label", { class: "block text-sm font-medium text-gray-900 mb-2" }, " GitHub 个人访问令牌 ", -1)),
                      createVNode(_component_el_input, {
                        modelValue: formData.value.githubToken,
                        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => formData.value.githubToken = $event),
                        type: "password",
                        placeholder: "请输入 GitHub Personal Access Token",
                        "show-password": "",
                        disabled: !formData.value.enabled,
                        onInput: handleTokenChange
                      }, null, 8, ["modelValue", "disabled"]),
                      _cache[5] || (_cache[5] = createBaseVNode("p", { class: "text-xs text-gray-500 mt-1" }, ' 需要创建具有 "gist" 权限的个人访问令牌 ', -1))
                    ]),
                    createBaseVNode("div", null, [
                      _cache[6] || (_cache[6] = createBaseVNode("label", { class: "block text-sm font-medium text-gray-900 mb-2" }, " Gist ID ", -1)),
                      createVNode(_component_el_input, {
                        modelValue: formData.value.gistId,
                        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => formData.value.gistId = $event),
                        placeholder: "请输入现有 Gist 的 ID",
                        disabled: !formData.value.enabled,
                        onInput: handleGistIdChange
                      }, null, 8, ["modelValue", "disabled"]),
                      _cache[7] || (_cache[7] = createBaseVNode("p", { class: "text-xs text-gray-500 mt-1" }, " 手动创建一个 Gist，然后输入其 ID ", -1))
                    ]),
                    createVNode(_component_el_card, {
                      class: "bg-blue-50",
                      shadow: "never"
                    }, {
                      header: withCtx(() => _cache[8] || (_cache[8] = [
                        createBaseVNode("span", { class: "text-sm font-medium text-blue-800" }, "设置步骤", -1)
                      ])),
                      default: withCtx(() => [
                        _cache[9] || (_cache[9] = createBaseVNode("ol", { class: "text-xs text-blue-700 space-y-1 list-decimal list-inside" }, [
                          createBaseVNode("li", null, '到 GitHub > Settings > Developer settings > Personal access tokens > Tokens (classic) 创建令牌，权限选择 "gist"'),
                          createBaseVNode("li", null, "手动创建一个 Gist（任意文件名和内容），复制 URL 中的 ID 部分"),
                          createBaseVNode("li", null, "将令牌和 Gist ID 填入上方输入框")
                        ], -1))
                      ]),
                      _: 1,
                      __: [9]
                    }),
                    createVNode(_component_el_card, { shadow: "never" }, {
                      header: withCtx(() => _cache[10] || (_cache[10] = [
                        createBaseVNode("span", { class: "text-sm font-medium text-gray-800" }, "同步状态", -1)
                      ])),
                      default: withCtx(() => [
                        createBaseVNode("div", _hoisted_4$1, [
                          createBaseVNode("div", _hoisted_5$1, [
                            _cache[11] || (_cache[11] = createBaseVNode("span", { class: "text-gray-600" }, "当前 Gist ID:", -1)),
                            createBaseVNode("span", _hoisted_6$1, toDisplayString(formData.value.gistId || "未设置"), 1)
                          ]),
                          createBaseVNode("div", _hoisted_7, [
                            _cache[12] || (_cache[12] = createBaseVNode("span", { class: "text-gray-600" }, "最后同步时间:", -1)),
                            createBaseVNode("span", _hoisted_8, toDisplayString(lastSyncTimeFormatted.value), 1)
                          ])
                        ])
                      ]),
                      _: 1
                    }),
                    createBaseVNode("div", _hoisted_9, [
                      createVNode(_component_el_button, {
                        type: "primary",
                        loading: testingConnection.value,
                        disabled: !formData.value.enabled || !formData.value.githubToken,
                        onClick: testConnection
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(testingConnection.value ? "测试中..." : "测试连接"), 1)
                        ]),
                        _: 1
                      }, 8, ["loading", "disabled"])
                    ])
                  ])
                ]);
              };
            }
          });
          const _hoisted_1 = { class: "h-[400px] overflow-y-auto" };
          const _hoisted_2 = { class: "p-6 h-full overflow-y-auto" };
          const _hoisted_3 = { class: "p-6 h-full overflow-y-auto" };
          const _hoisted_4 = { class: "p-6 h-full overflow-y-auto" };
          const _hoisted_5 = { class: "p-6 h-full overflow-y-auto" };
          const _hoisted_6 = { class: "flex justify-end gap-3" };
          const _sfc_main$1 = /* @__PURE__ */ defineComponent({
            __name: "SettingsDialog",
            props: {
              modelValue: { type: Boolean },
              currentSettings: {},
              defaultSettings: {},
              currentGeneralSettings: {},
              defaultGeneralSettings: {},
              currentPresetStates: {},
              currentSyncSettings: {},
              isMac: { type: Boolean }
            },
            emits: ["update:modelValue", "save", "reset", "generalSave", "generalReset", "presetSave", "presetReset", "syncSave", "syncReset"],
            setup(__props, { emit: __emit }) {
              const props = __props;
              const emit2 = __emit;
              const visible = computed({
                get: () => props.modelValue,
                set: (value) => emit2("update:modelValue", value)
              });
              const activeTab = ref("general");
              const generalSettingsRef = ref();
              const shortcutSettingsRef = ref();
              const presetSettingsRef = ref();
              const syncSettingsRef = ref();
              const canSave = computed(() => {
                if (activeTab.value === "shortcut") {
                  return shortcutSettingsRef.value?.hasNewKeyPress ?? false;
                } else if (activeTab.value === "general") {
                  return generalSettingsRef.value?.hasChanges ?? false;
                } else if (activeTab.value === "presets") {
                  return presetSettingsRef.value?.hasChanges ?? false;
                } else if (activeTab.value === "sync") {
                  return syncSettingsRef.value?.hasChanges ?? false;
                }
                return false;
              });
              const handleSave = () => {
                if (activeTab.value === "general") {
                  const generalData = generalSettingsRef.value?.getFormData();
                  if (generalData) {
                    emit2("generalSave", generalData);
                  }
                } else if (activeTab.value === "shortcut") {
                  shortcutSettingsRef.value?.save();
                } else if (activeTab.value === "presets") {
                  const presetData = presetSettingsRef.value?.getFormData();
                  if (presetData) {
                    emit2("presetSave", presetData);
                    presetSettingsRef.value?.save();
                  }
                } else if (activeTab.value === "sync") {
                  const syncData = syncSettingsRef.value?.getFormData();
                  if (syncData) {
                    emit2("syncSave", syncData);
                  }
                }
              };
              const handleSyncChange = () => {
              };
              const handleReset = () => {
                if (activeTab.value === "general") {
                  generalSettingsRef.value?.reset();
                } else if (activeTab.value === "shortcut") {
                  shortcutSettingsRef.value?.reset();
                } else if (activeTab.value === "presets") {
                  presetSettingsRef.value?.reset();
                  emit2("presetReset");
                } else if (activeTab.value === "sync") {
                  syncSettingsRef.value?.reset();
                  emit2("syncReset");
                }
              };
              const handleClosed = () => {
                activeTab.value = "general";
              };
              return (_ctx, _cache) => {
                const _component_el_tab_pane = ElTabPane;
                const _component_el_tabs = ElTabs;
                const _component_el_button = ElButton;
                const _component_el_dialog = ElDialog;
                return openBlock(), createBlock(_component_el_dialog, {
                  modelValue: visible.value,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => visible.value = $event),
                  width: "900px",
                  "close-on-click-modal": true,
                  "close-on-press-escape": false,
                  "body-style": { padding: "0" },
                  onClosed: handleClosed
                }, {
                  header: withCtx(() => _cache[2] || (_cache[2] = [
                    createBaseVNode("span", { class: "text-lg font-semibold" }, "设置", -1)
                  ])),
                  footer: withCtx(() => [
                    createBaseVNode("div", _hoisted_6, [
                      createVNode(_component_el_button, {
                        onClick: handleReset,
                        size: "large",
                        plain: ""
                      }, {
                        default: withCtx(() => _cache[3] || (_cache[3] = [
                          createTextVNode(" 重置为默认 ")
                        ])),
                        _: 1,
                        __: [3]
                      }),
                      createVNode(_component_el_button, {
                        type: "primary",
                        size: "large",
                        onClick: handleSave,
                        disabled: !canSave.value
                      }, {
                        default: withCtx(() => _cache[4] || (_cache[4] = [
                          createTextVNode(" 保存设置 ")
                        ])),
                        _: 1,
                        __: [4]
                      }, 8, ["disabled"])
                    ])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_1, [
                      createVNode(_component_el_tabs, {
                        modelValue: activeTab.value,
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => activeTab.value = $event),
                        "tab-position": "left",
                        class: "h-full",
                        stretch: ""
                      }, {
                        default: withCtx(() => [
                          createVNode(_component_el_tab_pane, {
                            label: "常规设置",
                            name: "general",
                            class: "h-full"
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("div", _hoisted_2, [
                                createVNode(_sfc_main$5, {
                                  "current-settings": _ctx.currentGeneralSettings,
                                  "default-settings": _ctx.defaultGeneralSettings,
                                  ref_key: "generalSettingsRef",
                                  ref: generalSettingsRef
                                }, null, 8, ["current-settings", "default-settings"])
                              ])
                            ]),
                            _: 1
                          }),
                          createVNode(_component_el_tab_pane, {
                            label: "预设网站",
                            name: "presets",
                            class: "h-full"
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("div", _hoisted_3, [
                                createVNode(_sfc_main$4, {
                                  "current-preset-states": _ctx.currentPresetStates,
                                  ref_key: "presetSettingsRef",
                                  ref: presetSettingsRef
                                }, null, 8, ["current-preset-states"])
                              ])
                            ]),
                            _: 1
                          }),
                          createVNode(_component_el_tab_pane, {
                            label: "批量染色快捷键",
                            name: "shortcut",
                            class: "h-full"
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("div", _hoisted_4, [
                                createVNode(_sfc_main$3, {
                                  "current-settings": _ctx.currentSettings,
                                  "default-settings": _ctx.defaultSettings,
                                  "is-mac": _ctx.isMac,
                                  visible: visible.value,
                                  "is-active": activeTab.value === "shortcut",
                                  ref_key: "shortcutSettingsRef",
                                  ref: shortcutSettingsRef
                                }, null, 8, ["current-settings", "default-settings", "is-mac", "visible", "is-active"])
                              ])
                            ]),
                            _: 1
                          }),
                          createVNode(_component_el_tab_pane, {
                            label: "数据同步",
                            name: "sync",
                            class: "h-full"
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("div", _hoisted_5, [
                                createVNode(_sfc_main$2, {
                                  "current-settings": _ctx.currentSyncSettings,
                                  ref_key: "syncSettingsRef",
                                  ref: syncSettingsRef,
                                  onChange: handleSyncChange
                                }, null, 8, ["current-settings"])
                              ])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["modelValue"])
                    ])
                  ]),
                  _: 1
                }, 8, ["modelValue"]);
              };
            }
          });
          const _sfc_main = /* @__PURE__ */ defineComponent({
            __name: "App",
            setup(__props) {
              const dialogData = ref(null);
              const handleShowDialog = (event) => {
                dialogData.value = { ...event.payload, visible: true };
              };
              const handleSettingsSave = (settings) => {
                eventBus.emit("settings:save", {
                  type: "batch-key",
                  settings
                });
              };
              const handleSettingsReset = () => {
                eventBus.emit("settings:reset", {
                  type: "batch-key"
                });
              };
              const handleGeneralSave = (settings) => {
                eventBus.emit("settings:save", {
                  type: "general",
                  settings
                });
              };
              const handleGeneralReset = () => {
                eventBus.emit("settings:reset", {
                  type: "general"
                });
              };
              const handlePresetSave = (states) => {
                eventBus.emit("settings:save", {
                  type: "preset",
                  states
                });
              };
              const handlePresetReset = () => {
                eventBus.emit("settings:reset", {
                  type: "preset"
                });
              };
              const handleSyncSave = (settings) => {
                eventBus.emit("settings:save", {
                  type: "sync",
                  settings
                });
              };
              const handleSyncReset = () => {
                eventBus.emit("settings:reset", {
                  type: "sync"
                });
              };
              onMounted(() => {
                eventBus.on("dialog:show-settings", handleShowDialog);
              });
              onUnmounted(() => {
                eventBus.off("dialog:show-settings", handleShowDialog);
              });
              return (_ctx, _cache) => {
                return dialogData.value ? (openBlock(), createBlock(_sfc_main$1, {
                  key: 0,
                  modelValue: dialogData.value.visible,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => dialogData.value.visible = $event),
                  "current-settings": dialogData.value.currentSettings,
                  "default-settings": dialogData.value.defaultSettings,
                  "current-general-settings": dialogData.value.currentGeneralSettings,
                  "default-general-settings": dialogData.value.defaultGeneralSettings,
                  "current-preset-states": dialogData.value.currentPresetStates,
                  "current-sync-settings": dialogData.value.currentSyncSettings,
                  "is-mac": dialogData.value.isMac,
                  onSave: handleSettingsSave,
                  onReset: handleSettingsReset,
                  onGeneralSave: handleGeneralSave,
                  onGeneralReset: handleGeneralReset,
                  onPresetSave: handlePresetSave,
                  onPresetReset: handlePresetReset,
                  onSyncSave: handleSyncSave,
                  onSyncReset: handleSyncReset
                }, null, 8, ["modelValue", "current-settings", "default-settings", "current-general-settings", "default-general-settings", "current-preset-states", "current-sync-settings", "is-mac"])) : createCommentVNode("", true);
              };
            }
          });
          const isMac = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
          const defaultBatchKeySettings = {
            ctrlKey: !isMac,
            // macOS 下为 false，Windows 下为 true
            shiftKey: true,
            altKey: false,
            metaKey: isMac,
            // macOS 下为 true，Windows 下为 false
            key: "V"
          };
          function getBaseUrl(url) {
            const domain = new URL(url).hostname;
            if (domain === "www.v2ex.com") return url.split("?")[0].split("#")[0];
            if (domain === "linux.do") return url.replace(/(\/\d+)\/\d+$/, "$1");
            if (domain === "www.bilibili.com") return url.split("?")[0];
            if (domain === "tieba.baidu.com") return url.split("?")[0];
            if (domain === "www.douban.com") return url.split("?")[0];
            if (domain === "ngabbs.com") return url.split("&")[0];
            if (domain === "bbs.nga.cn") return url.split("&")[0];
            if (domain === "nga.178.com") return url.split("&")[0];
            if (/^www\.(south|north|blue|white|level|snow|spring|summer)-plus\.net$/.test(domain)) {
              let processedUrl = url;
              processedUrl = processedUrl.replace(/#a$/, "");
              processedUrl = processedUrl.replace(/-fpage-\d+/, "");
              processedUrl = processedUrl.replace(/-page-(\d+|[ea])(\.html)?$/, "$2");
              return processedUrl;
            }
            return url;
          }
          function logStorageInfo(visitedLinks) {
            const serializedData = JSON.stringify(visitedLinks);
            const sizeInBytes = new TextEncoder().encode(serializedData).length;
            const sizeInKB = (sizeInBytes / 1024).toFixed(2);
            const sizeInMB = (sizeInBytes / (1024 * 1024)).toFixed(2);
            let sizeText;
            if (sizeInBytes < 1024) {
              sizeText = `${sizeInBytes} bytes`;
            } else if (sizeInBytes < 1024 * 1024) {
              sizeText = `${sizeInKB} KB`;
            } else {
              sizeText = `${sizeInMB} MB`;
            }
            const itemCount = Object.keys(visitedLinks).length;
            console.log(`visitedLinks storage size: ${itemCount} items, ${sizeText}`);
          }
          function startColorVisitedScript() {
            console.log("Color Visited Script has started!");
            let batchKeySettings = _GM_getValue("batch_shortcut_settings", defaultBatchKeySettings);
            let presetStates = (() => {
              const defaultStates = {};
              Object.keys(PRESET_RULES).forEach((siteName) => {
                defaultStates[siteName] = true;
              });
              return _GM_getValue("preset_states", defaultStates);
            })();
            const getGeneralSettings = () => ({
              color: _GM_getValue("color_setting", config.color),
              expirationTime: _GM_getValue("expiration_time_setting", config.expirationTime),
              debug: _GM_getValue("debug_setting", config.debug)
            });
            const defaultGeneralSettings = {
              color: config.color,
              expirationTime: config.expirationTime,
              debug: config.debug
            };
            let currentGeneralSettings = getGeneralSettings();
            let batchKeyHandler = null;
            let syncSettings = getSyncSettings();
            function startScript() {
              config.color = currentGeneralSettings.color;
              config.expirationTime = currentGeneralSettings.expirationTime;
              config.debug = currentGeneralSettings.debug;
              updateMenu();
              if (syncSettings.enabled) {
                syncOnStartup().catch((error) => {
                  console.warn("后台同步失败:", error.message);
                  showNotification(`同步失败: ${error.message}`);
                });
              }
              if (config.presets === "all") {
                config.presets = Object.keys(PRESET_RULES);
              }
              window.addEventListener("preset-states-updated", (event) => {
                const customEvent = event;
                const { presetStates: newPresetStates } = customEvent.detail;
                presetStates = newPresetStates;
                _GM_setValue("preset_states", presetStates);
                setupPage();
              });
              setupPage();
              onUrlChange(() => {
                setupPage();
              });
            }
            function setupPage() {
              if (config.debug) console.log("color-visited script initialized on", window.location.href);
              removeScript();
              if (isPageActive()) {
                injectCustomStyles();
                activateLinkFeatures();
                setupBatchKeyListener();
              } else {
                if (config.debug) console.log("Script is not active on this page:", window.location.href);
              }
            }
            function getEnabledPresets() {
              const allPresets = config.presets === "all" ? Object.keys(PRESET_RULES) : config.presets;
              return allPresets.filter((preset) => presetStates[preset] !== false);
            }
            function isPageActive() {
              const currentUrl = window.location.href;
              const enabledPresets = getEnabledPresets();
              return enabledPresets.some((preset) => {
                const presetRule = PRESET_RULES[preset];
                return presetRule?.pages.some((pattern) => pattern.test(currentUrl)) ?? false;
              });
            }
            function onUrlChange(callback) {
              let oldHref = location.href;
              const body = document.querySelector("body");
              const observer = new MutationObserver(() => {
                if (oldHref !== location.href) {
                  oldHref = location.href;
                  if (config.debug) console.log("URL changed:", oldHref, "->", location.href);
                  callback();
                }
              });
              observer.observe(body, { childList: true, subtree: true });
            }
            function getCurrentPagePreset() {
              const currentUrl = window.location.href;
              const enabledPresets = getEnabledPresets();
              for (const preset of enabledPresets) {
                const presetRule = PRESET_RULES[preset];
                if (presetRule?.pages.some((pattern) => pattern.test(currentUrl))) {
                  return preset;
                }
              }
              return null;
            }
            function shouldColorLink(url) {
              const currentPreset = getCurrentPagePreset();
              if (!currentPreset) return false;
              const presetRule = PRESET_RULES[currentPreset];
              return presetRule?.patterns.some((pattern) => pattern.test(url)) ?? false;
            }
            function updateMenu() {
              _GM_registerMenuCommand("设置", () => {
                showSettingsDialog(
                  batchKeySettings,
                  defaultBatchKeySettings,
                  currentGeneralSettings,
                  defaultGeneralSettings,
                  presetStates,
                  syncSettings,
                  isMac,
                  (newSettings) => {
                    batchKeySettings = newSettings;
                    _GM_setValue("batch_shortcut_settings", batchKeySettings);
                  },
                  () => {
                    batchKeySettings = { ...defaultBatchKeySettings };
                    _GM_setValue("batch_shortcut_settings", defaultBatchKeySettings);
                  },
                  (newGeneralSettings) => {
                    currentGeneralSettings = newGeneralSettings;
                    _GM_setValue("color_setting", newGeneralSettings.color);
                    _GM_setValue("expiration_time_setting", newGeneralSettings.expirationTime);
                    _GM_setValue("debug_setting", newGeneralSettings.debug);
                    config.color = newGeneralSettings.color;
                    config.expirationTime = newGeneralSettings.expirationTime;
                    config.debug = newGeneralSettings.debug;
                    setupPage();
                  },
                  () => {
                    currentGeneralSettings = { ...defaultGeneralSettings };
                    _GM_setValue("color_setting", defaultGeneralSettings.color);
                    _GM_setValue("expiration_time_setting", defaultGeneralSettings.expirationTime);
                    _GM_setValue("debug_setting", defaultGeneralSettings.debug);
                    config.color = defaultGeneralSettings.color;
                    config.expirationTime = defaultGeneralSettings.expirationTime;
                    config.debug = defaultGeneralSettings.debug;
                    setupPage();
                  },
                  (newPresetStates) => {
                    presetStates = newPresetStates;
                    _GM_setValue("preset_states", presetStates);
                    setupPage();
                  },
                  () => {
                    const defaultStates = {};
                    Object.keys(PRESET_RULES).forEach((key) => {
                      defaultStates[key] = true;
                    });
                    presetStates = defaultStates;
                    _GM_setValue("preset_states", presetStates);
                    setupPage();
                  },
                  (newSyncSettings) => {
                    syncSettings = newSyncSettings;
                    saveSyncSettings(syncSettings);
                    updateMenu();
                  },
                  () => {
                    syncSettings = { ...defaultSyncSettings };
                    saveSyncSettings(syncSettings);
                    updateMenu();
                  }
                );
              });
            }
            function removeScript() {
              removeCustomStyles();
              document.querySelectorAll("a.visited-link").forEach((link) => {
                link.classList.remove("visited-link");
              });
              if (batchKeyHandler) {
                document.removeEventListener("keydown", batchKeyHandler);
                batchKeyHandler = null;
              }
            }
            function deleteExpiredLinks() {
              const visitedLinks = _GM_getValue("visitedLinks", {});
              const now2 = (/* @__PURE__ */ new Date()).getTime();
              Object.keys(visitedLinks).forEach((url) => {
                if (now2 - visitedLinks[url] > config.expirationTime) {
                  delete visitedLinks[url];
                }
              });
              _GM_setValue("visitedLinks", visitedLinks);
            }
            function batchAddLinks() {
              const visitedLinks = _GM_getValue("visitedLinks", {});
              const now2 = (/* @__PURE__ */ new Date()).getTime();
              let addedCount = 0;
              document.querySelectorAll("a[href]").forEach((link) => {
                const inputUrl = getBaseUrl(link.href);
                if (shouldColorLink(inputUrl) && !Object.hasOwn(visitedLinks, inputUrl)) {
                  visitedLinks[inputUrl] = now2;
                  link.classList.add("visited-link");
                  addedCount++;
                }
              });
              if (addedCount > 0) {
                _GM_setValue("visitedLinks", visitedLinks);
                showNotification(`已批量添加 ${addedCount} 个链接到已访问记录`);
              } else {
                showNotification("没有找到新的符合规则的链接可添加");
              }
            }
            function setupBatchKeyListener() {
              if (batchKeyHandler) {
                document.removeEventListener("keydown", batchKeyHandler);
              }
              batchKeyHandler = function(event) {
                if (event.ctrlKey === batchKeySettings.ctrlKey && event.shiftKey === batchKeySettings.shiftKey && event.altKey === batchKeySettings.altKey && event.metaKey === batchKeySettings.metaKey && event.key.toUpperCase() === batchKeySettings.key) {
                  event.preventDefault();
                  batchAddLinks();
                }
              };
              document.addEventListener("keydown", batchKeyHandler);
            }
            function updateLinkStatus(link, visitedLinks) {
              const inputUrl = getBaseUrl(link.href);
              if (!shouldColorLink(inputUrl)) return;
              if (Object.hasOwn(visitedLinks, inputUrl)) {
                link.classList.add("visited-link");
                if (config.debug) console.log(`${inputUrl} class added`);
              }
            }
            function updateAllLinksStatus(visitedLinks) {
              document.querySelectorAll("a[href]").forEach((link) => {
                updateLinkStatus(link, visitedLinks);
              });
            }
            function setupDOMObserver(visitedLinks) {
              const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                  mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                      node.querySelectorAll("a[href]").forEach((link) => {
                        updateLinkStatus(link, visitedLinks);
                      });
                    }
                  });
                });
              });
              observer.observe(document.body, { childList: true, subtree: true });
              return observer;
            }
            function createLinkClickHandler(visitedLinks) {
              return function handleLinkClick(event) {
                const link = event.target.closest("a[href]");
                if (!link) return;
                const inputUrl = getBaseUrl(link.href);
                if (!shouldColorLink(inputUrl)) return;
                if (!Object.hasOwn(visitedLinks, inputUrl)) {
                  visitedLinks[inputUrl] = (/* @__PURE__ */ new Date()).getTime();
                  _GM_setValue("visitedLinks", visitedLinks);
                  if (config.debug) console.log(`${inputUrl} saved`);
                  link.classList.add("visited-link");
                  if (config.debug) console.log(`${inputUrl} class added`);
                }
              };
            }
            function setupLinkEventListeners(visitedLinks) {
              const handleLinkClick = createLinkClickHandler(visitedLinks);
              document.addEventListener("click", handleLinkClick, true);
              document.addEventListener("auxclick", handleLinkClick, true);
              return handleLinkClick;
            }
            function activateLinkFeatures() {
              deleteExpiredLinks();
              const visitedLinks = _GM_getValue("visitedLinks", {});
              logStorageInfo(visitedLinks);
              updateAllLinksStatus(visitedLinks);
              setupDOMObserver(visitedLinks);
              setupLinkEventListeners(visitedLinks);
            }
            startScript();
          }
          startColorVisitedScript();
          const createIsolatedApp = () => {
            const container = document.createElement("div");
            container.id = "color-visited-root";
            const shadowRoot = container.attachShadow({ mode: "open" });
            const appMountPoint = document.createElement("div");
            shadowRoot.appendChild(appMountPoint);
            const injectStyles = async () => {
              try {
                const elementPlusLink = document.createElement("link");
                elementPlusLink.rel = "stylesheet";
                elementPlusLink.href = "https://unpkg.com/element-plus/dist/index.css";
                shadowRoot.appendChild(elementPlusLink);
                const tailwindStyles = document.createElement("style");
                const tailwindModule = await __vitePreload(() => module.import('./tailwind-BtSByzuY-CC9yrMzt.js'), true ? void 0 : void 0);
                tailwindStyles.textContent = tailwindModule.default;
                shadowRoot.appendChild(tailwindStyles);
                const customStyles = document.createElement("style");
                const stylesModule = await __vitePreload(() => module.import('./index-Dd27cyou-rv-KGBld.js'), true ? void 0 : void 0);
                customStyles.textContent = stylesModule.default;
                shadowRoot.appendChild(customStyles);
              } catch (error) {
                console.warn("Failed to inject styles:", error);
              }
            };
            injectStyles();
            const app = createApp(_sfc_main);
            app.mount(appMountPoint);
            document.body.appendChild(container);
            return container;
          };
          createIsolatedApp();
        }
      });
      require_main_001();

    })
  };
}));

System.register("./tailwind-BtSByzuY-CC9yrMzt.js", [], (function (exports, module) {
  'use strict';
  return {
    execute: (function () {

      const tailwind = exports("default", '/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-y-reverse:0;--tw-space-x-reverse:0;--tw-border-style:solid;--tw-gradient-position:initial;--tw-gradient-from:#0000;--tw-gradient-via:#0000;--tw-gradient-to:#0000;--tw-gradient-stops:initial;--tw-gradient-via-stops:initial;--tw-gradient-from-position:0%;--tw-gradient-via-position:50%;--tw-gradient-to-position:100%;--tw-font-weight:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-duration:initial;--tw-ease:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-600:oklch(57.7% .245 27.325);--color-green-100:oklch(96.2% .044 156.743);--color-green-200:oklch(92.5% .084 155.995);--color-green-500:oklch(72.3% .219 149.579);--color-green-600:oklch(62.7% .194 149.214);--color-green-700:oklch(52.7% .154 150.069);--color-green-800:oklch(44.8% .119 151.328);--color-blue-50:oklch(97% .014 254.604);--color-blue-100:oklch(93.2% .032 255.585);--color-blue-200:oklch(88.2% .059 254.128);--color-blue-400:oklch(70.7% .165 254.624);--color-blue-500:oklch(62.3% .214 259.815);--color-blue-700:oklch(48.8% .243 264.376);--color-blue-800:oklch(42.4% .199 265.638);--color-purple-50:oklch(97.7% .014 308.299);--color-purple-100:oklch(94.6% .033 307.174);--color-purple-500:oklch(62.7% .265 303.9);--color-purple-600:oklch(55.8% .288 302.321);--color-purple-800:oklch(43.8% .218 303.724);--color-gray-50:oklch(98.5% .002 247.839);--color-gray-100:oklch(96.7% .003 264.542);--color-gray-200:oklch(92.8% .006 264.531);--color-gray-400:oklch(70.7% .022 261.325);--color-gray-500:oklch(55.1% .027 264.364);--color-gray-600:oklch(44.6% .03 256.802);--color-gray-700:oklch(37.3% .034 259.733);--color-gray-800:oklch(27.8% .033 256.848);--color-gray-900:oklch(21% .034 264.665);--color-white:#fff;--spacing:.25rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-xl:1.25rem;--text-xl--line-height:calc(1.75/1.25);--text-4xl:2.25rem;--text-4xl--line-height:calc(2.5/2.25);--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;--radius-md:.375rem;--radius-lg:.5rem;--radius-xl:.75rem;--ease-in:cubic-bezier(.4,0,1,1);--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}}@layer components;@layer utilities{.visible{visibility:visible}.absolute{position:absolute}.fixed{position:fixed}.static{position:static}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.mt-1{margin-top:calc(var(--spacing)*1)}.mt-2{margin-top:calc(var(--spacing)*2)}.mb-1{margin-bottom:calc(var(--spacing)*1)}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-3{margin-bottom:calc(var(--spacing)*3)}.mb-4{margin-bottom:calc(var(--spacing)*4)}.ml-4{margin-left:calc(var(--spacing)*4)}.ml-6{margin-left:calc(var(--spacing)*6)}.ml-8{margin-left:calc(var(--spacing)*8)}.ml-10{margin-left:calc(var(--spacing)*10)}.ml-14{margin-left:calc(var(--spacing)*14)}.block{display:block}.flex{display:flex}.grid{display:grid}.hidden{display:none}.inline{display:inline}.inline-flex{display:inline-flex}.table{display:table}.h-1{height:calc(var(--spacing)*1)}.h-1\\.5{height:calc(var(--spacing)*1.5)}.h-2{height:calc(var(--spacing)*2)}.h-3{height:calc(var(--spacing)*3)}.h-4{height:calc(var(--spacing)*4)}.h-10{height:calc(var(--spacing)*10)}.h-\\[400px\\]{height:400px}.h-full{height:100%}.max-h-32{max-height:calc(var(--spacing)*32)}.w-1{width:calc(var(--spacing)*1)}.w-1\\.5{width:calc(var(--spacing)*1.5)}.w-2{width:calc(var(--spacing)*2)}.w-3{width:calc(var(--spacing)*3)}.w-4{width:calc(var(--spacing)*4)}.w-10{width:calc(var(--spacing)*10)}.w-32{width:calc(var(--spacing)*32)}.flex-1{flex:1}.flex-shrink-0{flex-shrink:0}.rotate-90{rotate:90deg}.rotate-180{rotate:180deg}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.cursor-pointer{cursor:pointer}.resize{resize:both}.list-inside{list-style-position:inside}.list-decimal{list-style-type:decimal}.flex-col{flex-direction:column}.items-center{align-items:center}.items-start{align-items:flex-start}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.justify-end{justify-content:flex-end}.gap-2{gap:calc(var(--spacing)*2)}.gap-3{gap:calc(var(--spacing)*3)}:where(.space-y-1>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*1)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*1)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-2>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*2)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*2)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-3>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*3)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*3)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-4>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*4)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*4)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-6>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*6)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*6)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-x-2>:not(:last-child)){--tw-space-x-reverse:0;margin-inline-start:calc(calc(var(--spacing)*2)*var(--tw-space-x-reverse));margin-inline-end:calc(calc(var(--spacing)*2)*calc(1 - var(--tw-space-x-reverse)))}:where(.space-x-3>:not(:last-child)){--tw-space-x-reverse:0;margin-inline-start:calc(calc(var(--spacing)*3)*var(--tw-space-x-reverse));margin-inline-end:calc(calc(var(--spacing)*3)*calc(1 - var(--tw-space-x-reverse)))}.overflow-y-auto{overflow-y:auto}.rounded{border-radius:.25rem}.rounded-full{border-radius:3.40282e38px}.rounded-lg{border-radius:var(--radius-lg)}.rounded-md{border-radius:var(--radius-md)}.rounded-xl{border-radius:var(--radius-xl)}.rounded-b-xl{border-bottom-right-radius:var(--radius-xl);border-bottom-left-radius:var(--radius-xl)}.border{border-style:var(--tw-border-style);border-width:1px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-blue-200{border-color:var(--color-blue-200)}.border-gray-100{border-color:var(--color-gray-100)}.border-gray-200{border-color:var(--color-gray-200)}.bg-blue-50{background-color:var(--color-blue-50)}.bg-blue-400{background-color:var(--color-blue-400)}.bg-gray-50{background-color:var(--color-gray-50)}.bg-gray-50\\/50{background-color:#f9fafb80}@supports (color:color-mix(in lab,red,red)){.bg-gray-50\\/50{background-color:color-mix(in oklab,var(--color-gray-50)50%,transparent)}}.bg-gray-100{background-color:var(--color-gray-100)}.bg-gray-400{background-color:var(--color-gray-400)}.bg-green-100{background-color:var(--color-green-100)}.bg-green-500{background-color:var(--color-green-500)}.bg-purple-100{background-color:var(--color-purple-100)}.bg-purple-500{background-color:var(--color-purple-500)}.bg-white{background-color:var(--color-white)}.bg-gradient-to-br{--tw-gradient-position:to bottom right in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.bg-gradient-to-r{--tw-gradient-position:to right in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.from-blue-50{--tw-gradient-from:var(--color-blue-50);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-blue-500{--tw-gradient-from:var(--color-blue-500);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-purple-50{--tw-gradient-to:var(--color-purple-50);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-purple-600{--tw-gradient-to:var(--color-purple-600);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.fill-current{fill:currentColor}.p-2{padding:calc(var(--spacing)*2)}.p-3{padding:calc(var(--spacing)*3)}.p-4{padding:calc(var(--spacing)*4)}.p-5{padding:calc(var(--spacing)*5)}.p-6{padding:calc(var(--spacing)*6)}.p-10{padding:calc(var(--spacing)*10)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-3{padding-inline:calc(var(--spacing)*3)}.px-4{padding-inline:calc(var(--spacing)*4)}.px-5{padding-inline:calc(var(--spacing)*5)}.py-0{padding-block:calc(var(--spacing)*0)}.py-1{padding-block:calc(var(--spacing)*1)}.py-1\\.5{padding-block:calc(var(--spacing)*1.5)}.py-2{padding-block:calc(var(--spacing)*2)}.py-3{padding-block:calc(var(--spacing)*3)}.py-4{padding-block:calc(var(--spacing)*4)}.py-16{padding-block:calc(var(--spacing)*16)}.pt-3{padding-top:calc(var(--spacing)*3)}.pb-3{padding-bottom:calc(var(--spacing)*3)}.pb-4{padding-bottom:calc(var(--spacing)*4)}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:var(--font-mono)}.text-4xl{font-size:var(--text-4xl);line-height:var(--tw-leading,var(--text-4xl--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xl{font-size:var(--text-xl);line-height:var(--tw-leading,var(--text-xl--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.break-all{word-break:break-all}.text-blue-500{color:var(--color-blue-500)}.text-blue-700{color:var(--color-blue-700)}.text-blue-800{color:var(--color-blue-800)}.text-gray-400{color:var(--color-gray-400)}.text-gray-500{color:var(--color-gray-500)}.text-gray-600{color:var(--color-gray-600)}.text-gray-700{color:var(--color-gray-700)}.text-gray-800{color:var(--color-gray-800)}.text-gray-900{color:var(--color-gray-900)}.text-green-600{color:var(--color-green-600)}.text-green-700{color:var(--color-green-700)}.text-green-800{color:var(--color-green-800)}.text-purple-800{color:var(--color-purple-800)}.text-red-600{color:var(--color-red-600)}.text-white{color:var(--color-white)}.capitalize{text-transform:capitalize}.lowercase{text-transform:lowercase}.uppercase{text-transform:uppercase}.opacity-60{opacity:.6}.shadow,.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-2{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-blue-100{--tw-ring-color:var(--color-blue-100)}.blur{--tw-blur:blur(8px);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-colors{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-shadow{transition-property:box-shadow;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform{transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.duration-200{--tw-duration:.2s;transition-duration:.2s}.duration-300{--tw-duration:.3s;transition-duration:.3s}.ease-in{--tw-ease:var(--ease-in);transition-timing-function:var(--ease-in)}@media (hover:hover){.hover\\:bg-gray-100:hover{background-color:var(--color-gray-100)}.hover\\:bg-gray-200:hover{background-color:var(--color-gray-200)}.hover\\:bg-green-200:hover{background-color:var(--color-green-200)}.hover\\:shadow-md:hover{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}}}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-space-x-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-gradient-position{syntax:"*";inherits:false}@property --tw-gradient-from{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-via{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-to{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-stops{syntax:"*";inherits:false}@property --tw-gradient-via-stops{syntax:"*";inherits:false}@property --tw-gradient-from-position{syntax:"<length-percentage>";inherits:false;initial-value:0%}@property --tw-gradient-via-position{syntax:"<length-percentage>";inherits:false;initial-value:50%}@property --tw-gradient-to-position{syntax:"<length-percentage>";inherits:false;initial-value:100%}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-duration{syntax:"*";inherits:false}@property --tw-ease{syntax:"*";inherits:false}');

    })
  };
}));

System.register("./index-Dd27cyou-rv-KGBld.js", [], (function (exports, module) {
  'use strict';
  return {
    execute: (function () {

      const index = exports("default", ":host{all:initial;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif;font-size:14px;line-height:1.5;color:#303133}:host{--el-color-primary: #409eff;--el-input-border-color: #dcdfe6;--el-input-hover-border-color: #c0c4cc;--el-input-focus-border-color: var(--el-color-primary);--el-border-color: #dcdfe6;--el-border-color-hover: #c0c4cc;--el-disabled-bg-color: #f5f7fa;--el-disabled-border-color: #e4e7ed;--el-color-danger: #f56c6c;--el-transition-duration: .3s}");

    })
  };
}));

System.import("./__entry.js", "./");